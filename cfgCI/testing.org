#+title:     Testing various functions
#+author:    Vijay Gopal Chilkuri
#+email:     vijay.gopal.c@gmail.com

(org-babel-lob-injest "./theoryCFGCI.org")

* Testing C functions

** Simple unit tests with munit

#+begin_src C :tangle tests.c
#include <stdio.h>
#include "munit/munit.h"

void tests(){

    int foo = 1;
    int bar = 1;

    munit_assert_int(foo, ==, bar);

    printf("Hello world (munit-testing)\n");
}

#+end_src

#+begin_src bash :results output
emacs --batch --eval "(require 'org)" --eval '(org-babel-tangle-file "testing.org")'
gcc -o tests tests.c munit/munit.c
./tests 2>&1
rm tests
#+end_src

#+RESULTS:
#+begin_example
Hello world (munit-testing)
#+end_example

** TODO[2/2] Testing BF overlap matrix

- [X] 2x2 case

The overlap matrix for the BF with 4 SOMOs is of dimension 2x2 and is shown below:

#+begin_src python :results output :wrap ""
import numpy
import sys

bfmat = numpy.zeros(shape=(2,6),dtype=float)
#vec1
bfmat[0,0] = 1/2
bfmat[0,1] =-1/2
bfmat[0,2] =-1/2
bfmat[0,3] = 1/2
#vec2
bfmat[1,0] =-1/2
bfmat[1,3] =-1/2
bfmat[1,4] = 1/2
bfmat[1,5] = 1/2
ovlp = numpy.dot(bfmat,bfmat.T)
#print(numpy.dot(bfmat,bfmat.T))
#numpy.savetxt(sys.stdout, bfmat.T, fmt="|%4.2f")
for el in ovlp:
    print(' '.join(el.astype(str)))
#+end_src

#+RESULTS:
1.0 -0.5
-0.5 1.0

#+name: bfmat
+----+----+
|1.0 |-0.5|
+----+----+
|-0.5|1.0 |
+----+----+

Now this should match with the C code of the library.

#+include: "./theoryCFGCI.org" src

#+name: testOvlpMatrix2x2
#+begin_src C :main no :noweb yes #:tangle tests.c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

<<getOverlapMatrix>>
<<generateAllBFs>>
<<treefuncmain>>
<<indexlist>>
<<calculateIslands>>
<<getNsomo>>
<<inttobindigit>>

int main(){
    int64_t Isomo = ((1<<4)-1);
    int64_t MS=0;
    double *overlapMatrix;
    int rows=0;
    int cols=0;
    int NSOMOout=0;
    int test_ovlp_matrix = 0;

    // The correct overlap matrix
    double *ovlp_matrix_check = malloc(2*2*sizeof(double));
    ovlp_matrix_check[0*2 + 0] = 1.0;
    ovlp_matrix_check[0*2 + 1] =-0.5;
    ovlp_matrix_check[1*2 + 0] =-0.5;
    ovlp_matrix_check[1*2 + 1] = 1.0;

    getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);
    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(overlapMatrix[i*cols + j] != ovlp_matrix_check[i*cols + j]) test_ovlp_matrix = -1;
        }
    }

    //printRealMatrix(overlapMatrix,rows,cols);
    printf("test_ovlp_matrix_NSOMO4=%d\n",test_ovlp_matrix);
    free(overlapMatrix);
    return(test_ovlp_matrix);
}
#+end_src



- [X] 4x4 case

The overlap matrix for the BF with 4 SOMOs is of dimension 2x2 and is shown below:

#+begin_src python :results output
import numpy
import sys

bfmat = numpy.zeros(shape=(5,20),dtype=float)
coeff = 1.0/(2.0*numpy.sqrt(2.0))
#vec1
bfmat[1,0] = 0.0
bfmat[1,1] = 0.0
bfmat[1,2] = 0.0
bfmat[1,3] = 0.0
bfmat[1,4] = 0.0
bfmat[1,5] = coeff
bfmat[1,6] =-coeff
bfmat[1,7] =-coeff
bfmat[1,8] = coeff
bfmat[1,9] = 0.0
bfmat[1,10] = 0.0
bfmat[1,11] =-coeff
bfmat[1,12] = coeff
bfmat[1,13] = coeff
bfmat[1,14] =-coeff
bfmat[1,15] = 0.0
bfmat[1,16] = 0.0
bfmat[1,17] = 0.0
bfmat[1,18] = 0.0
bfmat[1,19] = 0.0
#vec2
bfmat[0,0] = 0.0
bfmat[0,1] = 0.0
bfmat[0,2] = coeff
bfmat[0,3] =-coeff
bfmat[0,4] = 0.0
bfmat[0,5] =-coeff
bfmat[0,6] = 0.0
bfmat[0,7] = coeff
bfmat[0,8] = 0.0
bfmat[0,9] = 0.0
bfmat[0,10] = 0.0
bfmat[0,11] = 0.0
bfmat[0,12] = 0.0
bfmat[0,13] =-coeff
bfmat[0,14] = coeff
bfmat[0,15] = 0.0
bfmat[0,16] = coeff
bfmat[0,17] =-coeff
bfmat[0,18] = 0.0
bfmat[0,19] = 0.0
#vec3
bfmat[3,0] = 0.0
bfmat[3,1] = 0.0
bfmat[3,2] = 0.0
bfmat[3,3] = 0.0
bfmat[3,4] = coeff
bfmat[3,5] =-coeff
bfmat[3,6] = 0.0
bfmat[3,7] = 0.0
bfmat[3,8] =-coeff
bfmat[3,9] = coeff
bfmat[3,10] =-coeff
bfmat[3,11] = coeff
bfmat[3,12] = 0.0
bfmat[3,13] = 0.0
bfmat[3,14] = coeff
bfmat[3,15] =-coeff
bfmat[3,16] = 0.0
bfmat[3,17] = 0.0
bfmat[3,18] = 0.0
bfmat[3,19] = 0.0
#vec4
bfmat[2,0] = coeff
bfmat[2,1] =-coeff
bfmat[2,2] = 0.0
bfmat[2,3] = 0.0
bfmat[2,4] = 0.0
bfmat[2,5] =-coeff
bfmat[2,6] = coeff
bfmat[2,7] = 0.0
bfmat[2,8] = 0.0
bfmat[2,9] = 0.0
bfmat[2,10] = 0.0
bfmat[2,11] = 0.0
bfmat[2,12] =-coeff
bfmat[2,13] = 0.0
bfmat[2,14] = coeff
bfmat[2,15] = 0.0
bfmat[2,16] = 0.0
bfmat[2,17] = 0.0
bfmat[2,18] = coeff
bfmat[2,19] =-coeff
#vec5
bfmat[4,0] = 0.0
bfmat[4,1] = coeff
bfmat[4,2] =-coeff
bfmat[4,3] = 0.0
bfmat[4,4] =-coeff
bfmat[4,5] = coeff
bfmat[4,6] = 0.0
bfmat[4,7] = 0.0
bfmat[4,8] = 0.0
bfmat[4,9] = 0.0
bfmat[4,10] = 0.0
bfmat[4,11] = 0.0
bfmat[4,12] = 0.0
bfmat[4,13] = 0.0
bfmat[4,14] =-coeff
bfmat[4,15] = coeff
bfmat[4,16] = 0.0
bfmat[4,17] = coeff
bfmat[4,18] =-coeff
bfmat[4,19] = 0.0
ovlp = numpy.dot(bfmat,bfmat.T)
#print(numpy.dot(bfmat,bfmat.T))
#numpy.savetxt(sys.stdout, bfmat.T, fmt="|%4.2f")
for el in ovlp:
    print(' '.join(el.astype(str)))
#+end_src

#+name: ovlmat4x4
+--------------------+--------------------+--------------------+--------------------+--------------------+
|0.9999999999999999   |-0.49999999999999994|0.24999999999999994 |0.24999999999999994 |-0.49999999999999994|
+--------------------+--------------------+--------------------+--------------------+--------------------+
|-0.49999999999999994| 0.9999999999999999 |-0.49999999999999994|-0.49999999999999994|0.24999999999999994 |
+--------------------+--------------------+--------------------+--------------------+--------------------+
|0.24999999999999994 |-0.49999999999999994| 0.9999999999999999 |0.24999999999999994 |-0.49999999999999994|
+--------------------+--------------------+--------------------+--------------------+--------------------+
|0.24999999999999994 |-0.49999999999999994|0.24999999999999994 | 0.9999999999999999 |-0.49999999999999994|
+--------------------+--------------------+--------------------+--------------------+--------------------+
|-0.49999999999999994|0.24999999999999994 |-0.49999999999999994|-0.49999999999999994| 0.9999999999999999 |
+--------------------+--------------------+--------------------+--------------------+--------------------+

Now this should match with the C code of the library.

#+name: testOvlpMatrix4x4
#+begin_src C :main no :noweb yes #:tangle tests.c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

<<getOverlapMatrix>>
<<generateAllBFs>>
<<treefuncmain>>
<<indexlist>>
<<calculateIslands>>
<<getNsomo>>
<<inttobindigit>>

int main(){
    int64_t Isomo = ((1<<6)-1);
    int64_t MS=0;
    double *overlapMatrix;
    int rows=0;
    int cols=0;
    int NSOMOout=0;
    int test_ovlp_matrix = 0;

    // The correct overlap matrix
    double *ovlp_matrix_check = malloc(5*5*sizeof(double));
    ovlp_matrix_check[0*5 + 0] = 1.0;
    ovlp_matrix_check[0*5 + 1] =-0.5;
    ovlp_matrix_check[0*5 + 2] = 0.25;
    ovlp_matrix_check[0*5 + 3] = 0.25;
    ovlp_matrix_check[0*5 + 4] =-0.5;
    ovlp_matrix_check[1*5 + 0] =-0.5;
    ovlp_matrix_check[1*5 + 1] = 1.0;
    ovlp_matrix_check[1*5 + 2] =-0.5;
    ovlp_matrix_check[1*5 + 3] =-0.5;
    ovlp_matrix_check[1*5 + 4] = 0.25;
    ovlp_matrix_check[2*5 + 0] = 0.25;
    ovlp_matrix_check[2*5 + 1] =-0.5;
    ovlp_matrix_check[2*5 + 2] = 1.0;
    ovlp_matrix_check[2*5 + 3] = 0.25;
    ovlp_matrix_check[2*5 + 4] =-0.5;
    ovlp_matrix_check[3*5 + 0] = 0.25;
    ovlp_matrix_check[3*5 + 1] =-0.5;
    ovlp_matrix_check[3*5 + 2] = 0.25;
    ovlp_matrix_check[3*5 + 3] = 1.0;
    ovlp_matrix_check[3*5 + 4] =-0.5;
    ovlp_matrix_check[4*5 + 0] =-0.5;
    ovlp_matrix_check[4*5 + 1] = 0.25;
    ovlp_matrix_check[4*5 + 2] =-0.5;
    ovlp_matrix_check[4*5 + 3] =-0.5;
    ovlp_matrix_check[4*5 + 4] = 1.0;

    getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);
    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(overlapMatrix[i*cols + j] != ovlp_matrix_check[i*cols + j]) test_ovlp_matrix = -1;
        }
    }

    //printRealMatrix(overlapMatrix,rows,cols);
    free(overlapMatrix);
    printf("\ntest_ovlp_matrix6x6=%d\n",test_ovlp_matrix);
    return(test_ovlp_matrix);
}
#+end_src


** TODO[1/2] Testing gram-schmidt orthonormalization

- [X] Test orthonormalization matrix for 4 SOMO case

  The orthonormalization matrix for 4 SOMO case is a 2x2 matrix and is very simple to derive.

  #+name: 2x2orthonorm
  | 0.8944 | 0.4472 |
  |    0.0 |    1.0 |

#+name: orthoMatrix4SOMO
#+begin_src C :noweb yes :main no :libs -lm
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

<<getOverlapMatrix>>
<<generateAllBFs>>
<<treefuncmain>>
<<indexlist>>
<<calculateIslands>>
<<getNsomo>>
<<inttobindigit>>
<<gramSchmidt>>

int main(){
    int64_t Isomo = ((1<<4)-1);
    int64_t MS=0;
    double *overlapMatrix;
    double *orthoMatrix;
    int rows=0;
    int cols=0;
    int NSOMOout=0;
    int test_ortho_matrix = 0;

    // The correct overlap matrix
    double *ortho_matrix_check = malloc(2*2*sizeof(double));
    ortho_matrix_check[0*2 + 0] = 0.8944271909999158785636694674925104941762473438446102897083588981;
    ortho_matrix_check[0*2 + 1] = 0.4472135954999579392818347337462552470881236719223051448541794490;
    ortho_matrix_check[1*2 + 0] = 0.0;
    ortho_matrix_check[1*2 + 1] = 1.0;

    getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);

    orthoMatrix = malloc(rows*cols*sizeof(double));

    gramSchmidt(overlapMatrix, rows, cols, orthoMatrix);

    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(fabs(orthoMatrix[i*cols + j] - ortho_matrix_check[i*cols + j]) > 1e-16) test_ortho_matrix = -1;
        }
    }

    printRealMatrix(orthoMatrix,rows,cols);
    printf("test_ortho_matrix_NSOMO4=%d\n",test_ortho_matrix);

    // Garbage collection
    free(overlapMatrix);
    free(orthoMatrix);

    return(test_ortho_matrix);
}


#+end_src

#+RESULTS:
|                            |      |
|                       0.89 | 0.45 |
|                        0.0 |  1.0 |
| test_ortho_matrix_NSOMO4=0 |      |

- [ ] Test orthonormalization matrix for 6 SOMO case

  The orthonormalization matrix for 6 SOMO case is a 5x5 matrix the first three rows of which are:

  #+name: 4x4orthonorm
  | 0.9225 | 0.3094 |-0.2306 |
  |    0.0 | 0.8944 | 0.4472 |
  |    0.0 |    0.0 |    1.0 |

  #+name: orthoMatrix6SOMO
  #+begin_src C :noweb yes :main no :libs -lm
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdint.h>
  #include <math.h>
  #include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

  <<getOverlapMatrix>>
  <<generateAllBFs>>
  <<treefuncmain>>
  <<indexlist>>
  <<calculateIslands>>
  <<getNsomo>>
  <<inttobindigit>>
  <<gramSchmidt>>

  int main(){
      int64_t Isomo = ((1<<6)-1);
      int64_t MS=0;
      double *overlapMatrix;
      double *orthoMatrix;
      int rows=0;
      int cols=0;
      int NSOMOout=0;
      int test_ortho_matrix = 0;

      // The correct overlap matrix
      // TODO
      double *ortho_matrix_check = malloc(2*2*sizeof(double));
      ortho_matrix_check[0*5 + 0] = 1.0;
      ortho_matrix_check[0*5 + 1] =-0.5;
      ortho_matrix_check[0*5 + 2] = 0.25;
      ortho_matrix_check[0*5 + 3] = 0.25;
      ortho_matrix_check[0*5 + 4] =-0.5;
      ortho_matrix_check[1*5 + 0] =-0.5;
      ortho_matrix_check[1*5 + 1] = 1.0;
      ortho_matrix_check[1*5 + 2] =-0.5;
      ortho_matrix_check[1*5 + 3] =-0.5;
      ortho_matrix_check[1*5 + 4] = 0.25;
      ortho_matrix_check[2*5 + 0] = 0.25;
      ortho_matrix_check[2*5 + 1] =-0.5;
      ortho_matrix_check[2*5 + 2] = 1.0;
      ortho_matrix_check[2*5 + 3] = 0.25;
      ortho_matrix_check[2*5 + 4] =-0.5;
      ortho_matrix_check[3*5 + 0] = 0.25;
      ortho_matrix_check[3*5 + 1] =-0.5;
      ortho_matrix_check[3*5 + 2] = 0.25;
      ortho_matrix_check[3*5 + 3] = 1.0;
      ortho_matrix_check[3*5 + 4] =-0.5;
      ortho_matrix_check[4*5 + 0] =-0.5;
      ortho_matrix_check[4*5 + 1] = 0.25;
      ortho_matrix_check[4*5 + 2] =-0.5;
      ortho_matrix_check[4*5 + 3] =-0.5;
      ortho_matrix_check[4*5 + 4] = 1.0;

      getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);

      orthoMatrix = malloc(rows*cols*sizeof(double));

      gramSchmidt(overlapMatrix, rows, cols, orthoMatrix);

      //for(int i=0;i<rows;i++){
      //    for(int j=0;j<cols;j++){
      //        if(fabs(orthoMatrix[i*cols + j] - ortho_matrix_check[i*cols + j]) > 1e-16) test_ortho_matrix = -1;
      //    }
      //}

      printRealMatrix(orthoMatrix,rows,cols);
      printf("test_ortho_matrix_NSOMO4=%d\n",test_ortho_matrix);

      // Garbage collection
      free(overlapMatrix);
      free(orthoMatrix);

      return(test_ortho_matrix);
  }


  #+end_src

  #+RESULTS: orthoMatrix6SOMO
|                            |      |      |      |       |
|                       0.88 | 0.16 |  0.0 |  0.0 |  0.44 |
|                        0.0 | 0.88 |  0.3 |  0.3 | -0.22 |
|                        0.0 |  0.0 | 0.89 |  0.0 |  0.45 |
|                        0.0 |  0.0 |  0.0 | 0.89 |  0.45 |
|                        0.0 |  0.0 |  0.0 |  0.0 |   1.0 |
| test_ortho_matrix_NSOMO4=0 |      |      |      |       |
