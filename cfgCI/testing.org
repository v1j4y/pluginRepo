#+title:     Testing various functions
#+author:    Vijay Gopal Chilkuri
#+email:     vijay.gopal.c@gmail.com

(org-babel-lob-injest "./theoryCFGCI.org")

* Testing C functions

** Simple unit tests with munit

#+begin_src C :tangle tests.c
#include <stdio.h>
#include "munit/munit.h"

void tests(){

    int foo = 1;
    int bar = 1;

    munit_assert_int(foo, ==, bar);

    printf("Hello world (munit-testing)\n");
}

#+end_src

#+begin_src bash :results output
emacs --batch --eval "(require 'org)" --eval '(org-babel-tangle-file "testing.org")'
gcc -o tests tests.c munit/munit.c
./tests 2>&1
rm tests
#+end_src

#+RESULTS:
#+begin_example
Hello world (munit-testing)
#+end_example


* Testing CSF creation

** TODO[2/2] Testing BF overlap matrix

- [X] 2x2 case

The overlap matrix for the BF with 4 SOMOs is of dimension 2x2 and is shown below:

#+begin_src python :results output :wrap ""
import numpy
import sys

bfmat = numpy.zeros(shape=(2,6),dtype=float)
#vec1
bfmat[0,0] = 1/2
bfmat[0,1] =-1/2
bfmat[0,2] =-1/2
bfmat[0,3] = 1/2
#vec2
bfmat[1,0] =-1/2
bfmat[1,3] =-1/2
bfmat[1,4] = 1/2
bfmat[1,5] = 1/2
ovlp = numpy.dot(bfmat,bfmat.T)
#print(numpy.dot(bfmat,bfmat.T))
#numpy.savetxt(sys.stdout, bfmat.T, fmt="|%4.2f")
for el in ovlp:
    print(' '.join(el.astype(str)))
#+end_src

#+RESULTS:
1.0 -0.5
-0.5 1.0

#+name: bfmat
+----+----+
|1.0 |-0.5|
+----+----+
|-0.5|1.0 |
+----+----+

Now this should match with the C code of the library.

#+include: "./theoryCFGCI.org" src

#+name: testOvlpMatrix2x2
#+begin_src C :main no :noweb yes #:tangle tests.c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

<<getOverlapMatrix>>
<<generateAllBFs>>
<<treefuncmain>>
<<indexlist>>
<<calculateIslands>>
<<getNsomo>>
<<inttobindigit>>

int main(){
    int64_t Isomo = ((1<<4)-1);
    int64_t MS=0;
    double *overlapMatrix;
    int rows=0;
    int cols=0;
    int NSOMOout=0;
    int test_ovlp_matrix = 0;

    // The correct overlap matrix
    double *ovlp_matrix_check = malloc(2*2*sizeof(double));
    ovlp_matrix_check[0*2 + 0] = 1.0;
    ovlp_matrix_check[0*2 + 1] =-0.5;
    ovlp_matrix_check[1*2 + 0] =-0.5;
    ovlp_matrix_check[1*2 + 1] = 1.0;

    getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);
    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(overlapMatrix[i*cols + j] != ovlp_matrix_check[i*cols + j]) test_ovlp_matrix = -1;
        }
    }

    //printRealMatrix(overlapMatrix,rows,cols);
    printf("test_ovlp_matrix_NSOMO4=%d\n",test_ovlp_matrix);
    free(overlapMatrix);
    return(test_ovlp_matrix);
}
#+end_src



- [X] 4x4 case

The overlap matrix for the BF with 4 SOMOs is of dimension 2x2 and is shown below:

#+begin_src python :results output
import numpy
import sys

bfmat = numpy.zeros(shape=(5,20),dtype=float)
coeff = 1.0/(2.0*numpy.sqrt(2.0))
#vec1
bfmat[1,0] = 0.0
bfmat[1,1] = 0.0
bfmat[1,2] = 0.0
bfmat[1,3] = 0.0
bfmat[1,4] = 0.0
bfmat[1,5] = coeff
bfmat[1,6] =-coeff
bfmat[1,7] =-coeff
bfmat[1,8] = coeff
bfmat[1,9] = 0.0
bfmat[1,10] = 0.0
bfmat[1,11] =-coeff
bfmat[1,12] = coeff
bfmat[1,13] = coeff
bfmat[1,14] =-coeff
bfmat[1,15] = 0.0
bfmat[1,16] = 0.0
bfmat[1,17] = 0.0
bfmat[1,18] = 0.0
bfmat[1,19] = 0.0
#vec2
bfmat[0,0] = 0.0
bfmat[0,1] = 0.0
bfmat[0,2] = coeff
bfmat[0,3] =-coeff
bfmat[0,4] = 0.0
bfmat[0,5] =-coeff
bfmat[0,6] = 0.0
bfmat[0,7] = coeff
bfmat[0,8] = 0.0
bfmat[0,9] = 0.0
bfmat[0,10] = 0.0
bfmat[0,11] = 0.0
bfmat[0,12] = 0.0
bfmat[0,13] =-coeff
bfmat[0,14] = coeff
bfmat[0,15] = 0.0
bfmat[0,16] = coeff
bfmat[0,17] =-coeff
bfmat[0,18] = 0.0
bfmat[0,19] = 0.0
#vec3
bfmat[3,0] = 0.0
bfmat[3,1] = 0.0
bfmat[3,2] = 0.0
bfmat[3,3] = 0.0
bfmat[3,4] = coeff
bfmat[3,5] =-coeff
bfmat[3,6] = 0.0
bfmat[3,7] = 0.0
bfmat[3,8] =-coeff
bfmat[3,9] = coeff
bfmat[3,10] =-coeff
bfmat[3,11] = coeff
bfmat[3,12] = 0.0
bfmat[3,13] = 0.0
bfmat[3,14] = coeff
bfmat[3,15] =-coeff
bfmat[3,16] = 0.0
bfmat[3,17] = 0.0
bfmat[3,18] = 0.0
bfmat[3,19] = 0.0
#vec4
bfmat[2,0] = coeff
bfmat[2,1] =-coeff
bfmat[2,2] = 0.0
bfmat[2,3] = 0.0
bfmat[2,4] = 0.0
bfmat[2,5] =-coeff
bfmat[2,6] = coeff
bfmat[2,7] = 0.0
bfmat[2,8] = 0.0
bfmat[2,9] = 0.0
bfmat[2,10] = 0.0
bfmat[2,11] = 0.0
bfmat[2,12] =-coeff
bfmat[2,13] = 0.0
bfmat[2,14] = coeff
bfmat[2,15] = 0.0
bfmat[2,16] = 0.0
bfmat[2,17] = 0.0
bfmat[2,18] = coeff
bfmat[2,19] =-coeff
#vec5
bfmat[4,0] = 0.0
bfmat[4,1] = coeff
bfmat[4,2] =-coeff
bfmat[4,3] = 0.0
bfmat[4,4] =-coeff
bfmat[4,5] = coeff
bfmat[4,6] = 0.0
bfmat[4,7] = 0.0
bfmat[4,8] = 0.0
bfmat[4,9] = 0.0
bfmat[4,10] = 0.0
bfmat[4,11] = 0.0
bfmat[4,12] = 0.0
bfmat[4,13] = 0.0
bfmat[4,14] =-coeff
bfmat[4,15] = coeff
bfmat[4,16] = 0.0
bfmat[4,17] = coeff
bfmat[4,18] =-coeff
bfmat[4,19] = 0.0
ovlp = numpy.dot(bfmat,bfmat.T)
#print(numpy.dot(bfmat,bfmat.T))
#numpy.savetxt(sys.stdout, bfmat.T, fmt="|%4.2f")
for el in ovlp:
    print(' '.join(el.astype(str)))
#+end_src

#+name: ovlmat4x4
+--------------------+--------------------+--------------------+--------------------+--------------------+
|0.9999999999999999   |-0.49999999999999994|0.24999999999999994 |0.24999999999999994 |-0.49999999999999994|
+--------------------+--------------------+--------------------+--------------------+--------------------+
|-0.49999999999999994| 0.9999999999999999 |-0.49999999999999994|-0.49999999999999994|0.24999999999999994 |
+--------------------+--------------------+--------------------+--------------------+--------------------+
|0.24999999999999994 |-0.49999999999999994| 0.9999999999999999 |0.24999999999999994 |-0.49999999999999994|
+--------------------+--------------------+--------------------+--------------------+--------------------+
|0.24999999999999994 |-0.49999999999999994|0.24999999999999994 | 0.9999999999999999 |-0.49999999999999994|
+--------------------+--------------------+--------------------+--------------------+--------------------+
|-0.49999999999999994|0.24999999999999994 |-0.49999999999999994|-0.49999999999999994| 0.9999999999999999 |
+--------------------+--------------------+--------------------+--------------------+--------------------+

Now this should match with the C code of the library.

#+name: testOvlpMatrix4x4
#+begin_src C :main no :noweb yes #:tangle tests.c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

<<getOverlapMatrix>>
<<generateAllBFs>>
<<treefuncmain>>
<<indexlist>>
<<calculateIslands>>
<<getNsomo>>
<<inttobindigit>>

int main(){
    int64_t Isomo = ((1<<6)-1);
    int64_t MS=0;
    double *overlapMatrix;
    int rows=0;
    int cols=0;
    int NSOMOout=0;
    int test_ovlp_matrix = 0;

    // The correct overlap matrix
    double *ovlp_matrix_check = malloc(5*5*sizeof(double));
    ovlp_matrix_check[0*5 + 0] = 1.0;
    ovlp_matrix_check[0*5 + 1] =-0.5;
    ovlp_matrix_check[0*5 + 2] = 0.25;
    ovlp_matrix_check[0*5 + 3] = 0.25;
    ovlp_matrix_check[0*5 + 4] =-0.5;
    ovlp_matrix_check[1*5 + 0] =-0.5;
    ovlp_matrix_check[1*5 + 1] = 1.0;
    ovlp_matrix_check[1*5 + 2] =-0.5;
    ovlp_matrix_check[1*5 + 3] =-0.5;
    ovlp_matrix_check[1*5 + 4] = 0.25;
    ovlp_matrix_check[2*5 + 0] = 0.25;
    ovlp_matrix_check[2*5 + 1] =-0.5;
    ovlp_matrix_check[2*5 + 2] = 1.0;
    ovlp_matrix_check[2*5 + 3] = 0.25;
    ovlp_matrix_check[2*5 + 4] =-0.5;
    ovlp_matrix_check[3*5 + 0] = 0.25;
    ovlp_matrix_check[3*5 + 1] =-0.5;
    ovlp_matrix_check[3*5 + 2] = 0.25;
    ovlp_matrix_check[3*5 + 3] = 1.0;
    ovlp_matrix_check[3*5 + 4] =-0.5;
    ovlp_matrix_check[4*5 + 0] =-0.5;
    ovlp_matrix_check[4*5 + 1] = 0.25;
    ovlp_matrix_check[4*5 + 2] =-0.5;
    ovlp_matrix_check[4*5 + 3] =-0.5;
    ovlp_matrix_check[4*5 + 4] = 1.0;

    getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);
    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(overlapMatrix[i*cols + j] != ovlp_matrix_check[i*cols + j]) test_ovlp_matrix = -1;
        }
    }

    //printRealMatrix(overlapMatrix,rows,cols);
    free(overlapMatrix);
    printf("\ntest_ovlp_matrix6x6=%d\n",test_ovlp_matrix);
    return(test_ovlp_matrix);
}
#+end_src


** TODO[1/2] Testing gram-schmidt orthonormalization


- [X] Test orthonormalization matrix for 4 SOMO case

  The orthonormalization matrix for 4 SOMO case is a 2x2 matrix and is very simple to derive.

  #+name: 2x2orthonorm
  | 0.8944 | 0.4472 |
  |    0.0 |    1.0 |

#+name: orthoMatrix4SOMO
#+begin_src C :noweb yes :main no :libs -lm
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

<<getOverlapMatrix>>
<<generateAllBFs>>
<<treefuncmain>>
<<indexlist>>
<<calculateIslands>>
<<getNsomo>>
<<inttobindigit>>
<<gramSchmidt>>

int main(){
    int64_t Isomo = ((1<<4)-1);
    int64_t MS=0;
    double *overlapMatrix;
    double *orthoMatrix;
    int rows=0;
    int cols=0;
    int NSOMOout=0;
    int test_ortho_matrix = 0;

    // The correct overlap matrix
    double *ortho_matrix_check = malloc(2*2*sizeof(double));
    ortho_matrix_check[0*2 + 0] = 0.8944271909999158785636694674925104941762473438446102897083588981;
    ortho_matrix_check[0*2 + 1] = 0.4472135954999579392818347337462552470881236719223051448541794490;
    ortho_matrix_check[1*2 + 0] = 0.0;
    ortho_matrix_check[1*2 + 1] = 1.0;

    getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);

    orthoMatrix = malloc(rows*cols*sizeof(double));

    gramSchmidt(overlapMatrix, rows, cols, orthoMatrix);

    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(fabs(orthoMatrix[i*cols + j] - ortho_matrix_check[i*cols + j]) > 1e-16) test_ortho_matrix = -1;
        }
    }

    printRealMatrix(orthoMatrix,rows,cols);
    printf("test_ortho_matrix_NSOMO4=%d\n",test_ortho_matrix);

    // Garbage collection
    free(overlapMatrix);
    free(orthoMatrix);

    return(test_ortho_matrix);
}


#+end_src

#+RESULTS: orthoMatrix4SOMO

#+RESULTS:
|                            |      |
|                       0.89 | 0.45 |
|                        0.0 |  1.0 |
| test_ortho_matrix_NSOMO4=0 |      |

- [ ] Test orthonormalization matrix for 6 SOMO case

  The orthonormalization matrix for 6 SOMO case is a 5x5 matrix the first three rows of which are:

  #+name: 4x4orthonorm
  | 0.9225 | 0.3094 |-0.2306 |
  |    0.0 | 0.8944 | 0.4472 |
  |    0.0 |    0.0 |    1.0 |

  #+name: orthoMatrix6SOMO
  #+begin_src C :noweb yes :main no :libs -lm
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdint.h>
  #include <math.h>
  #include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

  <<getOverlapMatrix>>
  <<generateAllBFs>>
  <<treefuncmain>>
  <<indexlist>>
  <<calculateIslands>>
  <<getNsomo>>
  <<inttobindigit>>
  <<gramSchmidt>>

  int main(){
      int64_t Isomo = ((1<<6)-1);
      int64_t MS=0;
      double *overlapMatrix;
      double *orthoMatrix;
      int rows=0;
      int cols=0;
      int NSOMOout=0;
      int test_ortho_matrix = 0;

      // The correct overlap matrix
      // TODO
      double *ortho_matrix_check = malloc(2*2*sizeof(double));
      ortho_matrix_check[0*5 + 0] = 1.0;
      ortho_matrix_check[0*5 + 1] =-0.5;
      ortho_matrix_check[0*5 + 2] = 0.25;
      ortho_matrix_check[0*5 + 3] = 0.25;
      ortho_matrix_check[0*5 + 4] =-0.5;
      ortho_matrix_check[1*5 + 0] =-0.5;
      ortho_matrix_check[1*5 + 1] = 1.0;
      ortho_matrix_check[1*5 + 2] =-0.5;
      ortho_matrix_check[1*5 + 3] =-0.5;
      ortho_matrix_check[1*5 + 4] = 0.25;
      ortho_matrix_check[2*5 + 0] = 0.25;
      ortho_matrix_check[2*5 + 1] =-0.5;
      ortho_matrix_check[2*5 + 2] = 1.0;
      ortho_matrix_check[2*5 + 3] = 0.25;
      ortho_matrix_check[2*5 + 4] =-0.5;
      ortho_matrix_check[3*5 + 0] = 0.25;
      ortho_matrix_check[3*5 + 1] =-0.5;
      ortho_matrix_check[3*5 + 2] = 0.25;
      ortho_matrix_check[3*5 + 3] = 1.0;
      ortho_matrix_check[3*5 + 4] =-0.5;
      ortho_matrix_check[4*5 + 0] =-0.5;
      ortho_matrix_check[4*5 + 1] = 0.25;
      ortho_matrix_check[4*5 + 2] =-0.5;
      ortho_matrix_check[4*5 + 3] =-0.5;
      ortho_matrix_check[4*5 + 4] = 1.0;

      getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);

      orthoMatrix = malloc(rows*cols*sizeof(double));

      gramSchmidt(overlapMatrix, rows, cols, orthoMatrix);

      //for(int i=0;i<rows;i++){
      //    for(int j=0;j<cols;j++){
      //        if(fabs(orthoMatrix[i*cols + j] - ortho_matrix_check[i*cols + j]) > 1e-16) test_ortho_matrix = -1;
      //    }
      //}

      printRealMatrix(orthoMatrix,rows,cols);
      printf("test_ortho_matrix_NSOMO4=%d\n",test_ortho_matrix);

      // Garbage collection
      free(overlapMatrix);
      free(orthoMatrix);

      return(test_ortho_matrix);
  }


  #+end_src

  #+RESULTS: orthoMatrix6SOMO
|                            |      |      |      |       |
|                       0.88 | 0.16 |  0.0 |  0.0 |  0.44 |
|                        0.0 | 0.88 |  0.3 |  0.3 | -0.22 |
|                        0.0 |  0.0 | 0.89 |  0.0 |  0.45 |
|                        0.0 |  0.0 |  0.0 | 0.89 |  0.45 |
|                        0.0 |  0.0 |  0.0 |  0.0 |   1.0 |
| test_ortho_matrix_NSOMO4=0 |      |      |      |       |


* Testing conversion of DET to CSF

** TODO[1/2] Test CSF to Det matrix

- [X] small 2 by 6 : 4 SOMOs

#+name: testcsftodet4somo
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>



int main(){
    int64_t Isomo = ((1<<4)-1);
    int64_t MS=0;
    double *overlapMatrix;
    double *orthoMatrix;
    double *csftodetmatrix;
    int rows=2;
    int cols=6;
    int NSOMOout=0;
    int test_ortho_matrix = 0;
    double norm = 0.0;

    csftodetmatrix = malloc(rows*cols*sizeof(double));

    convertCSFtoDetBasis(Isomo, MS, rows, cols, csftodetmatrix);

    printRealMatrix(csftodetmatrix,cols,rows);
    printf("test_ortho_matrix_NSOMO4=%d\n",test_ortho_matrix);

    // Garbage collection
    free(csftodetmatrix);

    return(test_ortho_matrix);
}



#+end_src

#+RESULTS: testcsftodet4somo
#+begin_example

      0.58       0.00
     -0.29       0.50
     -0.29      -0.50
     -0.29      -0.50
     -0.29       0.50
      0.58       0.00
test_ortho_matrix_NSOMO4=0
#+end_example

#+begin_src python :results output

import numpy

a = numpy.array([[1,0],[numpy.sqrt(1/3),numpy.sqrt(4/3)]])
b = numpy.array([[0.5,-0.5,0,0,-0.5,0.5],[0,0.5,-0.5,-0.5,0.5,0]])
d = numpy.array([[1.0,-0.5],[-0.5,1.0]])
print(a)
b[0] = b[0]*numpy.sqrt(4./3.) + b[1]*numpy.sqrt(1./3.)
b[1] = b[1]
print(b)
c = numpy.array([-0.3,0.2,0.1,0.1,0.2,-0.3])
#c = c/numpy.linalg.norm(c)
print(numpy.linalg.norm(c))
print(numpy.dot(b,c))
print(numpy.linalg.norm(numpy.dot(b,c)))
#print(numpy.dot(b,b.T))
#print(numpy.dot(c,b.T))
#print(numpy.dot(a,d))
#+end_src

#+RESULTS:
#+begin_example
[[1.         0.        ]
 [0.57735027 1.15470054]]
[[ 0.57735027 -0.28867513 -0.28867513 -0.28867513 -0.28867513  0.57735027]
 [ 0.          0.5        -0.5        -0.5         0.5         0.        ]]
0.5291502622129182
[-0.51961524  0.1       ]
0.529150262212918
#+end_example

- [ ] small 5 by 20 : 6 SOMOs

#+name: testcsftodet6somo
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>



int main(){
    int64_t Isomo = ((1<<6)-1);
    int64_t MS=0;
    double *overlapMatrix;
    double *orthoMatrix;
    double *csftodetmatrix;
    int rows=5;
    int cols=20;
    int NSOMOout=0;
    int test_ortho_matrix = 0;
    double norm = 0.0;

    csftodetmatrix = malloc(rows*cols*sizeof(double));

    convertCSFtoDetBasis(Isomo, MS, rows, cols, csftodetmatrix);

    printRealMatrix(csftodetmatrix,rows,cols);
    printf("test_ortho_matrix_NSOMO4=%d\n",test_ortho_matrix);

    // Garbage collection
    free(csftodetmatrix);

    return(test_ortho_matrix);
}



#+end_src

#+RESULTS: testcsftodet6somo
#+begin_example

overlap matrix

      1.00      -0.50       0.25       0.25      -0.50
     -0.50       1.00      -0.50      -0.50       0.25
      0.25      -0.50       1.00       0.25      -0.50
      0.25      -0.50       0.25       1.00      -0.50
     -0.50       0.25      -0.50      -0.50       1.00

overlap matrix

overlap matrix

      0.75       0.34      -0.27      -0.24       0.69
      0.00       0.91       0.45       0.39      -0.54
      0.00       0.00       1.00      -0.29       0.79
      0.00       0.00       0.00       1.15       0.58
      0.00       0.00       0.00       0.00       1.00

overlap matrix

csf to det matrix

      0.35      -0.35       0.00       0.00       0.00      -0.35       0.00       0.35       0.00       0.00       0.00       0.00      -0.35       0.00       0.35       0.00       0.00       0.00       0.35      -0.35
      0.00       0.35      -0.35       0.00      -0.35       0.35       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00      -0.35       0.35       0.00       0.35      -0.35       0.00
      0.00       0.00       0.35      -0.35       0.00      -0.35       0.35       0.00       0.00       0.00       0.00       0.00       0.00      -0.35       0.35       0.00       0.35      -0.35       0.00       0.00
      0.00       0.00       0.00       0.00       0.35      -0.35       0.00       0.00      -0.35       0.35      -0.35       0.35       0.00       0.00       0.35      -0.35       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.35      -0.35      -0.35       0.35       0.00       0.00      -0.35       0.35       0.35      -0.35       0.00       0.00       0.00       0.00       0.00

csf to det matrix

      0.27      -0.15      -0.22       0.10      -0.20       0.28      -0.34       0.02       0.33      -0.08       0.08      -0.33      -0.02       0.34      -0.28       0.20      -0.10       0.22       0.15      -0.27
      0.00       0.32      -0.16      -0.16      -0.18      -0.17       0.35       0.19      -0.33       0.14      -0.14       0.33      -0.19      -0.35       0.17       0.18       0.16       0.16      -0.32       0.00
      0.00       0.00       0.35      -0.35      -0.10       0.03       0.07      -0.28       0.38      -0.10       0.10      -0.38       0.28      -0.07      -0.03       0.10       0.35      -0.35       0.00       0.00
      0.00       0.00       0.00       0.00       0.41      -0.20      -0.20      -0.20      -0.20       0.41      -0.41       0.20       0.20       0.20       0.20      -0.41       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.35      -0.35      -0.35       0.35       0.00       0.00      -0.35       0.35       0.35      -0.35       0.00       0.00       0.00       0.00       0.00
test_ortho_matrix_NSOMO4=0
#+end_example



#+begin_src python :results output
import numpy

a = numpy.array([[2.0/numpy.sqrt(3.0), 1.0/numpy.sqrt(3.0)],[0.0,1.0]])
b = numpy.array([
      [0.50     ,-0.50     , 0.00  ,    0.00  ,   -0.50  ,    0.50 ],
      [0.00     , 0.50     ,-0.50  ,   -0.50  ,    0.50  ,    0.00 ]
])
c = numpy.dot(a,b)
print(a)
print(c)
print(numpy.dot(c,c.T))

#+end_src

#+RESULTS:
#+begin_example
[[1.15470054 0.57735027]
 [0.         1.        ]]
[[ 0.57735027 -0.28867513 -0.28867513 -0.28867513 -0.28867513  0.57735027]
 [ 0.          0.5        -0.5        -0.5         0.5         0.        ]]
[[1. 0.]
 [0. 1.]]
#+end_example


* Testing generation of MEij matrices

** TODO[1/7] SOMO -> SOMO type

- [ ] Edge case 2 and 0 Somos

#+name: mematrixSOMOSOMO12
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{
    { 1.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      1.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      1.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      1.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      1.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      1.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 1.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      1.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      1.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      1.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      1.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 2;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1  1
    // |  |
    // 0  2
    // 2  1

    orbp = 2;
    orbq = 1;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    printf("1Done MEij\n");
    printRealMatrix(MEij,rows,cols);
    printf("1Done MEij\n");


    //for(int i=0;i<20;i++){
    //    for(int j=0;j<5;j++){
    //        munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
    //    }
    //}

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO12
#+begin_example
leading test 00000011
leading test 00000000
Idets=2
leading test 00000001
leading test 00000010
Jdets 1
leading test 00000000
1SOMO->SOMO
1Done MEij

      1.00
      1.00
1Done MEij
#+end_example

- [X] p = 6 q = 1

  The SOMO -> SOMO excitations are of the following type:
1 1 1 1 1 1
0 1 1 1 1 2
etc...

#+name: mematrixSOMOSOMO16
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{
    { 1.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      1.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      1.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      1.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      1.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      1.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 1.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      1.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      1.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      1.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      1.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 0 1 1 1 1 2
    // 6         1

    orbp = 6;
    orbq = 1;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO16
#+begin_example
SOMO->SOMO
#+end_example


- [ ] p = 6 q = 2

  The SOMO -> SOMO excitations are of the following type:
1 1 1 1 1 1
0 1 1 1 2 1
etc...

#+name: mematrixSOMOSOMO26
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{

   {  1.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     1.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,   -1.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    1.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,  -1.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,   -1.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   { -1.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,    -1.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    1.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,   -1.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   1.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 0 1 1 1 2 1
    // 6       2

    orbp = 6;
    orbq = 2;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-3)-1;
    Jsomo = Jsomo << 2;
    Jsomo = Jsomo + 1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO26
#+begin_example
SOMO->SOMO
#+end_example

- [ ] p = 5 q = 1

#+name: mematrixSOMOSOMO15
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{
   { -1.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,     -1.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,     -1.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  1.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      1.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      1.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      1.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      1.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      1.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,     -1.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,     -1.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,     -1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 1 0 1 1 1 2
    //   2       6

    orbp = 5;
    orbq = 1;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    //Jsomo = Jsomo + (1<<NMO-2);
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");
    //

    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO15
#+begin_example
1SOMO->SOMO
#+end_example

- [ ] p = 4 q = 1

#+name: mematrixSOMOSOMO14
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{
    { 1.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 1.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,    -1.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,    -1.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,    -1.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,    -1.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,    -1.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,  -1.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,    -1.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,  -1.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    1.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 1 0 1 1 1 2
    //   2       6

    orbp = 4;
    orbq = 1;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO14
#+begin_example
leading test 00111111
leading test 00001111
1SOMO->SOMO
#+end_example

- [ ] p = 1 q = 6

#+name: mematrixSOMOSOMO61
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{

    { 1.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     1.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     1.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    1.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     1.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     1.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 1.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     1.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     1.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    1.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     1.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 2 1 1 1 1 0
    // 6         1

    orbp = 1;
    orbq = 6;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    Jsomo = Jsomo << 1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO61
#+begin_example
leading test 00111111
leading test 00011110
2SOMO->SOMO
#+end_example

- [ ] p = 1 q = 4

#+name: mematrixSOMOSOMO41
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{

   {  1.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  1.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,    -1.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,    -1.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,    -1.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,    -1.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,    -1.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,  -1.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,    -1.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,  -1.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     1.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     1.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 1 2 1 1 1 0
    //   2       6

    orbp = 1;
    orbq = 4;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO41
#+begin_example
2SOMO->SOMO
#+end_example

** TODO[0/2] DOMO -> VMO

DOMO to VMO type for e.g.

- [ ] p = 6 q = 1

2 1 1 1 1 0
1 1 1 1 1 1

#+name: meijDOMOVMO61
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][20]=
{

      { 1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 2 1 1 1 1 0
    // |         |
    // 1 1 1 1 1 1
    // 6         1

    orbp = 6;
    orbq = 1;

    Isomo = ((1 << NMO-2)-1) << 1;
    Jsomo = (1 << NMO-0)-1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<20;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: meijDOMOVMO61
#+begin_example
leading test 00011110
leading test 00111111
1DOMO->VMO
#+end_example

- [ ] p = 6 q = 2

    2 1 1 1 0 1

    1 1 1 1 1 1

#+name: domovmo62
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][20]=
{


    { -1.00 ,     0.00 ,     0.00    ,  0.00 ,     0.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00    ,  1.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00   ,   0.00   ,   0.00  ,    0.00  ,    0.00},
    {  0.00 ,    -1.00 ,     0.00    ,  0.00 ,     0.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00    ,  0.00  ,    0.00  ,    1.00 ,     0.00  ,    0.00   ,   0.00   ,   0.00  ,    0.00  ,    0.00},
    {  0.00 ,     0.00 ,     0.00    ,  1.00 ,     0.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00    ,  0.00  ,    0.00  ,    0.00 ,     0.00  ,   -1.00   ,   0.00   ,   0.00  ,    0.00  ,    0.00},
    {  0.00 ,     0.00 ,     0.00    ,  0.00 ,    -1.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00    ,  0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00   ,   1.00   ,   0.00  ,    0.00  ,    0.00},
    {  0.00 ,     0.00 ,     0.00    ,  0.00 ,     0.00 ,     0.00  ,    1.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00    ,  0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00   ,   0.00   ,   0.00  ,   -1.00  ,    0.00},
    {  0.00 ,     0.00 ,     0.00    ,  0.00 ,     0.00 ,     0.00  ,    0.00  ,    0.00  ,    1.00  ,    0.00 ,     0.00    ,  0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00   ,   0.00   ,   0.00  ,    0.00  ,   -1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing DOMO -> VMO
    // 2 1 1 1 0 1
    // |       |
    // 1 1 1 1 1 1
    // 6       2

    orbp = 6;
    orbq = 2;

    Isomo = (1 << NMO-3)-1;
    Isomo = Isomo << 2;
    Isomo += 1;
    Jsomo = (1 << NMO-0)-1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<20;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
            //printf("%5.5f %5.5f \n",MEij[i*cols+j],MEijGood[i][j]);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: domovmo62
#+begin_example
leading test 00011101
leading test 00111111
1DOMO->VMO
#+end_example


- [ ] p = 5 q = 1

1 2 1 1 1 0
1 1 1 1 1 1

#+name: meijDOMOVMO51
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][20]=
{





  {   1.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,    -1.00   ,   0.00  ,    0.00   ,   0.00  ,    0.00  ,    0.00  ,    0.00   ,   0.00   ,   0.00    ,  0.00    ,  0.00    ,  0.00   ,   0.00  ,    0.00},
  {   0.00  ,    1.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,   -1.00   ,   0.00  ,    0.00  ,    0.00  ,    0.00   ,   0.00   ,   0.00    ,  0.00    ,  0.00    ,  0.00   ,   0.00  ,    0.00},
  {   0.00  ,    0.00  ,    1.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00   ,  -1.00  ,    0.00  ,    0.00  ,    0.00   ,   0.00   ,   0.00    ,  0.00    ,  0.00    ,  0.00   ,   0.00  ,    0.00},
  {   0.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00   ,   0.00  ,   -1.00  ,    0.00  ,    0.00   ,   0.00   ,   0.00    ,  0.00    ,  0.00    ,  1.00   ,   0.00  ,    0.00},
  {   0.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00   ,   0.00  ,    0.00  ,   -1.00  ,    0.00   ,   0.00   ,   0.00    ,  0.00    ,  0.00    ,  0.00   ,   1.00  ,    0.00},
  {   0.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00   ,   0.00  ,    0.00  ,    0.00  ,    0.00   ,  -1.00   ,   0.00    ,  0.00    ,  0.00    ,  0.00   ,   0.00  ,    1.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 2 1 1 1 0
    // |         |
    // 1 1 1 1 1 1
    //   5       1

    orbp = 5;
    orbq = 1;

    Isomo = ((1 << NMO-3)-1) << 1;
    Isomo = Isomo | (1UL << (NMO-1));
    Jsomo = (1 << NMO-0)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<20;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src


- [ ] p = 1 q = 6

#+name: meijDOMOVMO_16
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][20]=
{

      { 1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 0 1 1 1 1 2
    // |         |
    // 1 1 1 1 1 1
    // 6         1

    orbp = 1;
    orbq = 6;

    Isomo = ((1 << NMO-2)-1) << 1;
    Jsomo = (1 << NMO-0)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<20;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: meijDOMOVMO_16
#+begin_example
2DOMO->VMO
#+end_example

- [ ] p = 1 q = 5

#+name: meijDOMOVMO_15
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][20]=
{




  {    1.00     , 0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,   -1.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00    ,  0.00   ,   0.00   ,   0.00  ,    0.00   ,   0.00},
  {    0.00     , 1.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00 ,     0.00  ,   -1.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00    ,  0.00   ,   0.00   ,   0.00  ,    0.00   ,   0.00},
  {    0.00     , 0.00  ,    1.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,   -1.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00    ,  0.00   ,   0.00   ,   0.00  ,    0.00   ,   0.00},
  {    0.00     , 0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00  ,   -1.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00    ,  0.00   ,   0.00   ,   1.00  ,    0.00   ,   0.00},
  {    0.00     , 0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00 ,    -1.00 ,     0.00 ,     0.00 ,     0.00    ,  0.00   ,   0.00   ,   0.00  ,    1.00   ,   0.00},
  {    0.00     , 0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,    -1.00 ,     0.00    ,  0.00   ,   0.00   ,   0.00  ,    0.00   ,   1.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 0 1 1 1 2
    //   |       |
    // 1 1 1 1 1 1
    //   5       1

    orbp = 1;
    orbq = 5;

    Isomo = ((1 << NMO-3)-1) << 1;
    Isomo = Isomo + (1<<(NMO-1));
    Jsomo = (1 << NMO-0)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    printf("1Done MEij\n");
    printRealMatrix(MEij,rows,cols);
    printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<20;j++){
            //munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: meijDOMOVMO_15
#+begin_example
2DOMO->VMO
1Done MEij

     -1.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00
      0.00      -1.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00      -1.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00       0.00      -1.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00       0.00      -1.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00      -1.00
1Done MEij
#+end_example


** TODO[0/0] DOMO -> SOMO
DEADLINE: <2021-02-03 mer.>

DOMO to SOMO excitations for e.g.

2 1 1 1 1 1

1 1 1 1 1 2

- [ ] p = 5 q = 1

2 1 1 1 1

1 1 1 1 2

#+name: meijDOMOsomo51
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][6]=
{



   {  0.00  ,    0.00    ,  0.00   ,   1.00   ,   0.00  ,    0.00},
   {  0.00  ,    0.00    ,  0.00   ,   0.00   ,   1.00  ,    0.00},
   {  1.00  ,    0.00    ,  0.00   ,   0.00   ,   0.00  ,    0.00},
   {  0.00  ,    0.00    ,  0.00   ,   0.00   ,   0.00  ,    1.00},
   {  0.00  ,    1.00    ,  0.00   ,   0.00   ,   0.00  ,    0.00},
   {  0.00  ,    0.00    ,  1.00   ,   0.00   ,   0.00  ,    0.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing DOMO -> SOMO
    // 2 1 1 1 1
    // |       |
    // 1 1 1 1 2
    // 5       1

    orbp = 5;
    orbq = 1;

    Isomo = ((1 << NMO-2)-1);
    Jsomo = ((1 << NMO-2)-1) << 1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");
    //

    for(int i=0;i<6;i++){
        for(int j=0;j<6;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: meijDOMOsomo51
#+begin_example
1SOMO->VMO and DOMO->SOMO
I=15 J=30 (5 1) nocc=0
DOMO->SOMO, 5,1
#+end_example



- [ ] p = 4 q = 1

1 2 1 1 1

1 1 1 1 2

#+name: meijDOMOSOMO41
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][6]=
{



 {    0.00  ,   -1.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00},
 {    0.00  ,    0.00  ,   -1.00  ,    0.00  ,    0.00  ,    0.00},
 {    1.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00},
 {    0.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00  ,    1.00},
 {    0.00  ,    0.00  ,    0.00  ,   -1.00  ,    0.00  ,    0.00},
 {    0.00  ,    0.00  ,    0.00  ,    0.00  ,   -1.00  ,    0.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing DOMO -> SOMO
    // 1 2 1 1 1
    // |       |
    // 1 1 1 1 2
    //   4     1

    orbp = 4;
    orbq = 1;

    Isomo = ((1 << NMO-2)-1);
    Isomo = Isomo - (1<<(NMO-3)) + (1<<(NMO-2));
    Jsomo = ((1 << NMO-2)-1) << 1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<6;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: meijDOMOSOMO41
#+begin_example
1SOMO->VMO and DOMO->SOMO
I=23 J=30 (4 1) nocc=0
DOMO->SOMO, 4,1
#+end_example


- [ ] p = 1 q = 5

1 1 1 1 2

2 1 1 1 1

#+name: meijDOMOsomo15
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][6]=
{




  {   0.00  ,    0.00   ,   1.00   ,   0.00  ,    0.00  ,    0.00},
  {   0.00  ,    0.00   ,   0.00   ,   0.00  ,    1.00  ,    0.00},
  {   0.00  ,    0.00   ,   0.00   ,   0.00  ,    0.00  ,    1.00},
  {   1.00  ,    0.00   ,   0.00   ,   0.00  ,    0.00  ,    0.00},
  {   0.00  ,    1.00   ,   0.00   ,   0.00  ,    0.00  ,    0.00},
  {   0.00  ,    0.00   ,   0.00   ,   1.00  ,    0.00  ,    0.00}


};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing DOMO -> SOMO
    // 1 1 1 1 2
    // |       |
    // 2 1 1 1 1
    // 5       1

    orbp = 1;
    orbq = 5;

    Jsomo = ((1 << NMO-2)-1);
    Isomo = ((1 << NMO-2)-1) << 1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<6;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: meijDOMOsomo15
#+begin_example
2SOMO->VMO and DOMO->SOMO
DOMO->SOMO, 1,5
leading test 00000011 -> 00000110 1
leading test 00000101 -> 00001010 1
leading test 00000110 -> 00001100 1
leading test 00001001 -> 00000011 1
leading test 00001010 -> 00000101 1
leading test 00001100 -> 00001001 1
#+end_example


#+begin_src C
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')



printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY((1<<6-2)-1));


#+end_src

#+RESULTS:
#+begin_example
leading test 00001111
#+end_example


* Testing generation of dimensions

** TODO[/] DOMO -> VMO type

- [ ] p = 6 q = 1

2 1 1 1 1 0
1 1 1 1 1 1

#+name: proijDOMOVMO61
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][20]=
{

      { 1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 8;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 2 1 1 1 1 0
    // |         |
    // 1 1 1 1 1 1
    // 6         1

    orbp = 6;
    orbq = 1;

    Isomo = ((1 << NMO-2)-1) << 1;
    Jsomo = (1 << NMO-0)-1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    getApqIJMatrixDims(Isomo, Jsomo, MS, &rows, &cols);
    printf("rows=%d,cols=%d\n",rows,cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    //for(int i=0;i<6;i++){
    //    for(int j=0;j<20;j++){
    //        munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
    //    }
    //}

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    //free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: proijDOMOVMO61
#+begin_example
leading test 01111110
leading test 11111111
Isomo=126 Jsomo=255
NsomoI=6 NsomoJ=8
	 >> 5 14
rows=5,cols=14
#+end_example

* Testing generation of prototype matrices

** TODO[0/4] SOMO -> SOMO type

- [ ] Small case with 2 somos and 0 somos

#+name: promatrixSOMOSOMO12
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double ApqIJGood[1][1]=
{
    { 1.4142135623730950488016887242096980785696718753769480731766797379 }
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *CSFICSFJApqIJ;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 2;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1  1
    // |  |
    // 0  2
    // 2  1

    orbp = 2;
    orbq = 1;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    getApqIJMatrixDriver(Isomo, Jsomo, orbp, orbq, MS, NMO, &CSFICSFJApqIJ, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(CSFICSFJApqIJ,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            munit_assert_double_equal(CSFICSFJApqIJ[i*cols + j],ApqIJGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(CSFICSFJApqIJ);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: promatrixSOMOSOMO12
#+begin_example

BF to det I

      0.50       0.50       0.00       0.00       0.50       0.50
      0.00       0.50       0.50       0.50       0.50       0.00

BF to det I

Gen det basis J

      0.71       0.71

Gen det basis  J
Idets=6
leading test 00000011
leading test 00000101
leading test 00000110
leading test 00001001
leading test 00001010
leading test 00001100
Jdets 2
leading test 00000001
leading test 00000010
1SOMO->SOMO
Done MEij

     -1.00       0.00
      0.00       0.00
      0.00       1.00
      1.00       0.00
      0.00       0.00
      0.00      -1.00
Done MEij
Done blas BFI

     -0.50      -0.50
      0.50       0.50
Done blas BFI
#+end_example

- [ ] 4 somos and 2 somos

#+name: promatrixSOMOSOMO42
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double ApqIJGood[1][1]=
{
    { 1.4142135623730950488016887242096980785696718753769480731766797379 }
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *CSFICSFJApqIJ;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 4;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1  1
    // |  |
    // 0  2
    // 2  1

    orbp = 4;
    orbq = 1;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    getApqIJMatrixDriver(Isomo, Jsomo, orbp, orbq, MS, NMO, &CSFICSFJApqIJ, &rows, &cols);

    printf("1Done CSFICSFJApqij\n");
    printRealMatrix(CSFICSFJApqIJ,rows,cols);
    printf("1Done CSFICSFJApqij\n");


    //for(int i=0;i<rows;i++){
    //    for(int j=0;j<cols;j++){
    //        munit_assert_double_equal(CSFICSFJApqIJ[i*cols + j],ApqIJGood[i][j],6);
    //    }
    //}

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(CSFICSFJApqIJ);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: promatrixSOMOSOMO42
#+begin_example

BF to det I

      0.50       0.50       0.00       0.00       0.50       0.50
      0.00       0.50       0.50       0.50       0.50       0.00

BF to det I

Gen det basis J

      0.71       0.71

Gen det basis  J
Idets=6
leading test 00000011
leading test 00000101
leading test 00000110
leading test 00001001
leading test 00001010
leading test 00001100
Jdets 2
leading test 00000001
leading test 00000010
1SOMO->SOMO
Done MEij

     -1.00       0.00
      0.00      -1.00
      0.00       0.00
      0.00       0.00
     -1.00       0.00
      0.00      -1.00
Done MEij
Done blas BFI

     -1.00      -1.00
     -0.50      -0.50
Done blas BFI
1Done CSFICSFJApqij

     -2.04
     -0.71
1Done CSFICSFJApqij
#+end_example

- [ ] 2 somos and 4 somos

#+name: promatrixSOMOSOMO24
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double ApqIJGood[1][1]=
{
    { 1.4142135623730950488016887242096980785696718753769480731766797379 }
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *CSFICSFJApqIJ;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 4;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1  1
    // |  |
    // 0  2
    // 2  1

    orbp = 1;
    orbq = 4;

    Jsomo = (1 << NMO)-1;
    Isomo = (1 << NMO-2)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    getApqIJMatrixDriver(Isomo, Jsomo, orbp, orbq, MS, NMO, &CSFICSFJApqIJ, &rows, &cols);

    printf("1Done CSFICSFJApqij\n");
    printRealMatrix(CSFICSFJApqIJ,rows,cols);
    printf("1Done CSFICSFJApqij\n");


    //for(int i=0;i<rows;i++){
    //    for(int j=0;j<cols;j++){
    //        munit_assert_double_equal(CSFICSFJApqIJ[i*cols + j],ApqIJGood[i][j],6);
    //    }
    //}

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(CSFICSFJApqIJ);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: promatrixSOMOSOMO24
#+begin_example

BF to det I

      0.71       0.71

BF to det I

Gen det basis J

      0.50       0.50       0.00       0.00       0.50       0.50
      0.00       0.50       0.50       0.50       0.50       0.00

Gen det basis  J
Idets=2
leading test 00000001
leading test 00000010
Jdets 6
leading test 00000011
leading test 00000101
leading test 00000110
leading test 00001001
leading test 00001010
leading test 00001100
2DOMO->VMO
Done MEij

     -1.00       0.00       0.00       0.00      -1.00       0.00
      0.00      -1.00       0.00       0.00       0.00      -1.00
Done MEij
Done blas BFI

     -0.71      -0.71       0.00       0.00      -0.71      -0.71
Done blas BFI
1Done CSFICSFJApqij

     -2.04      -0.71
1Done CSFICSFJApqij
#+end_example

- [ ] 6 somos and 4 somos

#+name: promatrixSOMOSOMO64
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double ApqIJGood[1][1]=
{
    { 1.4142135623730950488016887242096980785696718753769480731766797379 }
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *CSFICSFJApqIJ;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1  1
    // |  |
    // 0  2
    // 2  1

    orbp = 6;
    orbq = 1;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    getApqIJMatrixDriver(Isomo, Jsomo, orbp, orbq, MS, NMO, &CSFICSFJApqIJ, &rows, &cols);

    printf("1Done CSFICSFJApqij\n");
    printRealMatrix(CSFICSFJApqIJ,rows,cols);
    printf("1Done CSFICSFJApqij\n");


    //for(int i=0;i<rows;i++){
    //    for(int j=0;j<cols;j++){
    //        munit_assert_double_equal(CSFICSFJApqIJ[i*cols + j],ApqIJGood[i][j],6);
    //    }
    //}

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(CSFICSFJApqIJ);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: promatrixSOMOSOMO64
#+begin_example

BF to det I

      0.35       0.35       0.00       0.00       0.00       0.35       0.00       0.35       0.00       0.00       0.00       0.00       0.35       0.00       0.35       0.00       0.00       0.00       0.35       0.35
      0.00       0.35       0.35       0.00       0.35       0.35       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.35       0.35       0.00       0.35       0.35       0.00
      0.00       0.00       0.35       0.35       0.00       0.35       0.35       0.00       0.00       0.00       0.00       0.00       0.00       0.35       0.35       0.00       0.35       0.35       0.00       0.00
      0.00       0.00       0.00       0.00       0.35       0.35       0.00       0.00       0.35       0.35       0.35       0.35       0.00       0.00       0.35       0.35       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.35       0.35       0.35       0.35       0.00       0.00       0.35       0.35       0.35       0.35       0.00       0.00       0.00       0.00       0.00

BF to det I

Gen det basis J

      0.50       0.50       0.00       0.00       0.50       0.50
      0.00       0.50       0.50       0.50       0.50       0.00

Gen det basis  J
Idets=20
leading test 00000111
leading test 00001011
leading test 00001101
leading test 00001110
leading test 00010011
leading test 00010101
leading test 00010110
leading test 00011001
leading test 00011010
leading test 00011100
leading test 00100011
leading test 00100101
leading test 00100110
leading test 00101001
leading test 00101010
leading test 00101100
leading test 00110001
leading test 00110010
leading test 00110100
leading test 00111000
Jdets 6
leading test 00000011
leading test 00000101
leading test 00000110
leading test 00001001
leading test 00001010
leading test 00001100
1SOMO->SOMO
Done MEij

      1.00       0.00       0.00       0.00       0.00       0.00
      0.00       1.00       0.00       0.00       0.00       0.00
      0.00       0.00       1.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       1.00       0.00       0.00
      0.00       0.00       0.00       0.00       1.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       1.00
      0.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00
      1.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00
      0.00       1.00       0.00       0.00       0.00       0.00
      0.00       0.00       1.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       1.00       0.00       0.00
      0.00       0.00       0.00       0.00       1.00       0.00
      0.00       0.00       0.00       0.00       0.00       1.00
Done MEij
Done blas BFI

      0.71       0.71       0.00       0.00       0.71       0.71
      0.00       0.71       0.71       0.71       0.71       0.00
      0.00       0.35       0.35       0.35       0.35       0.00
      0.00       0.35       0.35       0.35       0.35       0.00
      0.35       0.35       0.00       0.00       0.35       0.35
Done blas BFI
1Done CSFICSFJApqij

      2.38       0.90
      1.62       1.69
      1.39       0.78
      1.53       1.02
      1.02       0.35
1Done CSFICSFJApqij
#+end_example
