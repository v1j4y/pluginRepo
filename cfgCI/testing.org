#+title:     Testing various functions
#+author:    Vijay Gopal Chilkuri
#+email:     vijay.gopal.c@gmail.com

(org-babel-lob-injest "./theoryCFGCI.org")

* Testing C functions

** Simple unit tests with munit

#+begin_src C :tangle tests.c
#include <stdio.h>
#include "munit/munit.h"

void tests(){

    int foo = 1;
    int bar = 1;

    munit_assert_int(foo, ==, bar);

    printf("Hello world (munit-testing)\n");
}

#+end_src

#+begin_src bash :results output
emacs --batch --eval "(require 'org)" --eval '(org-babel-tangle-file "testing.org")'
gcc -o tests tests.c munit/munit.c
./tests 2>&1
rm tests
#+end_src

#+RESULTS:
#+begin_example
Hello world (munit-testing)
#+end_example


* Testing CSF creation

** TODO[2/2] Testing BF overlap matrix

- [X] 2x2 case

The overlap matrix for the BF with 4 SOMOs is of dimension 2x2 and is shown below:

#+begin_src python :results output :wrap ""
import numpy
import sys

bfmat = numpy.zeros(shape=(2,6),dtype=float)
#vec1
bfmat[0,0] = 1/2
bfmat[0,1] =-1/2
bfmat[0,2] =-1/2
bfmat[0,3] = 1/2
#vec2
bfmat[1,0] =-1/2
bfmat[1,3] =-1/2
bfmat[1,4] = 1/2
bfmat[1,5] = 1/2
ovlp = numpy.dot(bfmat,bfmat.T)
#print(numpy.dot(bfmat,bfmat.T))
#numpy.savetxt(sys.stdout, bfmat.T, fmt="|%4.2f")
for el in ovlp:
    print(' '.join(el.astype(str)))
#+end_src

#+RESULTS:
1.0 -0.5
-0.5 1.0

#+name: bfmat
+----+----+
|1.0 |-0.5|
+----+----+
|-0.5|1.0 |
+----+----+

Now this should match with the C code of the library.

#+include: "./theoryCFGCI.org" src

#+name: testOvlpMatrix2x2
#+begin_src C :main no :noweb yes #:tangle tests.c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

<<getOverlapMatrix>>
<<generateAllBFs>>
<<treefuncmain>>
<<indexlist>>
<<calculateIslands>>
<<getNsomo>>
<<inttobindigit>>

int main(){
    int64_t Isomo = ((1<<4)-1);
    int64_t MS=0;
    double *overlapMatrix;
    int rows=0;
    int cols=0;
    int NSOMOout=0;
    int test_ovlp_matrix = 0;

    // The correct overlap matrix
    double *ovlp_matrix_check = malloc(2*2*sizeof(double));
    ovlp_matrix_check[0*2 + 0] = 1.0;
    ovlp_matrix_check[0*2 + 1] =-0.5;
    ovlp_matrix_check[1*2 + 0] =-0.5;
    ovlp_matrix_check[1*2 + 1] = 1.0;

    getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);
    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(overlapMatrix[i*cols + j] != ovlp_matrix_check[i*cols + j]) test_ovlp_matrix = -1;
        }
    }

    //printRealMatrix(overlapMatrix,rows,cols);
    printf("test_ovlp_matrix_NSOMO4=%d\n",test_ovlp_matrix);
    free(overlapMatrix);
    return(test_ovlp_matrix);
}
#+end_src



- [X] 4x4 case

The overlap matrix for the BF with 4 SOMOs is of dimension 2x2 and is shown below:

#+begin_src python :results output
import numpy
import sys

bfmat = numpy.zeros(shape=(5,20),dtype=float)
coeff = 1.0/(2.0*numpy.sqrt(2.0))
#vec1
bfmat[1,0] = 0.0
bfmat[1,1] = 0.0
bfmat[1,2] = 0.0
bfmat[1,3] = 0.0
bfmat[1,4] = 0.0
bfmat[1,5] = coeff
bfmat[1,6] =-coeff
bfmat[1,7] =-coeff
bfmat[1,8] = coeff
bfmat[1,9] = 0.0
bfmat[1,10] = 0.0
bfmat[1,11] =-coeff
bfmat[1,12] = coeff
bfmat[1,13] = coeff
bfmat[1,14] =-coeff
bfmat[1,15] = 0.0
bfmat[1,16] = 0.0
bfmat[1,17] = 0.0
bfmat[1,18] = 0.0
bfmat[1,19] = 0.0
#vec2
bfmat[0,0] = 0.0
bfmat[0,1] = 0.0
bfmat[0,2] = coeff
bfmat[0,3] =-coeff
bfmat[0,4] = 0.0
bfmat[0,5] =-coeff
bfmat[0,6] = 0.0
bfmat[0,7] = coeff
bfmat[0,8] = 0.0
bfmat[0,9] = 0.0
bfmat[0,10] = 0.0
bfmat[0,11] = 0.0
bfmat[0,12] = 0.0
bfmat[0,13] =-coeff
bfmat[0,14] = coeff
bfmat[0,15] = 0.0
bfmat[0,16] = coeff
bfmat[0,17] =-coeff
bfmat[0,18] = 0.0
bfmat[0,19] = 0.0
#vec3
bfmat[3,0] = 0.0
bfmat[3,1] = 0.0
bfmat[3,2] = 0.0
bfmat[3,3] = 0.0
bfmat[3,4] = coeff
bfmat[3,5] =-coeff
bfmat[3,6] = 0.0
bfmat[3,7] = 0.0
bfmat[3,8] =-coeff
bfmat[3,9] = coeff
bfmat[3,10] =-coeff
bfmat[3,11] = coeff
bfmat[3,12] = 0.0
bfmat[3,13] = 0.0
bfmat[3,14] = coeff
bfmat[3,15] =-coeff
bfmat[3,16] = 0.0
bfmat[3,17] = 0.0
bfmat[3,18] = 0.0
bfmat[3,19] = 0.0
#vec4
bfmat[2,0] = coeff
bfmat[2,1] =-coeff
bfmat[2,2] = 0.0
bfmat[2,3] = 0.0
bfmat[2,4] = 0.0
bfmat[2,5] =-coeff
bfmat[2,6] = coeff
bfmat[2,7] = 0.0
bfmat[2,8] = 0.0
bfmat[2,9] = 0.0
bfmat[2,10] = 0.0
bfmat[2,11] = 0.0
bfmat[2,12] =-coeff
bfmat[2,13] = 0.0
bfmat[2,14] = coeff
bfmat[2,15] = 0.0
bfmat[2,16] = 0.0
bfmat[2,17] = 0.0
bfmat[2,18] = coeff
bfmat[2,19] =-coeff
#vec5
bfmat[4,0] = 0.0
bfmat[4,1] = coeff
bfmat[4,2] =-coeff
bfmat[4,3] = 0.0
bfmat[4,4] =-coeff
bfmat[4,5] = coeff
bfmat[4,6] = 0.0
bfmat[4,7] = 0.0
bfmat[4,8] = 0.0
bfmat[4,9] = 0.0
bfmat[4,10] = 0.0
bfmat[4,11] = 0.0
bfmat[4,12] = 0.0
bfmat[4,13] = 0.0
bfmat[4,14] =-coeff
bfmat[4,15] = coeff
bfmat[4,16] = 0.0
bfmat[4,17] = coeff
bfmat[4,18] =-coeff
bfmat[4,19] = 0.0
ovlp = numpy.dot(bfmat,bfmat.T)
#print(numpy.dot(bfmat,bfmat.T))
#numpy.savetxt(sys.stdout, bfmat.T, fmt="|%4.2f")
for el in ovlp:
    print(' '.join(el.astype(str)))
#+end_src

#+name: ovlmat4x4
+--------------------+--------------------+--------------------+--------------------+--------------------+
|0.9999999999999999   |-0.49999999999999994|0.24999999999999994 |0.24999999999999994 |-0.49999999999999994|
+--------------------+--------------------+--------------------+--------------------+--------------------+
|-0.49999999999999994| 0.9999999999999999 |-0.49999999999999994|-0.49999999999999994|0.24999999999999994 |
+--------------------+--------------------+--------------------+--------------------+--------------------+
|0.24999999999999994 |-0.49999999999999994| 0.9999999999999999 |0.24999999999999994 |-0.49999999999999994|
+--------------------+--------------------+--------------------+--------------------+--------------------+
|0.24999999999999994 |-0.49999999999999994|0.24999999999999994 | 0.9999999999999999 |-0.49999999999999994|
+--------------------+--------------------+--------------------+--------------------+--------------------+
|-0.49999999999999994|0.24999999999999994 |-0.49999999999999994|-0.49999999999999994| 0.9999999999999999 |
+--------------------+--------------------+--------------------+--------------------+--------------------+

Now this should match with the C code of the library.

#+name: testOvlpMatrix4x4
#+begin_src C :main no :noweb yes #:tangle tests.c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

<<getOverlapMatrix>>
<<generateAllBFs>>
<<treefuncmain>>
<<indexlist>>
<<calculateIslands>>
<<getNsomo>>
<<inttobindigit>>

int main(){
    int64_t Isomo = ((1<<6)-1);
    int64_t MS=0;
    double *overlapMatrix;
    int rows=0;
    int cols=0;
    int NSOMOout=0;
    int test_ovlp_matrix = 0;

    // The correct overlap matrix
    double *ovlp_matrix_check = malloc(5*5*sizeof(double));
    ovlp_matrix_check[0*5 + 0] = 1.0;
    ovlp_matrix_check[0*5 + 1] =-0.5;
    ovlp_matrix_check[0*5 + 2] = 0.25;
    ovlp_matrix_check[0*5 + 3] = 0.25;
    ovlp_matrix_check[0*5 + 4] =-0.5;
    ovlp_matrix_check[1*5 + 0] =-0.5;
    ovlp_matrix_check[1*5 + 1] = 1.0;
    ovlp_matrix_check[1*5 + 2] =-0.5;
    ovlp_matrix_check[1*5 + 3] =-0.5;
    ovlp_matrix_check[1*5 + 4] = 0.25;
    ovlp_matrix_check[2*5 + 0] = 0.25;
    ovlp_matrix_check[2*5 + 1] =-0.5;
    ovlp_matrix_check[2*5 + 2] = 1.0;
    ovlp_matrix_check[2*5 + 3] = 0.25;
    ovlp_matrix_check[2*5 + 4] =-0.5;
    ovlp_matrix_check[3*5 + 0] = 0.25;
    ovlp_matrix_check[3*5 + 1] =-0.5;
    ovlp_matrix_check[3*5 + 2] = 0.25;
    ovlp_matrix_check[3*5 + 3] = 1.0;
    ovlp_matrix_check[3*5 + 4] =-0.5;
    ovlp_matrix_check[4*5 + 0] =-0.5;
    ovlp_matrix_check[4*5 + 1] = 0.25;
    ovlp_matrix_check[4*5 + 2] =-0.5;
    ovlp_matrix_check[4*5 + 3] =-0.5;
    ovlp_matrix_check[4*5 + 4] = 1.0;

    getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);
    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(overlapMatrix[i*cols + j] != ovlp_matrix_check[i*cols + j]) test_ovlp_matrix = -1;
        }
    }

    //printRealMatrix(overlapMatrix,rows,cols);
    free(overlapMatrix);
    printf("\ntest_ovlp_matrix6x6=%d\n",test_ovlp_matrix);
    return(test_ovlp_matrix);
}
#+end_src


** TODO[1/2] Testing gram-schmidt orthonormalization


- [X] Test orthonormalization matrix for 4 SOMO case

  The orthonormalization matrix for 4 SOMO case is a 2x2 matrix and is very simple to derive.

  #+name: 2x2orthonorm
  | 0.8944 | 0.4472 |
  |    0.0 |    1.0 |

#+name: orthoMatrix4SOMO
#+begin_src C :noweb yes :main no :libs -lm
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

<<getOverlapMatrix>>
<<generateAllBFs>>
<<treefuncmain>>
<<indexlist>>
<<calculateIslands>>
<<getNsomo>>
<<inttobindigit>>
<<gramSchmidt>>

int main(){
    int64_t Isomo = ((1<<4)-1);
    int64_t MS=0;
    double *overlapMatrix;
    double *orthoMatrix;
    int rows=0;
    int cols=0;
    int NSOMOout=0;
    int test_ortho_matrix = 0;

    // The correct overlap matrix
    double *ortho_matrix_check = malloc(2*2*sizeof(double));
    ortho_matrix_check[0*2 + 0] = 0.8944271909999158785636694674925104941762473438446102897083588981;
    ortho_matrix_check[0*2 + 1] = 0.4472135954999579392818347337462552470881236719223051448541794490;
    ortho_matrix_check[1*2 + 0] = 0.0;
    ortho_matrix_check[1*2 + 1] = 1.0;

    getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);

    orthoMatrix = malloc(rows*cols*sizeof(double));

    gramSchmidt(overlapMatrix, rows, cols, orthoMatrix);

    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(fabs(orthoMatrix[i*cols + j] - ortho_matrix_check[i*cols + j]) > 1e-16) test_ortho_matrix = -1;
        }
    }

    printRealMatrix(orthoMatrix,rows,cols);
    printf("test_ortho_matrix_NSOMO4=%d\n",test_ortho_matrix);

    // Garbage collection
    free(overlapMatrix);
    free(orthoMatrix);

    return(test_ortho_matrix);
}


#+end_src

#+RESULTS:
|                            |      |
|                       0.89 | 0.45 |
|                        0.0 |  1.0 |
| test_ortho_matrix_NSOMO4=0 |      |

- [ ] Test orthonormalization matrix for 6 SOMO case

  The orthonormalization matrix for 6 SOMO case is a 5x5 matrix the first three rows of which are:

  #+name: 4x4orthonorm
  | 0.9225 | 0.3094 |-0.2306 |
  |    0.0 | 0.8944 | 0.4472 |
  |    0.0 |    0.0 |    1.0 |

  #+name: orthoMatrix6SOMO
  #+begin_src C :noweb yes :main no :libs -lm
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdint.h>
  #include <math.h>
  #include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"

  <<getOverlapMatrix>>
  <<generateAllBFs>>
  <<treefuncmain>>
  <<indexlist>>
  <<calculateIslands>>
  <<getNsomo>>
  <<inttobindigit>>
  <<gramSchmidt>>

  int main(){
      int64_t Isomo = ((1<<6)-1);
      int64_t MS=0;
      double *overlapMatrix;
      double *orthoMatrix;
      int rows=0;
      int cols=0;
      int NSOMOout=0;
      int test_ortho_matrix = 0;

      // The correct overlap matrix
      // TODO
      double *ortho_matrix_check = malloc(2*2*sizeof(double));
      ortho_matrix_check[0*5 + 0] = 1.0;
      ortho_matrix_check[0*5 + 1] =-0.5;
      ortho_matrix_check[0*5 + 2] = 0.25;
      ortho_matrix_check[0*5 + 3] = 0.25;
      ortho_matrix_check[0*5 + 4] =-0.5;
      ortho_matrix_check[1*5 + 0] =-0.5;
      ortho_matrix_check[1*5 + 1] = 1.0;
      ortho_matrix_check[1*5 + 2] =-0.5;
      ortho_matrix_check[1*5 + 3] =-0.5;
      ortho_matrix_check[1*5 + 4] = 0.25;
      ortho_matrix_check[2*5 + 0] = 0.25;
      ortho_matrix_check[2*5 + 1] =-0.5;
      ortho_matrix_check[2*5 + 2] = 1.0;
      ortho_matrix_check[2*5 + 3] = 0.25;
      ortho_matrix_check[2*5 + 4] =-0.5;
      ortho_matrix_check[3*5 + 0] = 0.25;
      ortho_matrix_check[3*5 + 1] =-0.5;
      ortho_matrix_check[3*5 + 2] = 0.25;
      ortho_matrix_check[3*5 + 3] = 1.0;
      ortho_matrix_check[3*5 + 4] =-0.5;
      ortho_matrix_check[4*5 + 0] =-0.5;
      ortho_matrix_check[4*5 + 1] = 0.25;
      ortho_matrix_check[4*5 + 2] =-0.5;
      ortho_matrix_check[4*5 + 3] =-0.5;
      ortho_matrix_check[4*5 + 4] = 1.0;

      getOverlapMatrix(Isomo, MS, &overlapMatrix, &rows, &cols, &NSOMOout);

      orthoMatrix = malloc(rows*cols*sizeof(double));

      gramSchmidt(overlapMatrix, rows, cols, orthoMatrix);

      //for(int i=0;i<rows;i++){
      //    for(int j=0;j<cols;j++){
      //        if(fabs(orthoMatrix[i*cols + j] - ortho_matrix_check[i*cols + j]) > 1e-16) test_ortho_matrix = -1;
      //    }
      //}

      printRealMatrix(orthoMatrix,rows,cols);
      printf("test_ortho_matrix_NSOMO4=%d\n",test_ortho_matrix);

      // Garbage collection
      free(overlapMatrix);
      free(orthoMatrix);

      return(test_ortho_matrix);
  }


  #+end_src

  #+RESULTS: orthoMatrix6SOMO
|                            |      |      |      |       |
|                       0.88 | 0.16 |  0.0 |  0.0 |  0.44 |
|                        0.0 | 0.88 |  0.3 |  0.3 | -0.22 |
|                        0.0 |  0.0 | 0.89 |  0.0 |  0.45 |
|                        0.0 |  0.0 |  0.0 | 0.89 |  0.45 |
|                        0.0 |  0.0 |  0.0 |  0.0 |   1.0 |
| test_ortho_matrix_NSOMO4=0 |      |      |      |       |


* Testing generation of prototype matrices

** TODO[1/4] SOMO -> SOMO type

- [X] p = 6 q = 1

  The SOMO -> SOMO excitations are of the following type:
1 1 1 1 1 1
0 1 1 1 1 2
etc...

#+name: mematrixSOMOSOMO16
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{
    { 1.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      1.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      1.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      1.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      1.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      1.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 1.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      1.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      1.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      1.00,      0.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      1.00,      0.00},
    { 0.00,      0.00,      0.00,      0.00,      0.00,      1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 0 1 1 1 1 2
    // 6         1

    orbp = 6;
    orbq = 1;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO16
#+begin_example
SOMO->SOMO
#+end_example


- [ ] p = 6 q = 2

  The SOMO -> SOMO excitations are of the following type:
1 1 1 1 1 1
0 1 1 1 2 1
etc...

#+name: mematrixSOMOSOMO26
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{

   {  1.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     1.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,   -1.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    1.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,  -1.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,   -1.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   { -1.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,    -1.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    1.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,   -1.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   1.00  ,    0.00},
   {  0.00 ,     0.00  ,    0.00  ,    0.00   ,   0.00  ,    1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 0 1 1 1 2 1
    // 6       2

    orbp = 6;
    orbq = 2;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-3)-1;
    Jsomo = Jsomo << 2;
    Jsomo = Jsomo + 1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO26
#+begin_example
SOMO->SOMO
#+end_example

- [ ] p = 5 q = 1

#+name: mematrixSOMOSOMO15
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{
   { -1.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,     -1.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,     -1.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  1.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      1.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      1.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      1.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      1.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      1.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,     -1.00,      0.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,     -1.00,      0.00},
   {  0.00,      0.00,      0.00,      0.00,      0.00,     -1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 1 0 1 1 1 2
    //   2       6

    orbp = 5;
    orbq = 1;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    //Jsomo = Jsomo + (1<<NMO-2);
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");
    //

    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO15
#+begin_example
1SOMO->SOMO
#+end_example

- [ ] p = 4 q = 1

#+name: mematrixSOMOSOMO14
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{
    { 1.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 1.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,    -1.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,    -1.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,    -1.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,    -1.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,    -1.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,  -1.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,    -1.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,  -1.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    1.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00},
    { 0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 1 0 1 1 1 2
    //   2       6

    orbp = 4;
    orbq = 1;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO14
#+begin_example
leading test 00111111
leading test 00001111
1SOMO->SOMO
#+end_example

- [ ] p = 1 q = 6

#+name: mematrixSOMOSOMO61
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{

    { 1.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     1.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     1.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    1.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     1.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     1.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 1.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     1.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     1.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    1.00 ,     0.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     1.00 ,     0.00},
    { 0.00 ,     0.00 ,     0.00  ,    0.00 ,     0.00 ,     1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 2 1 1 1 1 0
    // 6         1

    orbp = 1;
    orbq = 6;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    Jsomo = Jsomo << 1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO61
#+begin_example
leading test 00111111
leading test 00011110
2SOMO->SOMO
#+end_example

- [ ] p = 1 q = 4

#+name: mematrixSOMOSOMO41
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[20][6]=
{

   {  1.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  1.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,    -1.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,    -1.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,    -1.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,    -1.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,    -1.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,  -1.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,    -1.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,  -1.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     1.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     0.00},
   {  0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00 ,     1.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 1 1 1 1 1
    // |         |
    // 1 2 1 1 1 0
    //   2       6

    orbp = 1;
    orbq = 4;

    Isomo = (1 << NMO)-1;
    Jsomo = (1 << NMO-2)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<20;i++){
        for(int j=0;j<5;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: mematrixSOMOSOMO41
#+begin_example
2SOMO->SOMO
#+end_example

** TODO[0/2] DOMO -> VMO

DOMO to VMO type for e.g.

- [ ] p = 6 q = 1

2 1 1 1 1 0
1 1 1 1 1 1

#+name: meijDOMOVMO61
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][20]=
{

      { 1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 2 1 1 1 1 0
    // |         |
    // 1 1 1 1 1 1
    // 6         1

    orbp = 6;
    orbq = 1;

    Isomo = ((1 << NMO-2)-1) << 1;
    Jsomo = (1 << NMO-0)-1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<20;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: meijDOMOVMO61
#+begin_example
leading test 00011110
leading test 00111111
1DOMO->VMO
#+end_example

- [ ] p = 6 q = 2

    2 1 1 1 0 1

    1 1 1 1 1 1

#+name: domovmo62
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][20]=
{


    { -1.00 ,     0.00 ,     0.00    ,  0.00 ,     0.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00    ,  1.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00   ,   0.00   ,   0.00  ,    0.00  ,    0.00},
    {  0.00 ,    -1.00 ,     0.00    ,  0.00 ,     0.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00    ,  0.00  ,    0.00  ,    1.00 ,     0.00  ,    0.00   ,   0.00   ,   0.00  ,    0.00  ,    0.00},
    {  0.00 ,     0.00 ,     0.00    ,  1.00 ,     0.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00    ,  0.00  ,    0.00  ,    0.00 ,     0.00  ,   -1.00   ,   0.00   ,   0.00  ,    0.00  ,    0.00},
    {  0.00 ,     0.00 ,     0.00    ,  0.00 ,    -1.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00    ,  0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00   ,   1.00   ,   0.00  ,    0.00  ,    0.00},
    {  0.00 ,     0.00 ,     0.00    ,  0.00 ,     0.00 ,     0.00  ,    1.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00    ,  0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00   ,   0.00   ,   0.00  ,   -1.00  ,    0.00},
    {  0.00 ,     0.00 ,     0.00    ,  0.00 ,     0.00 ,     0.00  ,    0.00  ,    0.00  ,    1.00  ,    0.00 ,     0.00    ,  0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00   ,   0.00   ,   0.00  ,    0.00  ,   -1.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing DOMO -> VMO
    // 2 1 1 1 0 1
    // |       |
    // 1 1 1 1 1 1
    // 6       2

    orbp = 6;
    orbq = 2;

    Isomo = (1 << NMO-3)-1;
    Isomo = Isomo << 2;
    Isomo += 1;
    Jsomo = (1 << NMO-0)-1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<20;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
            //printf("%5.5f %5.5f \n",MEij[i*cols+j],MEijGood[i][j]);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: domovmo62
#+begin_example
leading test 00011101
leading test 00111111
1DOMO->VMO
#+end_example


- [ ] p = 5 q = 1

1 2 1 1 1 0
1 1 1 1 1 1

#+name: meijDOMOVMO51
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][20]=
{





  {   1.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,    -1.00   ,   0.00  ,    0.00   ,   0.00  ,    0.00  ,    0.00  ,    0.00   ,   0.00   ,   0.00    ,  0.00    ,  0.00    ,  0.00   ,   0.00  ,    0.00},
  {   0.00  ,    1.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,   -1.00   ,   0.00  ,    0.00  ,    0.00  ,    0.00   ,   0.00   ,   0.00    ,  0.00    ,  0.00    ,  0.00   ,   0.00  ,    0.00},
  {   0.00  ,    0.00  ,    1.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00   ,  -1.00  ,    0.00  ,    0.00  ,    0.00   ,   0.00   ,   0.00    ,  0.00    ,  0.00    ,  0.00   ,   0.00  ,    0.00},
  {   0.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00   ,   0.00  ,   -1.00  ,    0.00  ,    0.00   ,   0.00   ,   0.00    ,  0.00    ,  0.00    ,  1.00   ,   0.00  ,    0.00},
  {   0.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00   ,   0.00  ,    0.00  ,   -1.00  ,    0.00   ,   0.00   ,   0.00    ,  0.00    ,  0.00    ,  0.00   ,   1.00  ,    0.00},
  {   0.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00   ,   0.00  ,    0.00   ,   0.00  ,    0.00  ,    0.00  ,    0.00   ,  -1.00   ,   0.00    ,  0.00    ,  0.00    ,  0.00   ,   0.00  ,    1.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 2 1 1 1 0
    // |         |
    // 1 1 1 1 1 1
    //   5       1

    orbp = 5;
    orbq = 1;

    Isomo = ((1 << NMO-3)-1) << 1;
    Isomo = Isomo | (1UL << (NMO-1));
    Jsomo = (1 << NMO-0)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<20;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src


- [ ] p = 1 q = 6

#+name: meijDOMOVMO_16
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][20]=
{

      { 1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00},
      { 0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       0.00,       1.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 0 1 1 1 1 2
    // |         |
    // 1 1 1 1 1 1
    // 6         1

    orbp = 1;
    orbq = 6;

    Isomo = ((1 << NMO-2)-1) << 1;
    Jsomo = (1 << NMO-0)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<20;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: meijDOMOVMO_16
#+begin_example
2DOMO->VMO
#+end_example

- [ ] p = 1 q = 5

#+name: meijDOMOVMO_15
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][20]=
{




  {    1.00     , 0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,   -1.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00    ,  0.00   ,   0.00   ,   0.00  ,    0.00   ,   0.00},
  {    0.00     , 1.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00 ,     0.00  ,   -1.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00    ,  0.00   ,   0.00   ,   0.00  ,    0.00   ,   0.00},
  {    0.00     , 0.00  ,    1.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,   -1.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00    ,  0.00   ,   0.00   ,   0.00  ,    0.00   ,   0.00},
  {    0.00     , 0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00  ,   -1.00 ,     0.00 ,     0.00 ,     0.00 ,     0.00    ,  0.00   ,   0.00   ,   1.00  ,    0.00   ,   0.00},
  {    0.00     , 0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00 ,    -1.00 ,     0.00 ,     0.00 ,     0.00    ,  0.00   ,   0.00   ,   0.00  ,    1.00   ,   0.00},
  {    0.00     , 0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00 ,     0.00  ,    0.00  ,    0.00  ,    0.00 ,     0.00 ,     0.00 ,    -1.00 ,     0.00    ,  0.00   ,   0.00   ,   0.00  ,    0.00   ,   1.00}

};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing SOMO -> SOMO
    // 1 0 1 1 1 2
    //   |       |
    // 1 1 1 1 1 1
    //   5       1

    orbp = 1;
    orbq = 5;

    Isomo = ((1 << NMO-3)-1) << 1;
    Isomo = Isomo + (1<<(NMO-1));
    Jsomo = (1 << NMO-0)-1;
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    //printf("\n");
    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    //printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");


    for(int i=0;i<6;i++){
        for(int j=0;j<20;j++){
            munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
        }
    }

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: meijDOMOVMO_15
#+begin_example
2DOMO->VMO
#+end_example


** TODO[0/0] DOMO -> SOMO
DEADLINE: <2021-02-03 mer.>

DOMO to SOMO excitations for e.g.

2 1 1 1 1 1

1 1 1 1 1 2

- [ ] p = 5 q = 1

2 1 1 1 1

1 1 1 1 2

#+name: meijDOMOVMO16
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][6]=
{


      {0.00  ,    0.00 ,    -1.00 ,     0.00 ,     0.00  ,    0.00},
      {0.00  ,    0.00 ,     0.00 ,     0.00 ,    -1.00  ,    0.00},
      {0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00  ,    0.00},
      {0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00  ,    0.00},
      {0.00  ,   -1.00 ,     0.00 ,     0.00 ,     0.00  ,    0.00},
      {0.00  ,    0.00 ,     0.00 ,    -1.00 ,     0.00  ,    0.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing DOMO -> SOMO
    // 2 1 1 1 1
    // |       |
    // 1 1 1 1 2
    // 5       1

    orbp = 1;
    orbq = 5;

    Jsomo = ((1 << NMO-2)-1);
    Isomo = ((1 << NMO-2)-1) << 1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    //printf("1Done MEij\n");
    //printRealMatrix(MEij,rows,cols);
    //printf("1Done MEij\n");
    //

    //for(int i=0;i<6;i++){
    //    for(int j=0;j<6;j++){
    //        munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
    //    }
    //}

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: meijDOMOVMO16
#+begin_example
leading test 00011110
leading test 00111111
2DOMO->VMO
1Done MEij

      1.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00
      0.00       1.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       1.00
1Done MEij
#+end_example


- [ ] p = 4 q = 1

1 2 1 1 1

1 1 1 1 2

#+name: meijDOMOSOMO14
#+begin_src C :noweb yes :main no :libs -lm -lblas :results output :flags -I . :includes '(cfgCI_utils.c tree_utils.c munit/munit.c)
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "./munit/munit.h"
#include "/home/vijay/Documents/codes/qp2/src/cfgCI/tree_utils.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

//<<getOverlapMatrix>>
//<<generateAllBFs>>
//<<treefuncmain>>
//<<indexlist>>
//<<calculateIslands>>
//<<getNsomo>>
//<<getncsfs>>
//<<inttobindigit>>
//<<gramSchmidt>>
//<<getApqIJMatrix>>
//<<convertBFtoDetBasis>>


const double MEijGood[6][6]=
{


      {0.00  ,    0.00 ,    -1.00 ,     0.00 ,     0.00  ,    0.00},
      {0.00  ,    0.00 ,     0.00 ,     0.00 ,    -1.00  ,    0.00},
      {0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00  ,    0.00},
      {0.00  ,    0.00 ,     0.00 ,     0.00 ,     0.00  ,    0.00},
      {0.00  ,   -1.00 ,     0.00 ,     0.00 ,     0.00  ,    0.00},
      {0.00  ,    0.00 ,     0.00 ,    -1.00 ,     0.00  ,    0.00}
};

int main(){
    int test_MEij_SOMO_SOMO_matrix = -1;
    double *MEij;
    int rows, cols;
    rows = 0;
    cols = 0;
    int64_t Isomo, Jsomo, MS, NMO;
    MS = 0;
    NMO = 6;
    int orbp, orbq;

    // Testing DOMO -> SOMO
    // 1 2 1 1 1
    // |       |
    // 1 1 1 1 2
    //   4     1

    orbp = 4;
    orbq = 1;

    Isomo = ((1 << NMO-2)-1);
    Isomo = Isomo - (1<<(NMO-3)) + (1<<(NMO-2));
    Jsomo = ((1 << NMO-2)-1) << 1;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &MEij, &rows, &cols);

    printf("1Done MEij\n");
    printRealMatrix(MEij,rows,cols);
    printf("1Done MEij\n");


    //for(int i=0;i<6;i++){
    //    for(int j=0;j<6;j++){
    //        munit_assert_double_equal(MEij[i*cols + j],MEijGood[i][j],6);
    //    }
    //}

    test_MEij_SOMO_SOMO_matrix = 0;

    // Garbage collection
    free(MEij);

    return(test_MEij_SOMO_SOMO_matrix);
}


#+end_src

#+RESULTS: meijDOMOSOMO14
#+begin_example
leading test 00010111
leading test 00011110
SOMO->VMO and DOMO->SOMO
DOMO->SOMO, 3,1
leading test 00000011 -> 00000011 -1
leading test 00000101 -> 00000101 -1
leading test 00000110 -> 00001110 1
leading test 00001001 -> 00001001 0
leading test 00001010 -> 00000010 0
leading test 00001100 -> 00000100 0
1Done MEij

      0.00      -1.00       0.00       0.00       0.00       0.00
      0.00       0.00      -1.00       0.00       0.00       0.00
      1.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00
      0.00       0.00       0.00       0.00       0.00       0.00
1Done MEij
#+end_example


#+begin_src C
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')



printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY((1<<6-2)-1));


#+end_src

#+RESULTS:
#+begin_example
leading test 00001111
#+end_example
