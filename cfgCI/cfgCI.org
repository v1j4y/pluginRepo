# -*- mode:org -*-
#+TITLE: Theory CFGCI
#+AUTHOR: Vijay Gopal Chilkuri
#+EMAIL: vijay.gopal.c@gmail.com
#+OPTIONS: toc:t
#+LATEX_CLASS: article
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{braket}
#+LATEX_HEADER: \usepackage{minted}

* Main Fortran code

** Loop over configurations

#+name: mainf90
#+begin_src f90 :main no :tangle cfgCI.irp.f
      subroutine printMatrix(mat, rows, cols)
      implicit none
      BEGIN_DOC
      ! Print a 2D matrix
      END_DOC
      integer i,j
      integer,intent(in) :: rows
      integer,intent(in) :: cols
      real*8,dimension(:,:),intent(in) :: mat(rows,cols)
      print *,""
      do i=1,rows
         do j=1,cols
            write(*,'(F6.4,2X)',advance="no") mat(i,j)
         end do
         print *,""
      end do
      end subroutine

      program cfgCI
      use cfunctions
      implicit none
      BEGIN_DOC
!     TODO : Put the documentation of the program here
      END_DOC
      character*32 cc
      integer i, j, k
      integer orbp, orbq
      integer rows
      integer cols
      integer*8 MS
      print *, N_int
      !cc = "Hello"
      !print *,"Ndet=",psi_det_size, "Nconfig=",N_configuration
      !do i = 1, 6
      !   call debug_spindet(psi_configuration(N_int,1,i),N_int)
      !   call debug_spindet(psi_configuration(N_int,2,i),N_int)
      !   print *,"with mask"
      !   call debug_spindet(iand(reunion_of_act_virt_bitmask,psi_configuration(N_int,1,i)),1)
      !   call debug_spindet(iand(reunion_of_act_virt_bitmask,psi_configuration(N_int,2,i)),1)
      !end do

#+end_src


** Apply single excitations on a configuration

Provide all the singles excitations.

#+begin_src f90 :main no :tangle cfgCI.irp.f
  integer(bit_kind) :: Icfg(N_INT,2)
  integer(bit_kind) :: alphas_Icfg(N_INT,2,200)
  integer(bit_kind) :: connectedI_alpha(N_INT,2,200)
  integer(bit_kind) :: psi_configuration_out(N_INT,2,400)
  real*8            :: psi_coef_out(dimBasisCSF)
  real*8            :: psi_coef_out_det(N_det)
  logical           :: psi_coef_out_init(dimBasisCSF)
  integer           :: excitationIds(2,200)
  integer           :: excitationTypes(200)
  integer  :: Nalphas_Icfg, nconnectedI, rowsikpq, colsikpq
  integer  :: extype,NSOMOalpha,Nsomoi,p,q,pmodel,qmodel
  integer :: getNSOMO
  integer :: totcolsTKI
  integer :: rowsTKI
  integer :: moi, moj, mok, mol, l,m
  real*8  :: norm_coef_cfg
  real*8  :: norm_coef_det
  real*8,dimension(:,:),allocatable :: TKI
  real*8,dimension(:,:),allocatable  :: GIJpqrs
  real*8,dimension(:,:),allocatable  :: TKIGIJ
  real*8, external :: mo_two_e_integral

  MS = 0
  norm_coef_cfg=0.d0

  psi_coef_out=0.d0
  psi_coef_out_init = .False.

  print *,"CSF basis dim=",dimBasisCSF
  do i = 1,dimBasisCSF
     print *, "i=",i,"coef=",psi_coef_config(i)
     !call debug_spindet(psi_configuration(1,1,i),N_int)
     !call debug_spindet(psi_configuration(1,2,i),N_int)
     norm_coef_cfg += psi_coef_config(i)*psi_coef_config(i)
  enddo
  print *,"norm CFG = ",norm_coef_cfg
  call convertWFfromCSFtoDET(psi_coef_out,psi_coef_out_det)
  norm_coef_det=0
  do i = 1,N_det
     !print *, "i=",i,"coef=",psi_coef_out_det(i)
     norm_coef_det += psi_coef_out_det(i)*psi_coef_out_det(i)
  enddo
  print *,"norm = ",norm_coef_det, " size=",N_det

  ! Loop over all selected configurations
  do i = 1,N_configuration
     Icfg(1,1) = psi_configuration(1,1,i)
     Icfg(1,2) = psi_configuration(1,2,i)
     ! Returns all unique (checking the past) singly excited cfgs connected to I
     call obtain_associated_alphaI(i, Icfg, alphas_Icfg, Nalphas_Icfg)
     ! TODO : remove doubly excited for return
     print *,i,"Nalphas = ",Nalphas_Icfg
     ! Here we do 2x the loop. One to count for the size of the matrix, then we compute.
     do k = 1,Nalphas_Icfg
        print *,"Kalpha=",k
        call debug_spindet(alphas_Icfg(1,1,k),N_int)
        call debug_spindet(alphas_Icfg(1,2,k),N_int)
        ! Now generate all singly excited with respect to a given alpha CFG
        call obtain_connected_I_foralpha(i,alphas_Icfg(:,:,k),connectedI_alpha,nconnectedI,excitationIds,excitationTypes)

        print *,k,"----> nconnected = ",nconnectedI
        totcolsTKI = 0
        rowsTKI = 0
        do j = 1,nconnectedI
           NSOMOalpha = getNSOMO(alphas_Icfg(:,:,k))
           NSOMOI = getNSOMO(connectedI_alpha(:,:,j))
           p = excitationIds(1,j)
           q = excitationIds(2,j)
           extype = excitationTypes(j)
           call convertOrbIdsToModelSpaceIds(alphas_Icfg(:,:,k), connectedI_alpha(:,:,j), p, q, extype, pmodel, qmodel)
           rowsikpq = AIJpqMatrixDimsList(NSOMOalpha,NSOMOI,extype,pmodel,qmodel,1)
           colsikpq = AIJpqMatrixDimsList(NSOMOalpha,NSOMOI,extype,pmodel,qmodel,2)
           totcolsTKI += colsikpq
           if(rowsTKI .LT. rowsikpq) rowsTKI = rowsikpq
           !print *,"----------------alpha------"
           !print *,k, Nalphas_Icfg
           !call debug_spindet(alphas_Icfg(1,1,k),N_int)
           !call debug_spindet(alphas_Icfg(1,2,k),N_int)
            print *,"----------------Icfg------- Isingle=",j
            call debug_spindet(connectedI_alpha(1,1,j),N_int)
            call debug_spindet(connectedI_alpha(1,2,j),N_int)
            print *,"----------------",NSOMOalpha,NSOMOI,"ex=",extype,pmodel,qmodel,"(",rowsikpq,colsikpq,")"
        end do

        !print *,"total columnTKI=",totcolsTKI
        !print *,"total rowsTKI=",rowsTKI
        ! allocate memory for table
        ! for 1 root
        ! for n roots dims = (rowsTKI,nroots,totcolsTKI)
        allocate(TKI(rowsTKI,totcolsTKI)) ! coefficients of CSF
        ! Initialize the inegral container
        ! dims : (totcolsTKI, nconnectedI)
        allocate(GIJpqrs(totcolsTKI,nconnectedI))  ! gpqrs
        allocate(TKIGIJ(rowsTKI,nconnectedI))  ! gpqrs

        TKI = 0.d0
        GIJpqrs = 0.d0
        TKIGIJ = 0.d0


        totcolsTKI = 0
        do j = 1,nconnectedI
           NSOMOalpha = getNSOMO(alphas_Icfg(:,:,k))
           NSOMOI = getNSOMO(connectedI_alpha(:,:,j))
           p = excitationIds(1,j)
           q = excitationIds(2,j)
           extype = excitationTypes(j)
           !print *,j,"calling to modelspaace pq=",p,q
           call convertOrbIdsToModelSpaceIds(alphas_Icfg(:,:,k), connectedI_alpha(:,:,j), p, q, extype, pmodel, qmodel)
           !print *,"det a"
           !call debug_spindet(alphas_Icfg(:,1,k),1)
           !call debug_spindet(alphas_Icfg(:,2,k),1)
           !print *,"det I"
           !call debug_spindet(connectedI_alpha(:,1,j),1)
           !call debug_spindet(connectedI_alpha(:,2,j),1)
           rowsikpq = AIJpqMatrixDimsList(NSOMOalpha,NSOMOI,extype,pmodel,qmodel,1)
           colsikpq = AIJpqMatrixDimsList(NSOMOalpha,NSOMOI,extype,pmodel,qmodel,2)
           !print *,"j=",j,">",rowsikpq,colsikpq,"ex=",extype,"pmod(p)=",p,"qmod(q)=",q," somoI=",NSOMOI," somoa=",NSOMOalpha
           do l = 1,rowsTKI
              do m = 1,colsikpq
                 TKI(l,totcolsTKI+m) = AIJpqContainer(NSOMOalpha,NSOMOI,extype,pmodel,qmodel,l,m) * psi_coef_config(j)
              enddo
           enddo
           do m = 1,colsikpq
              do l = 1,nconnectedI
                 ! <ij|kl> = (ik|jl)
                 moi = excitationIds(1,j)
                 mok = excitationIds(2,j)
                 moj = excitationIds(1,l)
                 mol = excitationIds(2,l)
                 GIJpqrs(totcolsTKI+m,l) = mo_two_e_integral(moi,moj,mok,mol)
              enddo
           enddo
           totcolsTKI += colsikpq
        end do


        !print *,"TKI matrix"
        !call printMatrix(TKI,rowsTKI,totcolsTKI)
        !print *,"GIJpqrs matrix"
        !call printMatrix(GIJpqrs,totcolsTKI,nconnectedI)

        ! Do big BLAS
        ! TODO TKI, size(TKI,1)*size(TKI,2)
        call dgemm('N','N', rowsTKI, nconnectedI, totcolsTKI, 1.d0,  &
          TKI, size(TKI,1), GIJpqrs, size(GIJpqrs,1), 0.d0, &
          TKIGIJ , size(TKIGIJ,1) )

        !print *,"TKIGIJ matrix"
        !call printMatrix(GIJpqrs,totcolsTKI,nconnectedI)

        ! Collect the result
        do j = 1,nconnectedI
           NSOMOalpha = getNSOMO(alphas_Icfg(:,:,k))
           NSOMOI     = getNSOMO(connectedI_alpha(:,:,j))
           p = excitationIds(1,j)
           q = excitationIds(2,j)
           extype = excitationTypes(j)
           call convertOrbIdsToModelSpaceIds(alphas_Icfg(:,:,k), connectedI_alpha(:,:,j), p, q, extype, pmodel, qmodel)
           rowsikpq = AIJpqMatrixDimsList(NSOMOalpha,NSOMOI,extype,pmodel,qmodel,1)
           colsikpq = AIJpqMatrixDimsList(NSOMOalpha,NSOMOI,extype,pmodel,qmodel,2)
           do m = 1,colsikpq
              do l = 1,rowsTKI
                 psi_coef_out(totcolsTKI + m) += AIJpqContainer(NSOMOalpha,NSOMOI,extype,pmodel,qmodel,l,m) * TKIGIJ(l,j)
                 psi_coef_out_init(totcolsTKI+m) = .True.
              enddo
           enddo
           totcolsTKI += colsikpq
        enddo

        deallocate(TKI) ! coefficients of CSF
        ! Initialize the inegral container
        ! dims : (totcolsTKI, nconnectedI)
        deallocate(GIJpqrs)  ! gpqrs
        deallocate(TKIGIJ)  ! gpqrs

     end do
  end do

  do i = 1,dimBasisCSF
     print *, "i=",i,"coef=",psi_coef_config(i),psi_coef_out(i)," ini?=",psi_coef_out_init(i)
  enddo

  end
#+end_src



#+begin_src f90 :main no
      integer Nint
      integer(bit_kind), dimension(1,2,100) :: singles
      integer n_singles
      Nint=1
      do i = 1, 1
         call generate_all_singles_cfg(psi_configuration(:,:,i), singles,&
         n_singles, Nint)
         print *,"Number of singles=",n_singles
         do j = 1, 2
            print *, psi_configuration(1,1,i), singles(1,1,j)
            MS = 0
            rows=-1
            cols=-1
            if(psi_configuration(1,1,i) .EQ. 0 .OR. singles(1,1,j) .EQ.0) cycle
            call getApqIJMatrixDims(psi_configuration(1,1,i),           &
                                    singles(1,1,j), &
                                    MS,                       &
                                    rows,                     &
                                    cols)
                                    print *, i,">",rows, cols

         end do
!        call printCFGlist(Nint, n_singles, singles)
      end do

      integer startDet, endDet
      do i = 1, 4
         startDet = psi_configuration_to_psi_det(1,i)
         endDet = psi_configuration_to_psi_det(2,i)
         do j = startDet, endDet
            print *, "\t",i, j, psi_configuration_to_psi_det_data(j)
         end do
      end do
      print *, 'Now starting to read my provider for dims'
      do i = 4,6,2
         do j = i-2,i+2,2
            print *,i,j,AIJpqMatrixDimsList(i,j,1,i,j,1), AIJpqMatrixDimsList(i,j,1,i,j,2)
         end do
      end do
      print *, 'Now starting to read my provider for matrix'
      do i = 4,6,2
         do j = i,i+2,2
            rows = AIJpqMatrixDimsList(i,j,1,i+1,1,1)
            cols = AIJpqMatrixDimsList(i,j,1,i+1,1,2)
            print *,i,j,rows,cols
            !print *,AIJpqContainer(i,j,1,i+1,1,:rows,:cols)
            call printMatrix(AIJpqContainer(i,j,1,i+1,1,:,:),14,14)
         end do
      end do
      print *, 'Hello world Tangled with two blocks'
      end
#+end_src

* Running QP

#+name: runqp
#+begin_src bash :results output
cd ~/Documents/codes/qp2
source quantum_package.rc
cd src/cfgCI
qp set_file n2.ezfio
ninja 2>&1 > /dev/null
qp run cfgCI
#+end_src

#+RESULTS: runqp
#+begin_example
Date: 28/01/2021 01:28:26
===============
Quantum Package
===============

Git Commit: Fixed doc
Git Date  : Mon Jan 25 22:54:59 2021 +0100
Git SHA1  : 46ce8a3
EZFIO Dir : n2.ezfio


Task server running : tcp://127.0.1.1:41279
.. >>>>> [ IO READ: read_wf ] <<<<< ..

.. >>>>> [ RES  MEM :       0.004993 GB ] [ VIRT MEM :       0.042542 GB ] <<<<< ..
.. >>>>> [ WALL TIME:       0.000144  s ] [ CPU  TIME:       0.001504  s ] <<<<< ..

 ,* mo_label          Canonical
,* Number of determinants                                       194
,* mo_num                                                        18
,* N_int                                                          1
.. >>>>> [ IO READ: elec_beta_num ] <<<<< ..

.. >>>>> [ RES  MEM :       0.004993 GB ] [ VIRT MEM :       0.107937 GB ] <<<<< ..
.. >>>>> [ WALL TIME:       0.001827  s ] [ CPU  TIME:       0.007938  s ] <<<<< ..

.. >>>>> [ IO READ: elec_alpha_num ] <<<<< ..

.. >>>>> [ RES  MEM :       0.004993 GB ] [ VIRT MEM :       0.107937 GB ] <<<<< ..
.. >>>>> [ WALL TIME:       0.001969  s ] [ CPU  TIME:       0.008272  s ] <<<<< ..

.. >>>>> [ IO READ: ao_num ] <<<<< ..

.. >>>>> [ RES  MEM :       0.004993 GB ] [ VIRT MEM :       0.107937 GB ] <<<<< ..
.. >>>>> [ WALL TIME:       0.002125  s ] [ CPU  TIME:       0.008358  s ] <<<<< ..

 Read  mo_coef
,* Dimension of the psi arrays                               100000
 Read psi_det
           1
 000000000000007F|000000000000007F
 |+++++++---------------------------------------------------------|
 |+++++++---------------------------------------------------------|
 000000000000013F|000000000000013F
 |++++++--+-------------------------------------------------------|
 |++++++--+-------------------------------------------------------|
 000000000000007F
 |+++++++---------------------------------------------------------|
 000000000000013F
 |++++++--+-------------------------------------------------------|
           1
      100000
                    0                  127
                    0                  191
                    0                  223
                    0                  239
 Number of singles=          84
                    0                    0
Isomo=0 Jsomo=0
NsomoI=0 NsomoJ=0
	 >> 1 1
           1 >                    1                    1
                    0                  129
Isomo=0 Jsomo=129
NsomoI=0 NsomoJ=2
	 >> 1 1
           1 >                    1                    1
 \t           1           1           1
 \t           2           2          22
 \t           3           3           3
 \t           4           4          21
 Hello world Tangled with two blocks
Wall time: 0:00:01

#+end_example
