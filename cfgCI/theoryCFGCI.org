# -*- mode:org -*-
#+TITLE: Theory CFGCI
#+AUTHOR: Vijay Gopal Chilkuri
#+EMAIL: vijay.gopal.c@gmail.com
#+OPTIONS: toc:t
#+LATEX_CLASS: article
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{braket}
#+LATEX_HEADER: \usepackage{minted}

* Introduction

There are three main aspects while using configuration based representation

* Algorithms

*** Small function to convert int to bit

Convert input CFG to an array of bits containing 0's and 1's representing
the position of SOMOs and DOMOs.

#+name: inttobindigit
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdint.h>

void int_to_bin_digit(int64_t in, int count, int* out)
{
    /* assert: count <= sizeof(int)*CHAR_BIT */
    unsigned int mask = 1U << (count-1);
    int i;
    for (i = 0; i < count; i++) {
        out[i] = (in & mask) ? 1 : 0;
        in <<= 1;
    }
}

void printRealMatrix(double *orthoMatrix, int rows, int cols){

    for(int i = 0; i < rows; i++){
        printf("\n");
        for(int j = 0; j < cols; j++){
            printf("%10.2f ",orthoMatrix[i*cols + j]);
        }
    }
    printf("\n");
}
#+end_src


*** Get number of CSFs

#+name: getncsfs
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>
#include <stdint.h>
#include <math.h>

inline double logbinom(double n, double k) {
    return lgamma(n+1)-lgamma(n-k+1)-lgamma(k+1);
}
inline double binom(double n, double k) {
    return exp(logbinom(n,k));
}

void getncsfs1(int *inpnsomo, int *inpms, int *outncsfs){
    int nsomo = *inpnsomo;
    int ms = *inpms;
    int nparcoupl = (nsomo + ms)/2;
    ,*outncsfs = binom(nsomo, nparcoupl);
}

void getncsfs(int NSOMO, int MS, int *outncsfs){
    int nparcoupl = (NSOMO + MS)/2;
    int nparcouplp1 = (NSOMO + MS+2)/2;
    int tmpndets=0;
    tmpndets = binom(NSOMO, nparcoupl);
    (*outncsfs) = tmpndets - binom(NSOMO, nparcouplp1);
}
#+end_src

** TODO [2/2] Print all CFGs

The only input required is the selected list of CFGs at a given CIPSI iteration \( I \).

- [X] Fortran module

  #+begin_src f90 :main no :tangle cfgCI_interface.f90
      module cfunctions
      use, intrinsic :: ISO_C_BINDING
      interface
         subroutine printcfglist(nint, ncfgs, cfglist) bind(C, name='printCFGList')
         import C_INT32_T, C_INT64_T
         integer(kind=C_INT32_T) :: nint
         integer(kind=C_INT32_T) :: ncfgs
         integer(kind=C_INT64_T) :: cfglist(nint,2,ncfgs)
         end subroutine printcfglist
      end interface
      interface
         subroutine getApqIJMatrixDims(Isomo, Jsomo, orbp, orbq,  &
         MS, rowApqIJ, colAqpIJ) bind(C, name='getApqIJMatrixDims')
         import C_INT32_T, C_INT64_T
         integer(kind=C_INT64_T),value :: Isomo ! CSFI
         integer(kind=C_INT64_T),value :: Jsomo ! CSFJ
         integer(kind=C_INT32_T),value :: orbp  ! Orbital p (changes in I)
         integer(kind=C_INT32_T),value :: orbq  ! Orbital q (changes in J)
         integer(kind=C_INT32_T),value :: MS    ! Ms = 2*Spin
         integer(kind=C_INT32_T),intent(out) :: rowApqIJ ! # of Rows of ApqIJ matrix
         integer(kind=C_INT32_T)  :: colApqIJ ! # of Columns of ApqIJ
         end subroutine getApqIJMatrixDims
      end interface
      interface
         subroutine getApqIJMatrixDriver(Isomo, Jsomo, orbp, orbq,  &
         MS, rowsApqIJ, colsAqpIJ, ApqIJ) bind(C, name='getApqIJMatrixDriver')
         import C_INT32_T, C_INT64_T
         integer(kind=C_INT64_T),value :: Isomo
         integer(kind=C_INT64_T),value :: Jsomo
         integer(kind=C_INT32_T),value :: orbp
         integer(kind=C_INT32_T),value :: orbq
         integer(kind=C_INT32_T),value :: MS
         integer(kind=C_INT32_T),intent(out) :: rowsApqIJ
         integer(kind=C_INT32_T) :: colsApqIJ
         !integer(kind=C_INT32_T),dimension(rowApqIJ,colApqIJ) :: ApqIJ
         integer(kind=C_INT32_T) :: ApqIJ
         end subroutine getApqIJMatrixDriver
      end interface
      end module cfunctions
  #+end_src


- [X] C function

#+name: printCFGlist
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>
#include <stdint.h>
#include "tree_utils.h"

void printCFGList(int32_t *inpNint, int32_t *inpNcfgs, int64_t *cfglist){
    int Ncfgs    = *inpNcfgs;
    int N_int    = *inpNint;
    int digit[MAX_SOMO];
    int64_t cfg1,cfg2;
    int nsomo=4;
    int ms=0;
    int ncsfs=0;
    printf("In 64 printcfglist\n");
    printf("Ncfgs = %d Nint=%d\n",Ncfgs, N_int);
    printf(" 1-- %d \n -- %d \n",cfglist[0*(2*Ncfgs) + 0*(Ncfgs) + 0], cfglist[0*(2*Ncfgs) + 1*(Ncfgs) + 0]);
    for(int i = 0; i < 15; i++){
        cfg1 = cfglist[1 + i*2];
        cfg2 = cfglist[0 + i*2];
        printf("%d> domo=%d somo=%d\n",i,cfg1,cfg2);
        int_to_bin_digit(cfg2,18,digit);
        for(int j=0;j<18;j++)
            printf("%d ",digit[j]);
        printf("\n");
    }
    getncsfs1(&nsomo,&ms,&ncsfs);
    printf("Nsomos = %d\n",ncsfs);
}
#+end_src

** Generate all singly excited CFGs

Generate all singly excited CFGs with respect to a given CFG.

#+name: genallSingly
#+begin_src fortran
#+end_src



** Generate BFs for a given number of SOMOs

A BF is represented as an integer. The bit representation of the integer (0 or 1) indicates the pairs. The BFs can be generated using the following rules:

1. A pair is represented by (0 1) with 0 indicating the left most index.

2. The right most 0 is linked with the left most 1.

This code generates all the bonded functions for a given number of SOMOs.

**** TODO [3/3] Algorithm

Here we describe how we generate the Bonded functions as shown in the example below.

#+begin_example
SOMO: [ 1 1 1 1 1] Ms = 1
BF list:
[[0 0 0 1 1]
 [0 0 1 0 1]
 [0 1 0 0 1]
 [0 0 1 1 0]
 [0 1 0 1 0]]
#+end_example

Basically, we use a binary tree to generate all the valid BFs.



- [X] Tree node data structure

The tree is built of a simple node which contains two links each for the two children \(C0, C1\) belonging to either a parallel \(0\)
or an anti-parallel \(1\) coupling. The address ~addr~ of all intermediate nodes is -1 and the address of the leaf node is the id of the BF
associated with the path traversed upon going back from the leaf to the root node using ~PREV~ pointer.

#+name: nodedef
#+begin_src c :main no :tangle tree_utils.h
#include <stdbool.h>

typedef struct bin_node Node;
typedef struct bin_tree Tree;
struct bin_node {
    Node *C0;
    Node *C1;
    Node *PREV;
    int addr;
    int cpl;
    int iSOMO;
};

struct bin_tree {
    Node *rootNode;
    int NBF;
};
#+end_src

- [X] Build Tree

  The algorithm for building the tree is very simple, the tree is constructed using two rules:

  1. The total number of 0's cannot be larger than ~zeromax~
  2. The total number of 1's cannot be smaller than ~onemin~

#+name: treefuncdefs
#+begin_src c :main no :tangle tree_utils.h
#include "/usr/include/x86_64-linux-gnu/cblas.h"

#define MAX_SOMO 32

void buildTreeDriver(Tree *bftree, int NSOMO, int MS, int *NBF);

void buildTree(Tree *bftree, Node **inode, int isomo, int izeros, int icpl, int NSOMOMax, int MSmax);

void printTreeDriver(Tree *bftree, int NSOMOMax);
void printTree(Node *bftree, int isomo, int NSOMOMax, int *vecBF);

void getIthBF(Node *node, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF);
void getIthBFDriver(Tree *bftree, int NSOMOMax, int getaddr, int *vecBF);

void getBFIndexList(int NSOMO, int *BF1, int *IdxListBF1);
void getIslands(int NSOMO, int *BF1, int *BF2, int *nislands, int *phasefactor);

void generateAllBFs(int64_t Isomo, int64_t MS, Tree *bftree, int *NBF, int *NSOMO);
void getSetBits(int64_t n, int *nsetbits);
void getOverlapMatrix(int64_t Isomo, int64_t MS, double **overlapMatrixptr, int *rows, int *cols, int *NSOMOout);
void gramSchmidt(double *overlapMatrix, int rows, int cols, double *orthoMatrix);


void calculateMETypeSOMOSOMO(int *BF1, int *BF2, int moi, int moj, double *factor, int *phasefactor);
void getOneElMETypeSOMOSOMO(int64_t Isomo, int64_t Jsomos, int moi, int moj, int MS, double **oneElMatrixElementsptr, int *rows, int *cols);

/***********************

Determinant Tree utils
,***********************/


void genDets(Tree *dettree,
               Node **inode,
               int isomo,
               int izeros,
               int icpl,
               int NSOMOMax,
               int MSmax);
void genDetsDriver(Tree *dettree, int NSOMO, int MS, int *Ndets);

void getIthDet(Node *inode, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF);
void getIthDetDriver(Tree *dettree, int NSOMOMax, int getaddr, int *vecBF);


/************************/

void genDetBasis(Tree *dettree, int Isomo, int MS, int *ndets);
void getbftodetfunction(Tree *dettree, int NSOMO, int MS, int *BF1, double *rowvec);
void convertBFtoDetBasis(int64_t Isomo, int MS, double **bftodetmatrixptr, int *rows, int *cols);

// Misc utils
void int_to_bin_digit(int64_t in, int count, int* out);
void printRealMatrix(double *orthoMatrix, int rows, int cols);

#+end_src

#+name: treefuncmain
#+begin_src c :main no :tangle tree_utils.c
void buildTree(Tree *bftree,
               Node **inode,
               int isomo,
               int izeros,
               int icpl,
               int NSOMOMax,
               int MSmax){

    // Find the maximum parallel couplings 0
    //      the maximum anti-parallel couplings 1
    int zeromax = MSmax + (NSOMOMax-MSmax)/2;
    int onemax = NSOMOMax - zeromax;

    // Exit condition
    if(isomo > NSOMOMax || icpl < 0 || izeros > zeromax ) return;

    // If we find a valid BF assign its address
    if(isomo == NSOMOMax){
        (*inode)->addr = bftree->rootNode->addr;
        bftree->rootNode->addr += 1;
        return;
    }

    // Call 0 branch
    if(((*inode)->C0) == -1 && izeros+1 <= zeromax){
        ((*inode)->C0) = malloc(sizeof(Node));
        (*(*inode)->C0) = (Node){ .C0 = -1, .C1 = -1, .PREV = *inode, .addr = -1, .cpl = 0, .iSOMO = isomo };
        buildTree(bftree, &(*inode)->C0, isomo+1, izeros+1, icpl+1, NSOMOMax, MSmax);
    }
    else buildTree(bftree, &(*inode)->C0, isomo+1, izeros+1, icpl+1, NSOMOMax, MSmax);

    // Call 1 branch
    if(((*inode)->C1) == -1 && icpl-1 >= 0){
        ((*inode)->C1) = malloc(sizeof(Node));
        (*(*inode)->C1) = (Node){ .C0 = -1, .C1 = -1, .PREV = *inode, .addr = -1, .cpl = 1, .iSOMO = isomo };
        buildTree(bftree, &(*inode)->C1, isomo+1, izeros+0, icpl-1, NSOMOMax, MSmax);
    }
    else buildTree(bftree, &(*inode)->C1, isomo+1, izeros+0, icpl-1, NSOMOMax, MSmax);

    return;
}

void buildTreeDriver(Tree *bftree, int NSOMO, int MS, int *NBF){
    int isomo = 0; // counts the total number of SOMO's
    int izeros= 0; // Counts the total number of parallel coupings (i.e. 0's)
    int icpl  = 0; // keep track of the ith ms (cannot be -ve)
    int addr  = 0; // Counts the total BF's

    buildTree(bftree, &(bftree->rootNode), isomo, izeros, icpl, NSOMO, MS);

    ,*NBF = bftree->rootNode->addr;
}

void printTree(Node *inode, int isomo, int NSOMOMax, int *vecBF){
    // Exit condition
    if(isomo > NSOMOMax) return;
    if(inode == -1) return;

    if(isomo == NSOMOMax){
        printf("add : %d > ",inode->addr);
        for(int i=0;i<NSOMOMax;i++)
            printf("%d ",vecBF[i]);
        printf("\n");
        return;
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(inode),inode->C1);


    // Recurse to C0
    if(inode->C0 != -1){
        vecBF[isomo] = 0;
        printTree(inode->C0, isomo+1, NSOMOMax, vecBF);
    }
    // Recurse to C1
    if(inode->C1 != -1){
        vecBF[isomo] = 1;
        printTree(inode->C1, isomo+1, NSOMOMax, vecBF);
    }

    return;
}

void printTreeDriver(Tree *bftree, int NSOMOMax){
    int isomo = 0;
    int vecBF[NSOMOMax];
    for(int i=0;i<NSOMOMax;i++)
        vecBF[i]=0;
    printTree((bftree->rootNode), isomo, NSOMOMax, vecBF);
}

void getIthBF(Node *inode, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF){
    // Exit condition
    if(foundBF) return;
    if(isomo > NSOMOMax) return;
    if(inode == -1) return;

    if(isomo == NSOMOMax){
        if(inode->addr == getaddr){
            for(int i = NSOMOMax-1; i > -1; i--){
                vecBF[i] = inode->cpl;
                inode = inode->PREV;
            }
            foundBF = true;
            return;
        }
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(inode),inode->C1);


    // Recurse to C0
    if(inode->C0 != -1){
        getIthBF(inode->C0, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }
    // Recurse to C1
    if(inode->C1 != -1){
        getIthBF(inode->C1, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }

    return;
}

void getIthBFDriver(Tree *bftree, int NSOMOMax, int getaddr, int *vecBF){
    int isomo = 0;
    bool foundBF = false;
    getIthBF((bftree->rootNode), isomo, foundBF, NSOMOMax, getaddr, vecBF);
}
#+end_src

- [X] Test Build BF

#+begin_src C :main no :noweb yes
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "/home/vijay/Documents/codes/qp2/plugins/local/pluginRepo/cfgCI/tree_utils.h"

<<treefuncmain>>

<<indexlist>>

<<calculateislands>>

void main(){
    int NSOMO = 6;
    int MS = 0;
    int NBF=0;
    Tree bftree = (Tree){  .rootNode = -1, .NBF = -1 };
    bftree.rootNode = malloc(sizeof(Node));
    (*bftree.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    buildTreeDriver(&bftree, NSOMO, MS, &NBF);

    //printTreeDriver(&bftree, NSOMO);

    int *BF1 = malloc(NSOMO * sizeof(int));
    int *BF2 = malloc(NSOMO * sizeof(int));

    int getaddr = 0;
    getIthBFDriver(&bftree, NSOMO, getaddr, BF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",BF1[i]);
    printf("\n");

    getaddr = 1;
    getIthBFDriver(&bftree, NSOMO, getaddr, BF2);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",BF2[i]);
    printf("\n");

    int *IdxListBF1 = malloc(NSOMO * sizeof(int));
    getBFIndexList(NSOMO, BF1, IdxListBF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",IdxListBF1[i]);
    printf("\n");

    getBFIndexList(NSOMO, BF2, IdxListBF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",IdxListBF1[i]);
    printf("\n");

    int nislands;
    int phasefactor;

    getIslands(NSOMO, BF1, BF2, &nislands, &phasefactor);
    printf("nislands = %d phase = %d\n",nislands,phasefactor);


    // Garbage collection
    free(BF1);
    free(BF2);
    free(IdxListBF1);

    return;
}
#+end_src

#+RESULTS:
| add      | : | 0 | >     | 0 | 0 | 0 | 1 | 1 | 1 |
| add      | : | 1 | >     | 0 | 0 | 1 | 0 | 1 | 1 |
| add      | : | 1 | >     | 5 | 4 | 3 | 2 | 1 | 0 |
| add      | : | 1 | >     | 5 | 2 | 1 | 4 | 3 | 0 |
| nislands | = | 2 | phase | = | 1 |   |   |   |   |


** Calculate the orthogonalization matrix

The orthogonalization matrix gives the orthonormalized vectors
in bonded-function (BF) (or determinant) basis which are eigenfunctions
of \( S^2 \) c.f. \( \mathbf{O}_{i}\) matrices.

*** Calculate Overlap between two BFs

In our representation, the BFs are represented as a seqence of \(0,1\)
as shown below:

#+begin_example
BF1 : [0 0 0 1 1] Ms = 1
      (1 (1 (2 3) 4)
#+end_example

The second representation is only used to derive the overlap/matrix-elements.

The overlap between two bonded functions is based on the derivations
by Cooper and McWeeney[?] and Sutcliffe[?]. They are based on Rumer
diagrams. Here, we shall briefly outline the algorithm for the
calculation of the overlap between two BFs.

In order to calculate the Overlap (\( S \)) between two bonded functions
\( V_r \) and \(V_s\), there are two steps which are as follows:

1. Permutations of the strings to bring \(V_r, V_s\) into maximum overlap
   configuration. This incurs a phase (\(-1\) for each permutation) \((-1)^r\).

2. The calculation of the number of Islands (\(i\)), the number of Open chains (\(O\)),
   and the number of E chains.

The description of the three types of diagrams is described below:

**** TODO [2/2] Islands

Once the two BFs are brought into maximum overlap, the number of islands can be
calculated. An island is defined as the total number of closed polygons formed
by joining the common indices in \(V_r\) and \(V_s\). The pairs in each BF
\(V_r\) and \(V_s\) are also joind by an arc. Each island has two primitive
spin-functions. A primitive spin-function is defined as a product of
\(\alpha-\beta\) pair in the two BFs. The two primitives originate from
assigning \(\alpha\) or \(\beta\) to the head and tail of the closed polygon or
vice-versa.

#+begin_example
      ------------------------------------
      |    --------------------------    |
      |    |    ----------------    |    |
      |    |    |    ------    |    |    |
      |    |    |    |   \ /  \ /  \ /  \ /
BF1 : 0    0    0    0    1    1    1    1
      |    |    |    |    |    |    |    |
BF2 : 0    1    0    0    0    1    1    1
      |   / \   |    |    |   / \  / \  / \
      ------    |    |    ------    |    |
                |    ----------------    |
                --------------------------
#+end_example

- [X] Get Index list

#+name: indexlist
#+begin_src c :main no #:tangle cfgCI_utils.c
#include <stdio.h>

void getBFIndexList(int NSOMO, int *BF1, int *IdxListBF1){
    int Iidx;
    int Jidx;
    int BFcopy[NSOMO];

    int dictidx[2];
    dictidx[0] = -1;
    dictidx[1] =  1;

    for(int i = 0; i < NSOMO; i++)
        BFcopy[i] = BF1[i];

    for(int i = 0; i < NSOMO; i++){
        Iidx = i;
        if(BFcopy[i] == 0){
            int countN1=0;
            for(int j = i+1; j < NSOMO; j++){
                Jidx = j;
                countN1 = countN1 + dictidx[BFcopy[j]];
                if(countN1 > 0){
                    break;
                }
            }
            BFcopy[Iidx] = -1;
            BFcopy[Jidx] = -1;
            IdxListBF1[Jidx] = Iidx;
            IdxListBF1[Iidx] = Jidx;
        }
    }

}
#+end_src

- [X] Get Islands


#+name: calculateIslands
#+begin_src c :main no #:tangle cfgCI_utils.c
#include <stdio.h>

void getIslands(int NSOMO, int *BF1, int *BF2, int *nislands, int *phasefactor){

    // Get BF ids
    int *IdxListBF1 = malloc(NSOMO * sizeof(int));
    int *IdxListBF2 = malloc(NSOMO * sizeof(int));

    getBFIndexList(NSOMO, BF1, IdxListBF1);
    getBFIndexList(NSOMO, BF2, IdxListBF2);

    int maxcount=0;
    ,*nislands = 0;
    ,*phasefactor = 1;

    int BF1copy[NSOMO];
    for(int i = 0; i < NSOMO; i++)
        BF1copy[i] = IdxListBF1[i];
    int BF2copy[NSOMO];
    for(int i = 0; i < NSOMO; i++)
        BF2copy[i] = IdxListBF2[i];

    for(int i = 0; i < NSOMO; i++){
        int thisId = i;
        int nextId = BF1copy[i];
        maxcount = 0;
        while(BF1copy[thisId] != -1 && maxcount < 20){
            if(maxcount==0) *nislands += 1;
            if(maxcount==19) *nislands -= 1;

            maxcount++;

            // First the bra
            nextId = BF1copy[thisId];
            BF1copy[thisId] = -1;
            BF1copy[nextId] = -1;
            //printf("\n(%d) %d> %d -> %d\n",i,maxcount,thisId,nextId);

            // Get the phase factor bra
            if(nextId < thisId) *phasefactor *= -1;

            // Then the ket
            thisId = BF2copy[nextId];
            BF2copy[thisId] = -1;
            BF2copy[nextId] = -1;
            //printf("\n(%d) %d> %d -> %d\n",i,maxcount,nextId,thisId);

            // Get the phase factor bra
            if(nextId > thisId) *phasefactor *= -1;

        }
        //printf("\nBF1\n");
        //for(int j = 0; j < NSOMO; j++)
        //    printf("%d ",BF1copy[j]);
        //printf("\nBF2\n");
        //for(int j = 0; j < NSOMO; j++)
        //    printf("%d ",BF2copy[j]);
    }

    // Garbage collection
    free(IdxListBF1);
    free(IdxListBF2);

}
#+end_src



**** Phase factor (r)

The phase factor is calculated according to the following rule. The connecting
lines shown in example above has a direction. Upon careful observation, one can
observe that out of the eight SOMOs 6 are aligned i.e. both bra and ket have arrows
or tails and 2 are misaligned. The phase \(r\) is defined as the minimum number of
flips required to pair all indices for the bra and ket indices. In the above example
three arrow directions have to be flipped giving \(r=3\) as shown below:

#+begin_example
      ------------------------------------
      |    --------------------------    |
      |    |    ----------------    |    |
      |    |    |    ------    |    |    |
      |   \ /   |   \ /   |   \ /   |   \ /
BF1 : 0    0    0    0    1    1    1    1
      |    |    |    |    |    |    |    |
BF2 : 0    1    0    0    0    1    1    1
      |   / \   |   / \   |   / \   |   / \
      ------    |    |    ------    |    |
                |    ----------------    |
                --------------------------
#+end_example

#+name: illustration islands
#+ATTR_ORG: :width 400
[[./illustration_islands.jpg]]

**** Open chains (O)

The open chains are constituted of open polygons which have an odd number of
sides. These are made up of BFs which consist of un-paired spins such as
\(2^{-1/2} \left[ \alpha(i)\beta(j) + \alpha(j)\beta(i) \right]\alpha(k) \) for
\(V_r\) and \(\alpha(i)-2^{-1/2} \left[ \alpha(j)\beta(k) + \alpha(k)\beta(j)
\right]\) for \(V_s\) respectively. These contribute a factor of \(1\) to the
MEs.

**** E type chains

The E type chains originate from BFs which contain different indices which are
mutually exclusive. The presence of mutually exclusive indices results in a
vanishing ME between such BFs.


Finally, the BFs contribute to the ME as follows:

#+name: EqCalcOvlp
\(
\braket{V_r | V_s} = \delta_{SS'}\delta_{E} 2^{i-s}(-1)^r
\)

Where \( S \) and \( S' \) are the spins for the \(V_r\) and \(V_s\)
respectively and \(s\) represents the total number of pairs in \(V_r\) and
\(V_s\). The total number of pairs are the same in \(V_r\) and \(V_s\) if they
belong to the same spin subspace.

**** TODO [3/7] Make the orthonormalization matrix

- [X] Calculate the number of SOMOs in the input CFG.

#+name:getNsomo
#+begin_src C :main no #:tangle cfgCI_utils.c
void getSetBits(int64_t n, int *nsetbits){
    int count = 0;
    while(n){
        count += n & 1;
        n >>= 1;
    }
    *nsetbits = count;
}
#+end_src

- [ ] Generate all the BF for the SOMOs in the CFG

#+name: generateAllBFs
#+begin_src C :main no #:tangle cfgCI_utils.c
void generateAllBFs(int64_t Isomo, int64_t MS, Tree *bftree, int *NBF, int *NSOMO){
    getSetBits(Isomo, NSOMO);
    buildTreeDriver(bftree, *NSOMO, MS, NBF);
}
#+end_src

- [ ] Fill the matrix using Eq:[[EqCalcOvlp]]


#+name: getOverlapMatrix
#+begin_src c :main no #:tangle cfgCI_utils.c
void getOverlapMatrix(int64_t Isomo, int64_t MS, double **overlapMatrixptr, int *rows, int *cols, int *NSOMOout){

    int64_t NBF = 0;
    int64_t NSOMO = 0;

    Tree bftree = (Tree){  .rootNode = -1, .NBF = -1 };
    bftree.rootNode = malloc(sizeof(Node));
    (*bftree.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Isomo, MS, &bftree, &NBF, &NSOMO);

    *NSOMOout = NSOMO;

    //printTreeDriver(&bftree, NSOMO);

    // Initialize overlap matrix
    (*overlapMatrixptr) = malloc(NBF*NBF*sizeof(double));
    (*rows) = NBF;
    (*cols) = NBF;

    double *overlapMatrix = (*overlapMatrixptr);

    //// initialize Matrix
    //for(int i = 0; i < NBF; i++)
    //    for(int j = 0; j < NBF; j++)
    //        overlapMatrix[i*NBF + j] = 0.0;

    int addI = 0;
    int addJ = 0;
    int *BF1 = malloc(MAX_SOMO * sizeof(int));
    int *BF2 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF1 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF2 = malloc(MAX_SOMO * sizeof(int));

    int g = 0;
    g = (NSOMO - MS)/2;
    printf("NBFs = %d NSOMOs = %d MS = %d g = %d\n",NBF,NSOMO,MS,g);

    int nislands; // Note that nislands < g always
    int phasefactor;

    int dictPhase[2];

    dictPhase[0] = 1;
    dictPhase[1] =-1;


    // Set block elements
    for(int i = 0; i < NBF; i++){
        addI = i;
        getIthBFDriver(&bftree, NSOMO, addI, BF1);
        getBFIndexList(NSOMO, BF1, IdxListBF1);

        //printf("addI : %d > ",addI);
        //for(int k=0;k<NSOMO;k++)
        //    printf("%d ",BF1[k]);
        //printf("\n");

        for(int j = 0; j < NBF; j++){
            addJ = j;
            getIthBFDriver(&bftree, NSOMO, addJ, BF2);
            getBFIndexList(NSOMO, BF2, IdxListBF2);
            //printf("addJ : %d > ",addI);
            //for(int k=0;k<NSOMO;k++)
            //    printf("%d ",BF2[k]);
            //printf("\n");

            // Get the i and r factors
            getIslands(NSOMO, BF1, BF2, &nislands, &phasefactor);

            //printf("(%d, %d) is=%d ph=%d fac=%10.15f\n",addI, addJ, nislands, phasefactor, phasefactor*1.0/(1 << (g-nislands)));

            overlapMatrix[i*NBF + j] = -1.0*phasefactor / (1 << (g - nislands));
        }
    }

    // Garbage collection
    free(BF1);
    free(IdxListBF1);
    free(BF2);
    free(IdxListBF2);

}
#+end_src

- [ ] Generate orthonormalization matrix

  A Gram-Schmidt orthogonalization will generate the CSFs from the BFs.

#+name: gramSchmidt
#+begin_src C :main no :noweb yes
void gramSchmidt(double *overlapMatrix, int rows, int cols, double *orthoMatrix){

    // vector
    double norm = 0.0;
    orthoMatrix[(rows-1)*cols + cols-1] = 1.0;
    for(int i = cols-2; i > -1; i--){
        orthoMatrix[(rows-1)*cols + i] = 0.0;
    }

    // Gram-Schmidt loop
    for(int i = rows-2; i > -1; i--){
        orthoMatrix[i*cols + i] = 1.0;
        for(int j = rows-1; j > i; j--){
            for(int k = rows-1; k >= j; k--){
                orthoMatrix[i*cols + j] += -1.0*orthoMatrix[j*cols + k]*overlapMatrix[i*cols + k];
            }
        }

        // Normalization
        norm = 0.0;
        for(int j = rows-1; j >= i; j--){
            norm += orthoMatrix[i*cols + j]*orthoMatrix[i*cols + j];
        }
        norm = sqrt(norm);
        for(int j = rows-1; j >= i; j--){
            orthoMatrix[i*cols + j] /= norm;
        }

    }

}
#+end_src

- [X] Generate det basis

  Generate the determinant representation of the BFs.

#+name: genDetBasis
#+begin_src C :main no

void genDets(Tree *dettree,
               Node **inode,
               int isomo,
               int izeros,
               int icpl,
               int NSOMOMax,
               int MSmax){

    // Find the maximum parallel couplings 0
    //      the maximum anti-parallel couplings 1
    int zeromax = MSmax + (NSOMOMax-MSmax)/2;
    int onemax = NSOMOMax - zeromax;

    // Exit condition
    if(isomo > NSOMOMax || izeros > zeromax || abs(icpl) > onemax) return;

    // If we find a valid BF assign its address
    if(isomo == NSOMOMax){
        (*inode)->addr = dettree->rootNode->addr;
        dettree->rootNode->addr += 1;
        return;
    }

    // Call 0 branch
    if(((*inode)->C0) == -1 && izeros+1 <= zeromax){
        ((*inode)->C0) = malloc(sizeof(Node));
        (*(*inode)->C0) = (Node){ .C0 = -1, .C1 = -1, .PREV = *inode, .addr = -1, .cpl = 0, .iSOMO = isomo };
        genDets(dettree, &(*inode)->C0, isomo+1, izeros+1, icpl+0, NSOMOMax, MSmax);
    }
    else genDets(dettree, &(*inode)->C0, isomo+1, izeros+1, icpl+0, NSOMOMax, MSmax);

    // Call 1 branch
    if(((*inode)->C1) == -1 && abs(icpl+1) <= onemax){
        ((*inode)->C1) = malloc(sizeof(Node));
        (*(*inode)->C1) = (Node){ .C0 = -1, .C1 = -1, .PREV = *inode, .addr = -1, .cpl = 1, .iSOMO = isomo };
        genDets(dettree, &(*inode)->C1, isomo+1, izeros+0, icpl+1, NSOMOMax, MSmax);
    }
    else genDets(dettree, &(*inode)->C1, isomo+1, izeros+0, icpl+1, NSOMOMax, MSmax);

    return;
}

void genDetsDriver(Tree *dettree, int NSOMO, int MS, int *Ndets){
    int isomo = 0; // counts the total number of SOMO's
    int izeros= 0; // Counts the total number of parallel coupings (i.e. 0's)
    int icpl  = 0; // keep track of the ith ms (cannot be -ve)
    int addr  = 0; // Counts the total BF's

    genDets(dettree, &(dettree->rootNode), isomo, izeros, icpl, NSOMO, MS);

    ,*Ndets = dettree->rootNode->addr;
}

void getIthDet(Node *inode, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF){
    // Exit condition
    if(foundBF) return;
    if(isomo > NSOMOMax) return;
    if(inode == -1) return;

    if(isomo == NSOMOMax){
        if(inode->addr == getaddr){
            for(int i = NSOMOMax-1; i > -1; i--){
                vecBF[i] = inode->cpl;
                inode = inode->PREV;
            }
            foundBF = true;
            return;
        }
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(inode),inode->C1);


    // Recurse to C0
    if(inode->C0 != -1){
        getIthDet(inode->C0, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }
    // Recurse to C1
    if(inode->C1 != -1){
        getIthDet(inode->C1, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }

    return;
}

void getIthDetDriver(Tree *dettree, int NSOMOMax, int getaddr, int *vecBF){
    int isomo = 0;
    bool foundBF = false;
    getIthDet((dettree->rootNode), isomo, foundBF, NSOMOMax, getaddr, vecBF);
}

void findAddofDet(Node *inode, int isomo, bool foundDet, int NSOMOMax, int *inpdet, int *addr){
    // Exit condition
    if(foundDet) return;
    if(isomo == NSOMOMax){
        foundDet = true;
        ,*addr = inode->addr;
        return;
    }
    //printf("%d | %d (%d)\n",isomo,inpdet[isomo],inode->addr);


    // Recurse to C0
    if(inpdet[isomo] == 0){
        if(inode->C0 != -1){
            findAddofDet(inode->C0, isomo+1, foundDet, NSOMOMax, inpdet, addr);
        }
        else{
            ,*addr = -1;
            return;
        }
    }
    else{
        // Recurse to C1
        if(inode->C1 != -1){
            findAddofDet(inode->C1, isomo+1, foundDet, NSOMOMax, inpdet, addr);
        }
        else{
            ,*addr = -1;
            return;
        }
    }

    return;
}

void findAddofDetDriver(Tree *dettree, int NSOMOMax, int *inpdet, int *addr){
    ,*addr = -1;
    int isomo = 0;
    bool foundDet = false;
    // for(int i=0;i<NSOMOMax;i++)
    //    printf("%d ",inpdet[i]);
    findAddofDet((dettree->rootNode), isomo, foundDet, NSOMOMax, inpdet, addr);
}

void getDetlist(Node *inode, int isomo, int NSOMOMax, int *vecBF, int *detlist){
    // Exit condition
    if(isomo > NSOMOMax) return;
    if(inode == -1) return;

    if(isomo == NSOMOMax){
        int idet=0;
        for(int k=0;k<NSOMOMax;k++){
            if(vecBF[k] == 1) idet = idet | (1<<(NSOMOMax-1-k));
        }
        detlist[inode->addr]=idet;
        return;
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(inode),inode->C1);


    // Recurse to C0
    if(inode->C0 != -1){
        vecBF[isomo] = 0;
        getDetlist(inode->C0, isomo+1, NSOMOMax, vecBF, detlist);
    }
    // Recurse to C1
    if(inode->C1 != -1){
        vecBF[isomo] = 1;
        getDetlist(inode->C1, isomo+1, NSOMOMax, vecBF, detlist);
    }

    return;
}

void getDetlistDriver(Tree *dettree, int NSOMOMax, int *detlist){
    int isomo = 0;
    int vecBF[NSOMOMax];
    getDetlist((dettree->rootNode), isomo, NSOMOMax, vecBF, detlist);
}

void genDetBasis(Tree *dettree, int Isomo, int MS, int *ndets){

    int NSOMO=0;
    getSetBits(Isomo, &NSOMO);
    genDetsDriver(dettree, NSOMO, MS, ndets);

}
#+end_src

- [X] Generate BF to Det matrix

  Here we generate the matrix of transformation from BF basis to
  determinant basis.

#+name: convertBFtoDetbasis
#+begin_src C :main no :noweb yes

void getbftodetfunction(Tree *dettree, int NSOMO, int MS, int *BF1, double *rowvec){
    int npairs = 1 << ((NSOMO - MS)/2);
    int idxp = 0;
    int idxq = 0;
    int *detslist = malloc(npairs*NSOMO*sizeof(int));
    double *phaselist = malloc(npairs*sizeof(double));
    for(int i=0;i<npairs;i++)
        phaselist[i] = 1.0;
    int shft = npairs;
    int donepq[NSOMO];
    double fac = 1.0;
    for(int i = 0; i < NSOMO; i++)
        donepq[i] = 0.0;
    //for(int i = 0; i < NSOMO; i++)
    //    printf("%d) %d\n",i,BF1[i]);

    for(int i = 0; i < NSOMO; i++){
        idxp = BF1[i];
        idxq = BF1[idxp];
        //printf("idxp=%d idxq=%d\n",idxp,idxq);
        // Do one pair only once
        if(donepq[idxp] > 0.0 || donepq[idxq] > 0.0) continue;
        fac *= 2.0;
        donepq[idxp] = 1.0;
        donepq[idxq] = 1.0;
        for(int j = 0; j < npairs; j = j + shft){
            for(int k = 0; k < shft/2; k++){
                detslist[(k+j)*NSOMO + idxp] = 1;
                detslist[(k+j)*NSOMO + idxq] = 0;
            }
            for(int k = shft/2; k < shft; k++){
                detslist[(k+j)*NSOMO + idxp] = 0;
                detslist[(k+j)*NSOMO + idxq] = 1;
                phaselist[k+j] *=-1;
            }
        }
        shft /= 2;
    }

    // Now get the addresses
    int inpdet[NSOMO];
    int addr = -1;
    for(int i = 0; i < npairs; i++){
        for(int j = 0; j < NSOMO; j++)
            inpdet[j] = detslist[i*NSOMO + j];
        findAddofDetDriver(dettree, NSOMO, inpdet, &addr);
        rowvec[addr] = 1.0 * phaselist[i]/sqrt(fac);
    }
}

void convertBFtoDetBasis(int64_t Isomo, int MS, double **bftodetmatrixptr, int *rows, int *cols){

    int NSOMO=0;
    getSetBits(Isomo, &NSOMO);
    int ndets = 0;
    int NBF = 0;
    double dNSOMO = NSOMO*1.0;
    double nalpha = (NSOMO + MS)/2.0;
    ndets = (int)binom(dNSOMO, nalpha);
    //printf("Ndets = %d\n",ndets);

    Tree dettree = (Tree){  .rootNode = -1, .NBF = -1 };
    dettree.rootNode = malloc(sizeof(Node));
    (*dettree.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    genDetBasis(&dettree, Isomo, MS, &ndets);

    //printTreeDriver(&dettree, NSOMO);
    //printf("Ndets = %d\n",ndets);

    int addr = -1;
    int inpdet[NSOMO];
    inpdet[0] = 1;
    inpdet[1] = 1;
    inpdet[2] = 1;
    inpdet[3] = 0;
    inpdet[4] = 0;
    inpdet[5] = 0;

    findAddofDetDriver(&dettree, NSOMO, inpdet, &addr);

    int detlist[ndets];
    getDetlistDriver(&dettree, NSOMO, detlist);

    //printf("\n");
    //for(int i=0;i<ndets;i++)
    //    printf("%d ",detlist[i]);
    //printf("\n");

    //printf("addr of det=%d\n",addr);

    // Prepare BFs
    Tree bftree = (Tree){  .rootNode = -1, .NBF = -1 };
    bftree.rootNode = malloc(sizeof(Node));
    (*bftree.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Isomo, MS, &bftree, &NBF, &NSOMO);

    //printf("in convert NBFs = %d ndets=%d\n",NBF,ndets);

    // Initialize transformation matrix
    (*bftodetmatrixptr) = malloc(NBF*ndets*sizeof(double));
    (*rows) = NBF;
    (*cols) = ndets;

    double *bftodetmatrix = (*bftodetmatrixptr);

    // Build BF to det matrix
    int addI = 0;
    int addJ = 0;
    double rowvec[ndets];
    for(int i=0;i<ndets;i++)
        rowvec[i]=0.0;
    int *BF1 = malloc(MAX_SOMO * sizeof(int));
    int *BF2 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF1 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF2 = malloc(MAX_SOMO * sizeof(int));

    for(int i = 0; i < NBF; i++){
        addI = i;
        getIthBFDriver(&bftree, NSOMO, addI, BF1);
        getBFIndexList(NSOMO, BF1, IdxListBF1);


        //printf("addI : %d > ",addI);
        //for(int k=0;k<NSOMO;k++)
        //    printf("%d ",BF1[k]);
        //printf("\n");

        // Get ith row
        getbftodetfunction(&dettree, NSOMO, MS, IdxListBF1, rowvec);

        //printf("---%d---\n",i);
        //for(int k=0;k<ndets;k++)
        //    printf("%10.4f ",rowvec[k]);
        //printf("\n");

        //printf("(%d, %d) is=%d ph=%d fac=%10.15f\n",addI, addJ, nislands, phasefactor, phasefactor*1.0/(1 << (g-nislands)));

        for(int j = 0; j < ndets; j++)
            bftodetmatrix[i*ndets + j] = rowvec[j];

        for(int k=0;k<ndets;k++)
            rowvec[k]=0.0;
    }

    // Garbage collection
    free(BF1);
    free(IdxListBF1);
    free(BF2);
    free(IdxListBF2);

}
#+end_src

- [ ] Calling Blas

  Call CBLAS routines

#+name: callingblas
#+begin_src C :main no tangle tree_utils.c
void callBlasMatxMat(double *A, int rowA, int colA, double *B, int rowB, int colB, double *C, bool transA, bool transB){
    int m = rowA;
    int k = colA;
    int n = colB;
    double alpha = 1.0;
    double beta  = 0.0;
    int val = 0;
    if (transA) val |= 0x1;
    if (transB) val |= 0x2;

    switch (val) {
        case 0: // notransA, notransB
            printf("type1\n");
            cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                        m, n, k, alpha, A, k, B, n, beta, C, n);
            break;
        case 1: // transA, notransB
            printf("type2\n");
            cblas_dgemm(CblasRowMajor, CblasTrans, CblasNoTrans,
                        m, n, k, alpha, A, k, B, n, beta, C, n);
            break;
        case 2: // notransA, transB
            printf("type3\n");
            cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasTrans,
                        m, n, k, alpha, A, k, B, n, beta, C, n);
            break;
        case 3: // notransA, notransB
            printf("type4\n");
            cblas_dgemm(CblasRowMajor, CblasTrans, CblasTrans,
                        m, n, k, alpha, A, k, B, n, beta, C, n);
            break;
        default:
            printf("Impossible !!!!\n");
            break;
    }
}
#+end_src

- [ ] Testing everything

#+begin_src C :main no :noweb yes :libs "-lm -lblas" :tangle main.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include "/home/vijay/Documents/codes/qp2/plugins/local/pluginRepo/cfgCI/tree_utils.h"
#include "/usr/include/x86_64-linux-gnu/cblas.h"

double logbinom(double n, double k);
//double logbinom(double n, double k) {
//    return lgamma(n+1)-lgamma(n-k+1)-lgamma(k+1);
//}
//
double binom(double n, double k);
//double binom(double n, double k) {
//    return exp(logbinom(n,k));
//}

<<inttobindigit>>

<<getncsfs>>

<<treefuncmain>>

<<indexlist>>

<<calculateislands>>

<<getNsomo>>

<<generateAllBFs>>

<<getOverlapMatrix>>

<<gramSchmidt>>

<<genDetBasis>>

<<convertBFtoDetBasis>>

<<calcMEdetpair>>

<<callcalcMEdetpair>>

<<callingblas>>

<<getApqIJMatrix>>

void main(){

    int rows = 0;
    int cols = 0;
    //double *overlapMatrixI;
    //double *overlapMatrixJ;
    //double *orthoMatrixI;
    //double *orthoMatrixJ;
    //double *bftodetmatrixI;
    //double *bftodetmatrixJ;
    double *ApqIJ;

    int64_t MS=0;
    int NSOMO=0;

    int64_t Isomo;
    Isomo = (1 << 4) - 1;
    Isomo = (1 << 6) - 1;
    //Isomo = (1 << 8) - 1;

    int64_t Jsomo;
    Jsomo = (1 << 6) - 1;
    Jsomo = (1 << 8) - 1;
    //Jsomo = (1 << 10) - 1;

    int orbp = 0;
    int orbq;
    orbq = 6-1;
    orbq = 8-1;
    //orbq = 10-1;

    getApqIJMatrixDriver(Isomo, Jsomo, orbp, orbq, MS, &ApqIJ, &rows, &cols);
    printf("ME CSF basis\n");
    printRealMatrix(ApqIJ, rows, cols);
    printf("ME CSF basis\n");


    // Test cblas
    //double *matA = malloc(10*20*sizeof(double));
    //double *matB = malloc(15*20*sizeof(double));
    //double *matC = malloc(10*15*sizeof(double));
    //for(int i=0;i<200;i++)
    //    matA[i]=1.0;
    //for(int i=0;i<300;i++)
    //    matB[i]=1.0;
    //for(int i=0;i<150;i++)
    //    matC[i]=0.0;

    //bool transA, transB;
    //transA = false;
    //transB = false;
    //callBlasMatxMat(matA, 10, 20, matB, 20, 15, matC, transA, transB);

    //printf("matC\n");
    //printRealMatrix(matC, 10,15);
    //printf("matC\n");


    // Garbage collection
    free(ApqIJ);

    //free(matA);
    //free(matB);
    //free(matC);

    return;
}
#+end_src

#+RESULTS:
| NBFs  |     = |     5 | NSOMOs |     = |     6 |    MS |     = |     0 |     g |     = |     3 |       |       |
| NBFs  |     = |    14 | NSOMOs |     = |     8 |    MS |     = |     0 |     g |     = |     4 |       |       |
| type1 |       |       |        |       |       |       |       |       |       |       |       |       |       |
| type1 |       |       |        |       |       |       |       |       |       |       |       |       |       |
| type1 |       |       |        |       |       |       |       |       |       |       |       |       |       |
| type1 |       |       |        |       |       |       |       |       |       |       |       |       |       |
| ME    |   CSF | basis |        |       |       |       |       |       |       |       |       |       |       |
|       |       |       |        |       |       |       |       |       |       |       |       |       |       |
| -0.07 |  0.14 | -0.13 |   0.08 | -0.13 |  0.13 |  0.05 |  -0.1 |   0.2 |  0.05 | -0.08 |  0.13 |  0.16 | -0.26 |
| 0.05  |  0.02 | -0.04 |   0.04 | -0.06 |  0.04 | -0.08 | -0.14 |  0.19 |  0.12 |  -0.1 |  0.04 |  0.22 | -0.09 |
| 0.05  | -0.13 |  0.05 |   0.07 |  0.04 | -0.04 | -0.18 |  0.12 | -0.03 | -0.02 |  0.04 | -0.06 | -0.02 | -0.08 |
| -0.05 | -0.04 |  0.15 |   -0.1 |  0.04 | -0.09 |   0.1 |  0.17 | -0.22 | -0.16 |  0.18 | -0.09 | -0.22 |  0.03 |
| -0.04 |  -0.0 |  0.01 |   0.08 | -0.06 |  0.02 |  0.03 | -0.03 | -0.04 |   0.1 | -0.13 |   0.1 |   0.1 | -0.25 |
| ME    |   CSF | basis |        |       |       |       |       |       |       |       |       |       |       |


** Make the prototype matrices

The prototype matrices give the matrix-elements (MEs) for a given type
of excitation \(p->q\) of a specific type between two CFGs \(I,J\).

These matrices are independent of the MOs and only depend on the total number of
electrons \(nel\), total number of orbitals \(norb\), and the total spin \(S\).

#+name: makePrototypeMatrices
#+begin_src c
void makePrototypeMatrices(int nel, int norb, double spin);
#+end_src

** Functions required for calculating MEs

*** TODO [3/3] Calculate MEs in Det basis

- [X] Calculate one-electron ME between two dets

#+name: calcMEdetpair
#+begin_src C :main no
void calcMEdetpair(int *detlistI, int *detlistJ, int orbI, int orbJ, int NSOMOI, int NSOMOJ, int ndetI, int ndetJ, double *matelemdetbasis){
    int mask = 0;
    double sgn[2];
    sgn[0] = 1.0;
    sgn[1] =-1.0;
    if(ndetI > ndetJ){
        // SOMO -> SOMO
        for(int i=0;i<NSOMOI;i++)
            mask = mask | (1 << i);
        mask = mask - 1;
        mask = mask ^ (1 << (NSOMOI-1));
        for(int i=0;i<ndetI;i++){
            int idet = (mask & detlistI[i]) >> 1;
            for(int j=0;j<ndetJ;j++){
                int jdet = (detlistJ[j]);
                double phase = 1.0*sgn[NSOMOJ%2];
                if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
            }
        }
    }
    else if (ndetJ > ndetI){
        // DOMO -> VMO
        for(int i=0;i<NSOMOJ;i++)
            mask = mask | (1 << i);
        mask = mask - 1;
        mask = mask ^ (1 << (NSOMOJ-1));
        for(int i=0;i<ndetJ;i++){
            int idet = (mask & detlistJ[i]) >> 1;
            for(int j=0;j<ndetI;j++){
                int jdet = (detlistI[j]);
                double phase = 1.0*sgn[__builtin_popcount(jdet)%2];
                if(idet == jdet) matelemdetbasis[j*ndetJ + i] = 1.0*phase;
            }
        }
    }
    else{
        int maskI=0;
        int maskJ=0;
        // DOMO -> SOMO
        if(orbI > orbJ){
            // 2 1 1 1 1 -> 1 1 1 1 2
            // mask
            // 0 1 1 1 0 -> 0 1 1 1 0
            for(int i=0;i<ndetJ;i++){
                int idet = detlistJ[i];
                for(int j=0;j<ndetI;j++){
                    int jdet = (detlistI[j]);
                    double phase = 1.0*sgn[__builtin_popcount(jdet)%2];
                    if(idet == jdet) matelemdetbasis[j*ndetJ + i] = 1.0*phase;
                }
            }
        }
        else{
            // 1 1 1 1 2 -> 2 1 1 1 1
            // mask
            // 0 1 1 1 0 -> 0 1 1 1 0
            for(int i=0;i<ndetJ;i++){
                int idet = detlistJ[i];
                for(int j=0;j<ndetI;j++){
                    int jdet = (detlistI[j]);
                    double phase = 1.0*sgn[__builtin_popcount(jdet)%2];
                    if(idet == jdet) matelemdetbasis[j*ndetJ + i] = 1.0*phase;
                }
            }
        }
    }
}
#+end_src

- [X] Calculate batch of MEs between CFGs

  Calculate the ME betwee two somos

#+name: callcalcMEdetpair
#+begin_src C :main no
void callcalcMEij(int Isomo, int Jsomo, int orbI, int orbJ, int MS, double **ApqIJptr, int *rowsA, int *colsA){
    // Get dets for I
    int ndetI;
    int ndetJ;

    // Get detlist
    int NSOMOI=0;
    int NSOMOJ=0;
    getSetBits(Isomo, &NSOMOI);
    getSetBits(Jsomo, &NSOMOJ);

    Tree dettreeI = (Tree){  .rootNode = -1, .NBF = -1 };
    dettreeI.rootNode = malloc(sizeof(Node));
    (*dettreeI.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    genDetBasis(&dettreeI, Isomo, MS, &ndetI);

    Tree dettreeJ = (Tree){  .rootNode = -1, .NBF = -1 };
    dettreeJ.rootNode = malloc(sizeof(Node));
    (*dettreeJ.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    genDetBasis(&dettreeJ, Jsomo, MS, &ndetJ);

    int detlistI[ndetI];
    int detlistJ[ndetJ];

    // Get detlist
    getDetlistDriver(&dettreeI, NSOMOI, detlistI);
    getDetlistDriver(&dettreeJ, NSOMOJ, detlistJ);

    (*ApqIJptr) = malloc(ndetI*ndetJ*sizeof(double));
    (*rowsA) = ndetI;
    (*colsA) = ndetJ;
    //printf("ndetI=%d ndetJ=%d\n",ndetI,ndetJ);

    double *matelemdetbasis = (*ApqIJptr);

    for(int i=0;i<ndetI;i++)
        for(int j=0;j<ndetJ;j++)
            matelemdetbasis[i*ndetJ + j]=0.0;

    // Garbage collection
    calcMEdetpair(detlistI, detlistJ, orbI, orbJ, NSOMOI, NSOMOJ, ndetI, ndetJ, matelemdetbasis);

    //printRealMatrix(matelemdetbasis, ndetI, ndetJ);

    // Garbage collection
}
#+end_src

- [X] Transform the MEs in CSF basis

  Transform the bra and ket indices to CSF basis from DET basis. The traonsformation
  proceeds in two steps. In the first step, the DET basis is transformed to BF basis followed
  by the transformation of the BF basis to CSF basis. Each of the transformation is carried out
  using DGEMM calls.

#+name: getApqIJMatrix
#+begin_src C :main no
void getApqIJMatrixDims(int64_t Isomo, int64_t Jsomo, int orbp, int orbq, int64_t MS, int *rowsout, int *colsout){
    int NSOMOI=0;
    int NSOMOJ=0;
    getSetBits(Isomo, &NSOMOI);
    getSetBits(Jsomo, &NSOMOJ);
    int NBFI=0;
    int NBFJ=0;
    getncsfs(NSOMOI, MS, &NBFI);
    getncsfs(NSOMOJ, MS, &NBFJ);
}

void getApqIJMatrixDriver(int64_t Isomo, int64_t Jsomo, int orbp, int orbq, int64_t MS, double **CSFICSFJApqIJptr, int *rowsout, int *colsout){

    double *overlapMatrixI;
    double *overlapMatrixJ;
    double *orthoMatrixI;
    double *orthoMatrixJ;
    double *bftodetmatrixI;
    double *bftodetmatrixJ;
    double *ApqIJ;
    int NSOMO=0;

    /***********************************
                   Doing I
    ,************************************/
    // Fill matrix
    int rowsI = 0;
    int colsI = 0;

    getOverlapMatrix(Isomo, MS, &overlapMatrixI, &rowsI, &colsI, &NSOMO);

    //printf("\nDone Overlap Matrix I\n");
    //printRealMatrix(overlapMatrixI, rowsI, colsI);
    //printf("\nDone Overlap Matrix I\n");

    orthoMatrixI = malloc(rowsI*colsI*sizeof(double));

    gramSchmidt(overlapMatrixI, rowsI, colsI, orthoMatrixI);

    //printf("\nDone Gram-Schmidt orthonormalization I\n");

    //printRealMatrix(orthoMatrixI, rowsI, colsI);

    //printf("\nGen det basis I \n");

    int rowsbftodetI, colsbftodetI;

    convertBFtoDetBasis(Isomo, MS, &bftodetmatrixI, &rowsbftodetI, &colsbftodetI);

    //printf("\n");
    //printRealMatrix(bftodetmatrixI, rowsbftodetI, colsbftodetI);
    //printf("\n");

    /***********************************
                   Doing J
    ,************************************/

    int rowsJ = 0;
    int colsJ = 0;
    // Fill matrix
    getOverlapMatrix(Jsomo, MS, &overlapMatrixJ, &rowsJ, &colsJ, &NSOMO);

    //printf("\nDone overlap J\n");
    //printRealMatrix(overlapMatrixJ, rowsJ, colsJ);
    //printf("\nDone overlap J\n");

    orthoMatrixJ = malloc(rowsJ*colsJ*sizeof(double));

    gramSchmidt(overlapMatrixJ, rowsJ, colsJ, orthoMatrixJ);

    //printf("\nDone Gram-Schmidt orthonormalization\n");
    //printRealMatrix(orthoMatrixJ, rowsJ, colsJ);
    //printf("\nDone Gram-Schmidt orthonormalization\n");


    int rowsbftodetJ, colsbftodetJ;

    convertBFtoDetBasis(Jsomo, MS, &bftodetmatrixJ, &rowsbftodetJ, &colsbftodetJ);

    //printf("dims BFtoDetJ rowsbftodetJ=%d colsbftodetJ=%d\n",rowsbftodetJ,colsbftodetJ);

    //printf("\nGen det basis \n");
    //printRealMatrix(bftodetmatrixJ, rowsbftodetJ, colsbftodetJ);
    //printf("\nGen det basis \n");

    int rowsA = 0;
    int colsA = 0;

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, &ApqIJ, &rowsA, &colsA);

    //printf("Done MEij\n");
    //printRealMatrix(ApqIJ, rowsA, colsA);
    //printf("Done MEij\n");

    // Final ME in BF basis

    // First transform I in bf basis
    double *bfIApqIJ = malloc(rowsbftodetI*colsA*sizeof(double));

    int transA=false;
    int transB=false;
    callBlasMatxMat(bftodetmatrixI, rowsbftodetI, colsbftodetI, ApqIJ, rowsA, colsA, bfIApqIJ, transA, transB);

    //printf("Done blas BFI\n");
    //printRealMatrix(bfIApqIJ, colsI, colsA);

    // now transform I in csf basis
    double *CSFIApqIJ = malloc(rowsI*colsA*sizeof(double));
    transA = false;
    transB = false;
    callBlasMatxMat(orthoMatrixI, rowsI, colsI, bfIApqIJ, colsI, colsA, CSFIApqIJ, transA, transB);

    //printf("Done blas CSFI\n");
    //printRealMatrix(CSFIApqIJ, rowsI, colsA);
    //printf("Done blas CSFI\n");

    // now transform J in BF basis
    double *CSFIbfJApqIJ = malloc(rowsI*rowsbftodetJ*sizeof(double));
    //printf("rowsI = %d colsA=%d | rowsbftodetJ=%d colsbftodetJ=%d\n",rowsI,colsA,rowsbftodetJ,colsbftodetJ);
    transA = false;
    transB = false;
    callBlasMatxMat(CSFIApqIJ, rowsI, colsA, bftodetmatrixJ, colsbftodetJ, rowsbftodetJ, CSFIbfJApqIJ, transA, transB);

    //printf("Done blas BFJ\n");
    //printRealMatrix(CSFIbfJApqIJ, rowsI, rowsbftodetJ);
    //printf("Done blas BFJ\n");

    // now transform J in CSF basis
    (*CSFICSFJApqIJptr) = malloc(rowsI*rowsJ*sizeof(double));
    (*rowsout) = rowsI;
    (*colsout) = rowsJ;

    double *CSFICSFJApqIJ = (*CSFICSFJApqIJptr);
    transA = false;
    transB = false;
    callBlasMatxMat(CSFIbfJApqIJ, rowsI, rowsbftodetJ, orthoMatrixJ, colsJ, rowsJ, CSFICSFJApqIJ, transA, transB);

    //printf("ME CSF basis\n");
    //printRealMatrix(CSFICSFJApqIJ, rowsI, rowsJ);


    // Garbage collection
    free(overlapMatrixI);
    free(overlapMatrixJ);
    free(orthoMatrixI);
    free(orthoMatrixJ);
    free(bftodetmatrixI);
    free(bftodetmatrixJ);
    free(ApqIJ);
    free(bfIApqIJ);
    free(CSFIApqIJ);
    free(CSFIbfJApqIJ);
}
#+end_src

*** TODO [1/4] Table of matrix-elements

The first step twoards the evaluation of MEs between bonded-functions is
the tabulation of the effect of the application of the operator on BFs.

There are four type of cases depending on the type of orbitals for the excitaton
i.e. for \(\hat{E}_{ji}\), the type of orbitals possible for \(i\) are DOMO or
SOMO and the type of orbitals possible for \(j\) are SOMO or VMO respectively.
The table of MEs will be different in each case

Here is a table which lists the action of E_{j,i} on all the various
cases of BFs that can arise.

- [ ] SOMO -> VMO type

  This is the simplest type. The \(i\) th SOMO is simply replaced
  by the \(j\) th one.

#+name: SOMO -> VMO
| BF (ket) | Type | Operator         | BF (bra) |
|          |      | \(\hat{E}_{ji}\) |          |
|          |      |                  |          |
| (i       | C-C  | \(1\)            | (j       |
|          |      |                  |          |

- [X] SOMO -> SOMO type

This is slightly involved depending on the type of SOMO \(i\)
and type of SOMO \(j\) and to which islands they belong to.

#+name: SOMO -> SOMO
|   | BF (ket)    | Type | Operator                | BF (bra) |
|   |             |      | \(\hat{E}_{ji}\)        |          |
|   |             |      |                         |          |
| 1 | (i j)       | C-C  | \(\sqrt{2}\)            | -        |
| 2 | (i k) (j l) | C-C' | \(-\frac{1}{\sqrt{2}}\) | (kl)     |
| 3 | (i k) (j    | C-O  | \(-\frac{1}{\sqrt{2}}\) | (k       |
| 4 | (i (j k)    | O-C  | \(-\frac{1}{\sqrt{2}}\) | (k       |
| 5 | (i (j       | O-C  | \(0\)                   | -        |

- [ ] DOMO -> VMO

  Here two extra SOMOs will be created and the MEs of
  the operator will form a rectangular matrix.

#+name: DOMO -> SOMO
| BF (ket) | Type | Operator         | BF (bra)   |
|          |      | \(\hat{E}_{ji}\) |            |
|          |      |                  |            |
| (ii)     | O    | \(\sqrt{2}\)     | (i j)      |
| (ii)     | C    | \(0\)            | (i k)(j l) |
|          |      |                  |            |

- [ ] DOMO -> SOMO

  Here the total number of SOMOs is kept the same therefore,
  there is no change in the BFs for bra and ket functions.

#+name: DOMO -> SOMO
| BF (ket) | Type | Operator         | BF (bra) |
|          |      | \(\hat{E}_{ji}\) |          |
|          |      |                  |          |
| (ii      | O    | \( 1\)           | (j       |
| (i k)    | C    | \(-1\)           | (j k)    |
|          |      |                  |          |

** TODO [0/4] Calculate the Operator MEs

The operator matrix-elements are calculated using the bonded-function (or
determinant) basis and are called \( A^{pq}_{IK} \), where \(p,q\) are the two
molecular orbital indices and \(I,K\) are the two CFGs.

Note that this function simply returns the value from a prototype lookup table
which contains the pretabulated values for a given \(p,q\) excitation of a
specified type which is one of the four:

1. SOMO \(->\) VMO
2. SOMO \(->\) SOMO
3. DOMO \(->\) VMO
4. DOMO \(->\) SOMO




- [ ] SOMO -> VMO type

  This case is the simplest and there is only one
  non-vanising ME as shown in Table:[[SOMO -> VMO]].
  Therefore, the one-electron operator MEs are
  that of the identity matrix.

- [ ] SOMO -> SOMO type

  The MEs for the various types are given in Table:[[SOMO -> SOMO]].
  Here we implement the rules.

#+name: calculateMETypeSOMOSOMO
#+begin_src C :main no #:tangle cfgCI_utils.c
void calculateMETypeSOMOSOMO(int *BF1, int *BF2, int moi, int moj, double *factor, int *phasefactor){

    // Calculate the factor following rules in the table
    // find the type

    if(BF1[moi] == moj){
        // Type I
        (*factor) = sqrt(2.0);
        (*phasefactor) = 1;
    }
    else{
        if(BF1[moi] != moi || BF1[moj] != moj){
            // Type II, III and IV
            (*factor) = 1.0/sqrt(2.0);
            (*phasefactor) =-1;
        }
        else{
            // Type V
            (*factor) = 0.0;
            (*phasefactor) = 1;
        }
    }


}
#+end_src

#+name: getOneElMETypeSOMOSOMO
#+begin_src C :main no
void getOneElMETypeSOMOSOMO(int64_t Isomo, int64_t Jsomo, int moi, int moj, int MS, double **oneElMatrixElementsptr, int *rows, int *cols){

    // Icfg

    int64_t INBF = 0;
    int64_t INSOMO = 0;

    Tree Ibftree = (Tree){  .rootNode = -1, .NBF = -1 };
    Ibftree.rootNode = malloc(sizeof(Node));
    (*Ibftree.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Isomo, MS, &Ibftree, &INBF, &INSOMO);

    // Jcfg

    int64_t JNBF = 0;
    int64_t JNSOMO = 0;

    Tree Jbftree = (Tree){  .rootNode = -1, .NBF = -1 };
    Jbftree.rootNode = malloc(sizeof(Node));
    (*Jbftree.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Jsomo, MS, &Jbftree, &JNBF, &JNSOMO);


    // Initialize orthonormalization matrix

    (*oneElMatrixElementsptr) = malloc(INBF*JNBF*sizeof(double));
    (*rows) = INBF;
    (*cols) = JNBF;

    double *oneElMatrixElements = (*oneElMatrixElementsptr);

    // Calculate Matrix

    int addI = 0;
    int addJ = 0;
    int *BF1 = malloc(MAX_SOMO * sizeof(int));
    int *BF2 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF1 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF2 = malloc(MAX_SOMO * sizeof(int));

    int g = 0;
    g = (INSOMO - MS)/2;
    printf("NBFs = %d NSOMOs = %d MS = %d g = %d\n",INBF,INSOMO,MS,g);

    int nislands; // Note that nislands < g always
    int phasefactor;
    double factor;
    nislands = 0;
    phasefactor = 1;
    factor = 0.0;

    int dictPhase[2];

    dictPhase[0] = 1;
    dictPhase[1] =-1;


    // Set block elements
    for(int i = 0; i < INBF; i++){
        addI = i;
        getIthBFDriver(&Ibftree, INSOMO, addI, BF1);
        getBFIndexList(INSOMO, BF1, IdxListBF1);

        //printf("addI : %d > ",addI);
        //for(int k=0;k<NSOMO;k++)
        //    printf("%d ",BF1[k]);
        //printf("\n");

        for(int j = 0; j < JNBF; j++){
            addJ = j;
            getIthBFDriver(&Jbftree, JNSOMO, addJ, BF2);
            getBFIndexList(JNSOMO, BF2, IdxListBF2);
            //printf("addJ : %d > ",addI);
            //for(int k=0;k<NSOMO;k++)
            //    printf("%d ",BF2[k]);
            //printf("\n");

            // Get the i and r factors
            calculateMETypeSOMOSOMO(IdxListBF1, IdxListBF2, moi, moj, &factor, &phasefactor);

            //printf("(%d, %d) is=%d ph=%d fac=%10.15f\n",addI, addJ, nislands, phasefactor, phasefactor*1.0/(1 << (g-nislands)));

            oneElMatrixElements[i*INBF + j] = -1.0*phasefactor*factor;
        }
    }

    // Garbage collection
    free(BF1);
    free(IdxListBF1);
    free(BF2);
    free(IdxListBF2);
}
#+end_src

#+RESULTS: METypeSOMOSOMO

- [ ] DOMO -> VMO type

- [ ] DOMO -> SOMO type

- [ ] Testing


#+begin_src C :main no :noweb yes
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include "/home/vijay/Documents/codes/qp2/plugins/local/pluginRepo/cfgCI/tree_utils.h"

<<inttobindigit>>

<<treefuncmain>>

<<indexlist>>

<<calculateislands>>

<<getNsomo>>

<<generateAllBFs>>

<<getOrthoMatrix>>

<<calculateMETypeSOMOSOMO>>

<<getOneElMETypeSOMOSOMO>>

void main(){

    int rows = 0;
    int cols = 0;
    double *oneElMatrixElementsptr;

    int64_t MS=0;

    int64_t Isomo;
    Isomo = (1 << 8) - 1;

    int64_t Jsomo;
    Jsomo = (1 << 6) - 1;

    int moi = 6;
    int moj = 7;

    //int digit[MAX_SOMO];
    //int_to_bin_digit(Isomo, MAX_SOMO, digit);
    //for(int j=0;j<MAX_SOMO;j++)
    //    printf("%d ",digit[j]);
    //printf("\n");

    // Fill matrix
    getOneElMETypeSOMOSOMO(Isomo, Jsomo, moi, moj, MS, &oneElMatrixElementsptr, &rows, &cols);

    printRealMatrix(oneElMatrixElementsptr, rows, cols);

    // Garbage collection
    free(oneElMatrixElementsptr);

    return;
}
#+end_src

#+RESULTS:


#+name: getOneElOperatorMatrix
#+begin_src c
void getOneElOperatorMatrix(int *cfgI, int *cfgK);
#+end_src

** Sigma-Vector I

The one-electron part \( \sum_{pq} \tilde{h}_{pq} <\Psi|\hat{E}_{pq}|\Psi>\).

** Sigma-Vector II

The two-electron part \(\frac{1}{2} \sum_{pq,rs} g(pq,rs) <\Psi|\hat{E}_{pq}\hat{E}_{rs}|\Psi> \)

*** Function to calculate Sigma-Vector

#+name: calcSigmaFunction
#+begin_src c :results output
void calcSigma(double *coeff, double *Gpqrs){
}
#+end_src

* Bibliography

bibliography:biblio.org
