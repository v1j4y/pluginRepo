# -*- mode:org -*-
#+TITLE: Theory CFGCI
#+AUTHOR: Vijay Gopal Chilkuri
#+EMAIL: vijay.gopal.c@gmail.com
#+OPTIONS: toc:t
#+LATEX_CLASS: article
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{braket}
#+LATEX_HEADER: \usepackage{minted}

* Introduction

There are three main aspects while using configuration based representation

* Algorithms

*** Small function to convert int to bit

Convert input CFG to an array of bits containing 0's and 1's representing
the position of SOMOs and DOMOs.

#+name: printCFGlist
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdint.h>

void int_to_bin_digit(int64_t in, int count, int* out)
{
    /* assert: count <= sizeof(int)*CHAR_BIT */
    unsigned int mask = 1U << (count-1);
    int i;
    for (i = 0; i < count; i++) {
        out[i] = (in & mask) ? 1 : 0;
        in <<= 1;
    }
}
#+end_src


*** Get number of CSFs

#+name: getncsfs
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>
#include <stdint.h>
#include <math.h>

inline double logbinom(double n, double k) {
    return lgamma(n+1)-lgamma(n-k+1)-lgamma(k+1);
}
inline double binom(double n, double k) {
    return exp(logbinom(n,k));
}

void getncsfs(int *inpnsomo, int *inpms, int *outncsfs){
    int nsomo = *inpnsomo;
    int ms = *inpms;
    int nparcoupl = (nsomo + ms)/2;
    *outncsfs = binom(nsomo, nparcoupl);
}
#+end_src

** TODO [2/2] Print all CFGs

The only input required is the selected list of CFGs at a given CIPSI iteration \( I \).

- [X] Fortran module

  #+begin_src fortran :main no :tangle cfgCI_interface.f90
      module cfunctions
      use, intrinsic :: ISO_C_BINDING
      interface
         subroutine printcfglist(nint, ncfgs, cfglist) bind(C, name='printCFGList')
         import C_INT32_T, C_INT64_T
         integer(kind=C_INT32_T) :: nint
         integer(kind=C_INT32_T) :: ncfgs
         integer(kind=C_INT64_T) :: cfglist(nint,2,ncfgs)
         end subroutine printcfglist
      end interface
      end module cfunctions
  #+end_src


- [X] C function

#+name: printCFGlist
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>
#include <stdint.h>

void printCFGList(int32_t *inpNint, int32_t *inpNcfgs, int64_t *cfglist){
    int Ncfgs    = *inpNcfgs;
    int N_int    = *inpNint;
    int digit[18];
    int64_t cfg1,cfg2;
    int nsomo=4;
    int ms=0;
    int ncsfs=0;
    printf("In 64 printcfglist\n");
    printf("Ncfgs = %d Nint=%d\n",Ncfgs, N_int);
    printf(" 1-- %d \n -- %d \n",cfglist[0*(2*Ncfgs) + 0*(Ncfgs) + 0], cfglist[0*(2*Ncfgs) + 1*(Ncfgs) + 0]);
    for(int i = 0; i < 15; i++){
        cfg1 = cfglist[1 + i*2];
        printf("%d> domo=%d somo=%d\n",i,cfg1,cfg2);
        int_to_bin_digit(cfg1,18,digit);
        for(int j=0;j<18;j++)
            printf("%d ",digit[j]);
        printf("\n");
    }
    getncsfs(&nsomo,&ms,&ncsfs);
    printf("Nsomos = %d\n",ncsfs);
}
#+end_src

** Generate BFs for a given number of SOMOs

A BF is represented as an integer. The bit representation of the integer (0 or 1) indicates the pairs. The BFs can be generated using the following rules:

1. A pair is represented by (0 1) with 0 indicating the left most index.

2. The right most 0 is linked with the left most 1.

This code generates all the bonded functions for a given number of SOMOs.

**** TODO [3/3] Algorithm

Here we describe how we generate the Bonded functions as shown in the example below.

#+begin_example
SOMO: [ 1 1 1 1 1] Ms = 1
BF list:
[[0 0 0 1 1]
 [0 0 1 0 1]
 [0 1 0 0 1]
 [0 0 1 1 0]
 [0 1 0 1 0]]
#+end_example

Basically, we use a binary tree to generate all the valid BFs.



- [X] Tree node data structure

The tree is built of a simple node which contains two links each for the two children \(C0, C1\) belonging to either a parallel \(0\)
or an anti-parallel \(1\) coupling. The address ~addr~ of all intermediate nodes is -1 and the address of the leaf node is the id of the BF
associated with the path traversed upon going back from the leaf to the root node using ~PREV~ pointer.

#+name: nodedef
#+begin_src c :main no :tangle tree_utils.h
typedef struct bin_node Node;
typedef struct bin_tree Tree;
struct bin_node {
    Node *C0;
    Node *C1;
    Node *PREV;
    int addr;
    int cpl;
    int iSOMO;
};

struct bin_tree {
    Node rootNode;
    int NBF;
};
#+end_src

- [X] Build Tree

  The algorithm for building the tree is very simple, the tree is constructed using two rules:

  1. The total number of 0's cannot be larger than ~zeromax~
  2. The total number of 1's cannot be smaller than ~onemin~

#+name: treefuncdefs
#+begin_src c :main no :tangle tree_utils.h
void buildTreeDriver(Tree *bftree, int NSOMO, int MS, int *NBF);

void buildTree(Tree *bftree, Node *inode, int isomo, int izeros, int icpl, int NSOMOMax, int MSmax);

void printTreeDriver(Tree *bftree, int NSOMOMax);
void printTree(Node *bftree, int isomo, int NSOMOMax, int *vecBF);

void getIthBF(Node *node, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF);
void getIthBFDriver(Tree *bftree, int NSOMOMax, int getaddr, int *vecBF);

void getBFIndexList(int NSOMO, int *BF1, int *IdxListBF1);
void getIslands(int NSOMO, int *BF1, int *BF2, int *nislands);
#+end_src

#+name: treefuncmain
#+begin_src c :main no :tangle tree_utils.c
void buildTree(Tree *bftree,
               Node *inode,
               int isomo,
               int izeros,
               int icpl,
               int NSOMOMax,
               int MSmax){

    // Find the maximum parallel couplings 0
    //      the maximum anti-parallel couplings 1
    int zeromax = MSmax + (NSOMOMax-MSmax)/2;
    int onemax = NSOMOMax - zeromax;

    // Exit condition
    if(isomo > NSOMOMax || icpl < 0 || izeros > zeromax ) return;

    // If we find a valid BF assign its address
    if(isomo == NSOMOMax){
        inode->addr = bftree->rootNode.addr;
        bftree->rootNode.addr += 1;
        return;
    }

    // Call 0 branch
    if((inode->C0) == -1 && izeros+1 <= zeromax){
        (inode->C0) = malloc(sizeof(Node));
        ,*(inode->C0) = (Node){ .C0 = -1, .C1 = -1, .PREV = inode, .addr = -1, .cpl = 0, .iSOMO = isomo };
        buildTree(bftree, inode->C0, isomo+1, izeros+1, icpl+1, NSOMOMax, MSmax);
    }
    else buildTree(bftree, inode->C0, isomo+1, izeros+1, icpl+1, NSOMOMax, MSmax);

    // Call 1 branch
    if((inode->C1) == -1 && icpl-1 >= 0){
        (inode->C1) = malloc(sizeof(Node));
        ,*(inode->C1) = (Node){ .C0 = -1, .C1 = -1, .PREV = inode, .addr = -1, .cpl = 1, .iSOMO = isomo };
        buildTree(bftree, inode->C1, isomo+1, izeros+0, icpl-1, NSOMOMax, MSmax);
    }
    else buildTree(bftree, inode->C1, isomo+1, izeros+0, icpl-1, NSOMOMax, MSmax);

    return;
}

void buildTreeDriver(Tree *bftree, int NSOMO, int MS, int *NBF){
    int isomo = 0; // counts the total number of SOMO's
    int izeros= 0; // Counts the total number of parallel coupings (i.e. 0's)
    int icpl  = 0; // keep track of the ith ms (cannot be -ve)
    int addr  = 0; // Counts the total BF's

    buildTree(bftree, &(bftree->rootNode), isomo, izeros, icpl, NSOMO, MS);

    ,*NBF = bftree->rootNode.addr;
}

void printTree(Node *node, int isomo, int NSOMOMax, int *vecBF){
    // Exit condition
    if(isomo > NSOMOMax) return;
    if(node == -1) return;

    if(isomo == NSOMOMax){
        printf("add : %d > ",node->addr);
        for(int i=0;i<NSOMOMax;i++)
            printf("%d ",vecBF[i]);
        printf("\n");
        return;
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(node),node->C1);


    // Recurse to C0
    if(node->C0 != -1){
        vecBF[isomo] = 0;
        printTree(node->C0, isomo+1, NSOMOMax, vecBF);
    }
    // Recurse to C1
    if(node->C1 != -1){
        vecBF[isomo] = 1;
        printTree(node->C1, isomo+1, NSOMOMax, vecBF);
    }

    return;
}

void printTreeDriver(Tree *bftree, int NSOMOMax){
    int isomo = 0;
    int vecBF[NSOMOMax];
    for(int i=0;i<NSOMOMax;i++)
        vecBF[i]=0;
    printTree(&(bftree->rootNode), isomo, NSOMOMax, vecBF);
}

void getIthBF(Node *inode, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF){
    // Exit condition
    if(foundBF) return;
    if(isomo > NSOMOMax) return;
    if(inode == -1) return;

    if(isomo == NSOMOMax){
        if(inode->addr == getaddr){
            for(int i = NSOMOMax-1; i > -1; i--){
                vecBF[i] = inode->cpl;
                inode = inode->PREV;
            }
            foundBF = true;
            return;
        }
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(inode),inode->C1);


    // Recurse to C0
    if(inode->C0 != -1){
        getIthBF(inode->C0, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }
    // Recurse to C1
    if(inode->C1 != -1){
        getIthBF(inode->C1, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }

    return;
}

void getIthBFDriver(Tree *bftree, int NSOMOMax, int getaddr, int *vecBF){
    int isomo = 0;
    bool foundBF = false;
    getIthBF(&(bftree->rootNode), isomo, foundBF, NSOMOMax, getaddr, vecBF);
}
#+end_src

- [X] Test Build BF

#+begin_src C :main no :noweb yes :tangle main.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

<<nodedef>>

<<treefuncdefs>>

<<treefuncmain>>

<<indexlist>>

<<calculateislands>>

void main(){
    int NSOMO = 8;
    int MS = 0;
    int NBF=0;
    Tree bftree = (Tree){  .rootNode = -1, .NBF = -1 };
    bftree.rootNode = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    buildTreeDriver(&bftree, NSOMO, MS, &NBF);

    //printTreeDriver(&bftree, NSOMO);

    int *BF1 = malloc(NSOMO * sizeof(int));
    int *BF2 = malloc(NSOMO * sizeof(int));

    int getaddr = 1;
    getIthBFDriver(&bftree, NSOMO, getaddr, BF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",BF1[i]);
    printf("\n");

    getaddr = 9;
    getIthBFDriver(&bftree, NSOMO, getaddr, BF2);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",BF2[i]);
    printf("\n");

    int *IdxListBF1 = malloc(NSOMO * sizeof(int));
    getBFIndexList(NSOMO, BF1, IdxListBF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",IdxListBF1[i]);
    printf("\n");

    getBFIndexList(NSOMO, BF2, IdxListBF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",IdxListBF1[i]);
    printf("\n");

    int nislands;

    getIslands(NSOMO, BF1, BF2, &nislands);
    printf("nislands = %d\n",nislands);


    // Garbage collection
    free(BF1);
    free(BF2);
    free(IdxListBF1);

    return;
}
#+end_src

#+RESULTS:
| add      | : | 1 | > | 0 | 0 | 0 | 1 | 0 | 1 | 1 | 1 |
| add      | : | 9 | > | 0 | 1 | 0 | 0 | 0 | 1 | 1 | 1 |
| add      | : | 9 | > | 7 | 6 | 3 | 2 | 5 | 4 | 1 | 0 |
| add      | : | 9 | > | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 |
| nislands | = | 2 |   |   |   |   |   |   |   |   |   |


** Calculate the orthogonalization matrix

The orthogonalization matrix gives the orthonormalized vectors
in bonded-function (BF) (or determinant) basis which are eigenfunctions
of \( S^2 \) c.f. \( \mathbf{O}_{i}\) matrices.

*** Calculate Overlap between two BFs

In our representation, the BFs are represented as a seqence of \(0,1\)
as shown below:

#+begin_example
BF1 : [0 0 0 1 1] Ms = 1
      (1 (1 (2 3) 4)
#+end_example

The second representation is only used to derive the overlap/matrix-elements.

The overlap between two bonded functions is based on the derivations
by Cooper and McWeeney[?] and Sutcliffe[?]. They are based on Rumer
diagrams. Here, we shall briefly outline the algorithm for the
calculation of the overlap between two BFs.

In order to calculate the Overlap (\( S \)) between two bonded functions
\( V_r \) and \(V_s\), there are two steps which are as follows:

1. Permutations of the strings to bring \(V_r, V_s\) into maximum overlap
   configuration. This incurs a phase (\(-1\) for each permutation) \((-1)^r\).

2. The calculation of the number of Islands (\(i\)), the number of Open chains (\(O\)),
   and the number of E chains.

The description of the three types of diagrams is described below:

**** TODO [2/2] Islands

Once the two BFs are brought into maximum overlap, the number of islands can be
calculated. An island is defined as the total number of closed polygons formed
by joining the common indices in \(V_r\) and \(V_s\). The pairs in each BF
\(V_r\) and \(V_s\) are also joind by an arc. Each island has two primitive
spin-functions. A primitive spin-function is defined as a product of
\(\alpha-\beta\) pair in the two BFs. The two primitives originate from
assigning \(\alpha\) or \(\beta\) to the head and tail of the closed polygon or
vice-versa.

#+begin_example
      ------------------------------------
      |    --------------------------    |
      |    |    ----------------    |    |
      |    |    |    ------    |    |    |
      |    |    |    |   \ /  \ /  \ /  \ /
BF1 : 0    0    0    0    1    1    1    1
      |    |    |    |    |    |    |    |
BF2 : 0    1    0    0    0    1    1    1
      |   / \   |    |    |   / \  / \  / \
      ------    |    |    ------    |    |
                |    ----------------    |
                --------------------------
#+end_example

- [X] Get Index list

#+name: indexlist
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>

void getBFIndexList(int NSOMO, int *BF1, int *IdxListBF1){
    int Iidx;
    int Jidx;
    int BFcopy[NSOMO];

    int dictidx[2];
    dictidx[0] = -1;
    dictidx[1] =  1;

    for(int i = 0; i < NSOMO; i++)
        BFcopy[i] = BF1[i];

    for(int i = 0; i < NSOMO; i++){
        Iidx = i;
        if(BFcopy[i] == 0){
            int countN1=0;
            for(int j = i+1; j < NSOMO; j++){
                Jidx = j;
                countN1 = countN1 + dictidx[BFcopy[j]];
                if(countN1 > 0){
                    break;
                }
            }
            BFcopy[Iidx] = -1;
            BFcopy[Jidx] = -1;
            IdxListBF1[Jidx] = Iidx;
            IdxListBF1[Iidx] = Jidx;
        }
    }

}
#+end_src

- [X] Get Islands


#+name: calculateIslands
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>

void getIslands(int NSOMO, int *BF1, int *BF2, int *nislands){

    // Get BF ids
    int *IdxListBF1 = malloc(NSOMO * sizeof(int));
    int *IdxListBF2 = malloc(NSOMO * sizeof(int));

    getBFIndexList(NSOMO, BF1, IdxListBF1);
    getBFIndexList(NSOMO, BF2, IdxListBF2);

    int maxcount=0;
    ,*nislands = 0;

    int BF1copy[NSOMO];
    for(int i = 0; i < NSOMO; i++)
        BF1copy[i] = IdxListBF1[i];
    int BF2copy[NSOMO];
    for(int i = 0; i < NSOMO; i++)
        BF2copy[i] = IdxListBF2[i];

    for(int i = 0; i < NSOMO; i++){
        int thisId = i;
        int nextId = BF1copy[i];
        maxcount = 0;
        while(BF1copy[thisId] != -1 && maxcount < 20){
            if(maxcount==0) *nislands += 1;

            maxcount++;

            // First the bra
            nextId = BF1copy[thisId];
            BF1copy[thisId] = -1;
            BF1copy[nextId] = -1;
            //printf("\n(%d) %d> %d -> %d\n",i,maxcount,thisId,nextId);

            // Then the ket
            thisId = BF2copy[nextId];
            BF2copy[thisId] = -1;
            BF2copy[nextId] = -1;
            //printf("\n(%d) %d> %d -> %d\n",i,maxcount,nextId,thisId);
        }
        //printf("\nBF1\n");
        //for(int j = 0; j < NSOMO; j++)
        //    printf("%d ",BF1copy[j]);
        //printf("\nBF2\n");
        //for(int j = 0; j < NSOMO; j++)
        //    printf("%d ",BF2copy[j]);
    }

}
#+end_src


**** Phase factor (r)

The phase factor is calculated according to the following rule. The connecting
lines shown in example above has a direction. Upon careful observation, one can
observe that out of the eight SOMOs 6 are aligned i.e. both bra and ket have arrows
or tails and 2 are misaligned. The phase \(r\) is defined as the minimum number of
flips required to pair all indices for the bra and ket indices. In the above example
three arrow directions have to be flipped giving \(r=3\) as shown below:

#+begin_example
      ------------------------------------
      |    --------------------------    |
      |    |    ----------------    |    |
      |    |    |    ------    |    |    |
      |   \ /   |   \ /   |   \ /   |   \ /
BF1 : 0    0    0    0    1    1    1    1
      |    |    |    |    |    |    |    |
BF2 : 0    1    0    0    0    1    1    1
      |   / \   |   / \   |   / \   |   / \
      ------    |    |    ------    |    |
                |    ----------------    |
                --------------------------
#+end_example

**** Open chains (O)

The open chains are constituted of open polygons which have an odd number of
sides. These are made up of BFs which consist of un-paired spins such as
\(2^{-1/2} \left[ \alpha(i)\beta(j) + \alpha(j)\beta(i) \right]\alpha(k) \) for
\(V_r\) and \(\alpha(i)-2^{-1/2} \left[ \alpha(j)\beta(k) + \alpha(k)\beta(j)
\right]\) for \(V_s\) respectively. These contribute a factor of \(1\) to the
MEs.

**** E type chains

The E type chains originate from BFs which contain different indices which are
mutually exclusive. The presence of mutually exclusive indices results in a
vanishing ME between such BFs.


Finally, the BFs contribute to the ME as follows:

\(
\braket{V_r | V_s} = \delta_{SS'}\delta_{E} 2^{i-s}(-1)^r
\)

Where \( S \) and \( S' \) are the spins for the \(V_r\) and \(V_s\)
respectively and \(s\) represents the total number of pairs in \(V_r\) and
\(V_s\). The total number of pairs are the same in \(V_r\) and \(V_s\) if they
belong to the same spin subspace.


#+name: getOrthoMatrix
#+begin_src c
void getOrthoMatrix(int *cfg, Matrix &orthoMat);
#+end_src

** Make the prototype matrices

jThe prototype matrices give the matrix-elements (MEs) for a given type
of excitation \(p->q\) of a specific type between two CFGs \(I,J\).

These matrices are independent of the MOs and only depend on the total number of
electrons \(nel\), total number of orbitals \(norb\), and the total spin \(S\).

#+name: makePrototypeMatrices
#+begin_src c
void makePrototypeMatrices(int nel, int norb, double spin);
#+end_src

** Functions required for calculating MEs


** Calculate the Operator MEs

The operator matrix-elements are calculated using the bonded-function (or
determinant) basis and are called \( A^{pq}_{IK} \), where \(p,q\) are the two
molecular orbital indices and \(I,K\) are the two CFGs.

Note that this function simply returns the value from a prototype lookup table
which contains the pretabulated values for a given \(p,q\) excitation of a
specified type which is one of the four:

1. SOMO \(->\) VMO
2. SOMO \(->\) SOMO
3. DOMO \(->\) VMO
4. DOMO \(->\) SOMO


#+name: getOneElOperatorMatrix
#+begin_src c
void getOneElOperatorMatrix(int *cfgI, int *cfgK);
#+end_src

** Sigma-Vector I

The one-electron part \( \sum_{pq} \tilde{h}_{pq} <\Psi|\hat{E}_{pq}|\Psi>\).

** Sigma-Vector II

The two-electron part \(\frac{1}{2} \sum_{pq,rs} g(pq,rs) <\Psi|\hat{E}_{pq}\hat{E}_{rs}|\Psi> \)

*** Function to calculate Sigma-Vector

#+name: calcSigmaFunction
#+begin_src c :results output
<<getOrthoMatrix>>
void calcSigma(double *coeff, double *Gpqrs);
#+end_src

* Bibliography

bibliography:biblio.org
