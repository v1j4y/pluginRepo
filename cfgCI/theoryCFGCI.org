# -*- mode:org -*-
#+TITLE: Theory CFGCI
#+AUTHOR: Vijay Gopal Chilkuri
#+EMAIL: vijay.gopal.c@gmail.com
#+OPTIONS: toc:t
#+LATEX_CLASS: article
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{braket}
#+LATEX_HEADER: \usepackage{minted}

* Introduction

There are three main aspects while using configuration based representation

* Algorithms

*** Small function to convert int to bit

Convert input CFG to an array of bits containing 0's and 1's representing
the position of SOMOs and DOMOs.


#+name: inttobindigit
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdint.h>
#include <stdio.h>
#include "tree_utils.h"

void int_to_bin_digit(int64_t in, int count, int* out)
{
    /* assert: count <= sizeof(int)*CHAR_BIT */
    unsigned int mask = 1U << (count-1);
    int i;
    for (i = 0; i < count; i++) {
        out[i] = (in & mask) ? 1 : 0;
        in <<= 1;
    }
}

void printRealMatrix(double *orthoMatrix, int rows, int cols){

    for(int i = 0; i < rows; i++){
        printf("\n");
        for(int j = 0; j < cols; j++){
            printf("%10.2f ",orthoMatrix[i*cols + j]);
        }
    }
    printf("\n");
}
#+end_src


*** Get number of CSFs

#+name: getncsfs
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>
#include <stdint.h>
#include <math.h>

double logbinom(double n, double k) {
    return lgamma(n+1)-lgamma(n-k+1)-lgamma(k+1);
}
double binom(double n, double k) {
    return exp(logbinom(n,k));
}

void getncsfs1(int *inpnsomo, int *inpms, int *outncsfs){
    int nsomo = *inpnsomo;
    int ms = *inpms;
    int nparcoupl = (nsomo + ms)/2;
    ,*outncsfs = binom(nsomo, nparcoupl);
}

void getncsfs(int NSOMO, int MS, int *outncsfs){
    int nparcoupl = (NSOMO + MS)/2;
    int nparcouplp1 = ((NSOMO + MS)/2)+1;
    double tmpndets=0.0;
    if(NSOMO == 0){
        (*outncsfs) = 1;
        return;
    }
    tmpndets = binom(NSOMO, nparcoupl);
    (*outncsfs) = round(tmpndets - binom(NSOMO, nparcouplp1));
}
#+end_src


** TODO [2/2] Print all CFGs

The only input required is the selected list of CFGs at a given CIPSI iteration \( I \).

- [X] Fortran module

  #+begin_src f90 :main no :tangle cfgCI_interface.f90
module cfunctions
        use, intrinsic :: ISO_C_BINDING
      interface
         subroutine printcfglist(nint, ncfgs, cfglist) bind(C, name='printCFGList')
           import C_INT32_T, C_INT64_T
         integer(kind=C_INT32_T) :: nint
         integer(kind=C_INT32_T) :: ncfgs
         integer(kind=C_INT64_T) :: cfglist(nint,2,ncfgs)
       end subroutine printcfglist
      end interface
      interface
         subroutine getApqIJMatrixDims(Isomo, Jsomo, MS, rowsout, colsout) &
              bind(C, name='getApqIJMatrixDims')
           import C_INT32_T, C_INT64_T
           integer(kind=C_INT64_T),value,intent(in) :: Isomo ! CSFI
           integer(kind=C_INT64_T),value,intent(in) :: Jsomo ! CSFJ
           integer(kind=C_INT64_T),value,intent(in) :: MS    ! Ms = 2*Spin
           integer(kind=C_INT32_T),intent(out):: rowsout
           integer(kind=C_INT32_T),intent(out):: colsout
         end subroutine getApqIJMatrixDims
      end interface
      interface
         subroutine getApqIJMatrixDriver(Isomo, Jsomo, orbp, orbq,  &
              MS, NMO, CSFICSFJApqIJ, rowsmax, colsmax) bind(C, name='getApqIJMatrixDriverArrayInp')
           import C_INT32_T, C_INT64_T, C_DOUBLE
           integer(kind=C_INT64_T),value,intent(in) :: Isomo
           integer(kind=C_INT64_T),value,intent(in) :: Jsomo
           integer(kind=C_INT32_T),value,intent(in) :: orbp
           integer(kind=C_INT32_T),value,intent(in) :: orbq
           integer(kind=C_INT64_T),value,intent(in) :: MS
           integer(kind=C_INT64_T),value,intent(in) :: NMO
           integer(kind=C_INT32_T),intent(in) :: rowsmax
           integer(kind=C_INT32_T),intent(in) :: colsmax
           real   (kind=C_DOUBLE ),intent(out) :: CSFICSFJApqIJ(rowsmax,colsmax)
           !integer(kind=C_INT32_T),dimension(rowApqIJ,colApqIJ) :: ApqIJ
         end subroutine getApqIJMatrixDriver
      end interface
       interface
         subroutine getCSFtoDETTransformationMatrix(Isomo,&
              MS, rowsmax, colsmax, csftodetmatrix) bind(C, name='convertCSFtoDetBasis')
           import C_INT32_T, C_INT64_T, C_DOUBLE
           integer(kind=C_INT64_T),value,intent(in) :: Isomo
           integer(kind=C_INT64_T),value,intent(in) :: MS
           integer(kind=C_INT32_T),intent(in) :: rowsmax
           integer(kind=C_INT32_T),intent(in) :: colsmax
           real   (kind=C_DOUBLE ),intent(out) :: csftodetmatrix(rowsmax,colsmax)
         end subroutine getCSFtoDETTransformationMatrix
      end interface
    end module cfunctions
  #+end_src


- [X] C function

#+name: printCFGlist
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>
#include <stdint.h>

void printCFGList(int32_t *inpNint, int32_t *inpNcfgs, int64_t *cfglist){
    int Ncfgs    = *inpNcfgs;
    int N_int    = *inpNint;
    int digit[MAX_SOMO];
    int64_t cfg1,cfg2;
    int nsomo=4;
    int ms=0;
    int ncsfs=0;
    printf("In 64 printcfglist\n");
    printf("Ncfgs = %d Nint=%d\n",Ncfgs, N_int);
    printf(" 1-- %ld \n -- %ld \n",cfglist[0*(2*Ncfgs) + 0*(Ncfgs) + 0], cfglist[0*(2*Ncfgs) + 1*(Ncfgs) + 0]);
    for(int i = 0; i < 15; i++){
        cfg1 = cfglist[1 + i*2];
        cfg2 = cfglist[0 + i*2];
        printf("%d> domo=%ld somo=%ld\n",i,cfg1,cfg2);
        int_to_bin_digit(cfg2,18,digit);
        for(int j=0;j<18;j++)
            printf("%d ",digit[j]);
        printf("\n");
    }
    getncsfs1(&nsomo,&ms,&ncsfs);
    printf("Nsomos = %d\n",ncsfs);
}
#+end_src

** Generate all singly excited CFGs

Generate all singly excited CFGs with respect to a given CFG.

#+name: genallSingly
#+begin_src fortran
#+end_src



** Generate BFs for a given number of SOMOs

A BF is represented as an integer. The bit representation of the integer (0 or 1) indicates the pairs. The BFs can be generated using the following rules:

1. A pair is represented by (0 1) with 0 indicating the left most index.

2. The right most 0 is linked with the left most 1.

This code generates all the bonded functions for a given number of SOMOs.

**** TODO [3/3] Algorithm

Here we describe how we generate the Bonded functions as shown in the example below.

#+begin_example
SOMO: [ 1 1 1 1 1] Ms = 1
BF list:
[[0 0 0 1 1]
 [0 0 1 0 1]
 [0 1 0 0 1]
 [0 0 1 1 0]
 [0 1 0 1 0]]
#+end_example

Basically, we use a binary tree to generate all the valid BFs.



- [X] Tree node data structure

The tree is built of a simple node which contains two links each for the two children \(C0, C1\) belonging to either a parallel \(0\)
or an anti-parallel \(1\) coupling. The address ~addr~ of all intermediate nodes is -1 and the address of the leaf node is the id of the BF
associated with the path traversed upon going back from the leaf to the root node using ~PREV~ pointer.

#+name: nodedef
#+begin_src c :main no :tangle tree_utils.h
#ifndef TREE_UTILS_H
#define TREE_UTILS_H
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <math.h>

typedef struct bin_node Node;
typedef struct bin_tree Tree;
struct bin_node {
    Node *C0;
    Node *C1;
    Node *PREV;
    int addr;
    int cpl;
    int iSOMO;
};

struct bin_tree {
    Node *rootNode;
    int NBF;
};
#+end_src

- [X] Build Tree

  The algorithm for building the tree is very simple, the tree is constructed using two rules:

  1. The total number of 0's cannot be larger than ~zeromax~
  2. The total number of 1's cannot be smaller than ~onemin~

#+name: treefuncdefs
#+begin_src c :main no :tangle tree_utils.h
#include "/usr/include/x86_64-linux-gnu/cblas.h"

#define MAX_SOMO 32

void buildTreeDriver(Tree *bftree, int NSOMO, int MS, int *NBF);

void buildTree(Tree *bftree, Node **inode, int isomo, int izeros, int icpl, int NSOMOMax, int MSmax);

void printTreeDriver(Tree *bftree, int NSOMOMax);
void printTree(Node *bftree, int isomo, int NSOMOMax, int *vecBF);

void getIthBF(Node *node, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF);
void getIthBFDriver(Tree *bftree, int NSOMOMax, int getaddr, int *vecBF);

void getBFIndexList(int NSOMO, int *BF1, int *IdxListBF1);
void getIslands(int NSOMO, int *BF1, int *BF2, int *nislands, int *phasefactor);

void generateAllBFs(int64_t Isomo, int64_t MS, Tree *bftree, int *NBF, int *NSOMO);
void getSetBits(int64_t n, int *nsetbits);
void getOverlapMatrix(int64_t Isomo, int64_t MS, double **overlapMatrixptr, int *rows, int *cols, int *NSOMOout);
void gramSchmidt(double *overlapMatrix, int rows, int cols, double *orthoMatrix);


void calculateMETypeSOMOSOMO(int *BF1, int *BF2, int moi, int moj, double *factor, int *phasefactor);
void getOneElMETypeSOMOSOMO(int64_t Isomo, int64_t Jsomos, int moi, int moj, int MS, double **oneElMatrixElementsptr, int *rows, int *cols);

/***********************

Determinant Tree utils
,***********************/


void genDets(Tree *dettree,
               Node **inode,
               int isomo,
               int izeros,
               int icpl,
               int NSOMOMax,
               int MSmax);
void genDetsDriver(Tree *dettree, int NSOMO, int MS, int *Ndets);

void getIthDet(Node *inode, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF);
void getIthDetDriver(Tree *dettree, int NSOMOMax, int getaddr, int *vecBF);
void getDetlistDriver(Tree *dettree, int NSOMOMax, int *detlist);
void findAddofDet(Node *inode, int isomo, bool foundDet, int NSOMOMax, int *inpdet, int *addr);
void findAddofDetDriver(Tree *dettree, int NSOMOMax, int *inpdet, int *addr);


/************************/

void genDetBasis(Tree *dettree, int Isomo, int MS, int *ndets);
void getbftodetfunction(Tree *dettree, int NSOMO, int MS, int *BF1, double *rowvec);
void convertBFtoDetBasis(int64_t Isomo, int MS, double **bftodetmatrixptr, int *rows, int *cols);

// Misc utils
void int_to_bin_digit(int64_t in, int count, int* out);
void printRealMatrix(double *orthoMatrix, int rows, int cols);
void callBlasMatxMat(double *A, int rowA, int colA, double *B, int rowB, int colB, double *C, bool transA, bool transB);

#endif
#+end_src

#+name: treefuncmain
#+begin_src c :main no :tangle tree_utils.c
#include "tree_utils.h"

void buildTree(Tree *bftree,
               Node **inode,
               int isomo,
               int izeros,
               int icpl,
               int NSOMOMax,
               int MSmax){

    // Find the maximum parallel couplings 0
    //      the maximum anti-parallel couplings 1
    int zeromax = MSmax + (NSOMOMax-MSmax)/2;
    int onemax = NSOMOMax - zeromax;

    // Exit condition
    if(isomo > NSOMOMax || icpl < 0 || izeros > zeromax ) return;

    // If we find a valid BF assign its address
    if(isomo == NSOMOMax){
        (*inode)->addr = bftree->rootNode->addr;
        bftree->rootNode->addr += 1;
        return;
    }

    // Call 0 branch
    if(((*inode)->C0) == NULL && izeros+1 <= zeromax){
        ((*inode)->C0) = malloc(sizeof(Node));
        (*(*inode)->C0) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = *inode, .addr = -1, .cpl = 0, .iSOMO = isomo };
        buildTree(bftree, &(*inode)->C0, isomo+1, izeros+1, icpl+1, NSOMOMax, MSmax);
    }
    else buildTree(bftree, &(*inode)->C0, isomo+1, izeros+1, icpl+1, NSOMOMax, MSmax);

    // Call 1 branch
    if(((*inode)->C1) == NULL && icpl-1 >= 0){
        ((*inode)->C1) = malloc(sizeof(Node));
        (*(*inode)->C1) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = *inode, .addr = -1, .cpl = 1, .iSOMO = isomo };
        buildTree(bftree, &(*inode)->C1, isomo+1, izeros+0, icpl-1, NSOMOMax, MSmax);
    }
    else buildTree(bftree, &(*inode)->C1, isomo+1, izeros+0, icpl-1, NSOMOMax, MSmax);

    return;
}

void buildTreeDriver(Tree *bftree, int NSOMO, int MS, int *NBF){
    int isomo = 0; // counts the total number of SOMO's
    int izeros= 0; // Counts the total number of parallel coupings (i.e. 0's)
    int icpl  = 0; // keep track of the ith ms (cannot be -ve)
    int addr  = 0; // Counts the total BF's

    buildTree(bftree, &(bftree->rootNode), isomo, izeros, icpl, NSOMO, MS);

    ,*NBF = bftree->rootNode->addr;
}

void printTree(Node *inode, int isomo, int NSOMOMax, int *vecBF){
    // Exit condition
    if(isomo > NSOMOMax) return;
    if(inode == NULL) return;

    if(isomo == NSOMOMax){
        printf("add : %d > ",inode->addr);
        for(int i=0;i<NSOMOMax;i++)
            printf("%d ",vecBF[i]);
        printf("\n");
        return;
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(inode),inode->C1);


    // Recurse to C0
    if(inode->C0 != NULL){
        vecBF[isomo] = 0;
        printTree(inode->C0, isomo+1, NSOMOMax, vecBF);
    }
    // Recurse to C1
    if(inode->C1 != NULL){
        vecBF[isomo] = 1;
        printTree(inode->C1, isomo+1, NSOMOMax, vecBF);
    }

    return;
}

void printTreeDriver(Tree *bftree, int NSOMOMax){
    int isomo = 0;
    int vecBF[NSOMOMax];
    for(int i=0;i<NSOMOMax;i++)
        vecBF[i]=0;
    printTree((bftree->rootNode), isomo, NSOMOMax, vecBF);
}

void getIthBF(Node *inode, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF){
    // Exit condition
    if(foundBF) return;
    if(isomo > NSOMOMax) return;
    if(inode == NULL) return;

    if(isomo == NSOMOMax){
        if(inode->addr == getaddr){
            for(int i = NSOMOMax-1; i > -1; i--){
                vecBF[i] = inode->cpl;
                inode = inode->PREV;
            }
            foundBF = true;
            return;
        }
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(inode),inode->C1);


    // Recurse to C0
    if(inode->C0 != NULL){
        getIthBF(inode->C0, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }
    // Recurse to C1
    if(inode->C1 != NULL){
        getIthBF(inode->C1, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }

    return;
}

void getIthBFDriver(Tree *bftree, int NSOMOMax, int getaddr, int *vecBF){
    int isomo = 0;
    bool foundBF = false;
    getIthBF((bftree->rootNode), isomo, foundBF, NSOMOMax, getaddr, vecBF);
}
#+end_src

- [X] Test Build BF

#+begin_src C :main no :noweb yes
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "tree_utils.h"

<<treefuncmain>>

<<indexlist>>

<<calculateislands>>

void main(){
    int NSOMO = 6;
    int MS = 0;
    int NBF=0;
    Tree bftree = (Tree){  .rootNode = NULL, .NBF = -1 };
    bftree.rootNode = malloc(sizeof(Node));
    (*bftree.rootNode) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = NULL, .addr = 0, .cpl = -1, .iSOMO = -1};

    buildTreeDriver(&bftree, NSOMO, MS, &NBF);

    //printTreeDriver(&bftree, NSOMO);

    int *BF1 = malloc(NSOMO * sizeof(int));
    int *BF2 = malloc(NSOMO * sizeof(int));

    int getaddr = 0;
    getIthBFDriver(&bftree, NSOMO, getaddr, BF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",BF1[i]);
    printf("\n");

    getaddr = 1;
    getIthBFDriver(&bftree, NSOMO, getaddr, BF2);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",BF2[i]);
    printf("\n");

    int *IdxListBF1 = malloc(NSOMO * sizeof(int));
    getBFIndexList(NSOMO, BF1, IdxListBF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",IdxListBF1[i]);
    printf("\n");

    getBFIndexList(NSOMO, BF2, IdxListBF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",IdxListBF1[i]);
    printf("\n");

    int nislands;
    int phasefactor;

    getIslands(NSOMO, BF1, BF2, &nislands, &phasefactor);
    printf("nislands = %d phase = %d\n",nislands,phasefactor);


    // Garbage collection
    free(BF1);
    free(BF2);
    free(IdxListBF1);

    return;
}
#+end_src

#+RESULTS:
| add      | : | 0 | >     | 0 | 0 | 0 | 1 | 1 | 1 |
| add      | : | 1 | >     | 0 | 0 | 1 | 0 | 1 | 1 |
| add      | : | 1 | >     | 5 | 4 | 3 | 2 | 1 | 0 |
| add      | : | 1 | >     | 5 | 2 | 1 | 4 | 3 | 0 |
| nislands | = | 2 | phase | = | 1 |   |   |   |   |


** Calculate the orthogonalization matrix

The orthogonalization matrix gives the orthonormalized vectors
in bonded-function (BF) (or determinant) basis which are eigenfunctions
of \( S^2 \) c.f. \( \mathbf{O}_{i}\) matrices.

*** Calculate Overlap between two BFs

In our representation, the BFs are represented as a seqence of \(0,1\)
as shown below:

#+begin_example
BF1 : [0 0 0 1 1] Ms = 1
      (1 (1 (2 3) 4)
#+end_example

The second representation is only used to derive the overlap/matrix-elements.

The overlap between two bonded functions is based on the derivations
by Cooper and McWeeney[?] and Sutcliffe[?]. They are based on Rumer
diagrams. Here, we shall briefly outline the algorithm for the
calculation of the overlap between two BFs.

In order to calculate the Overlap (\( S \)) between two bonded functions
\( V_r \) and \(V_s\), there are two steps which are as follows:

1. Permutations of the strings to bring \(V_r, V_s\) into maximum overlap
   configuration. This incurs a phase (\(-1\) for each permutation) \((-1)^r\).

2. The calculation of the number of Islands (\(i\)), the number of Open chains (\(O\)),
   and the number of E chains.

The description of the three types of diagrams is described below:

**** TODO [2/2] Islands

Once the two BFs are brought into maximum overlap, the number of islands can be
calculated. An island is defined as the total number of closed polygons formed
by joining the common indices in \(V_r\) and \(V_s\). The pairs in each BF
\(V_r\) and \(V_s\) are also joind by an arc. Each island has two primitive
spin-functions. A primitive spin-function is defined as a product of
\(\alpha-\beta\) pair in the two BFs. The two primitives originate from
assigning \(\alpha\) or \(\beta\) to the head and tail of the closed polygon or
vice-versa.

#+begin_example
      ------------------------------------
      |    --------------------------    |
      |    |    ----------------    |    |
      |    |    |    ------    |    |    |
      |    |    |    |   \ /  \ /  \ /  \ /
BF1 : 0    0    0    0    1    1    1    1
      |    |    |    |    |    |    |    |
BF2 : 0    1    0    0    0    1    1    1
      |   / \   |    |    |   / \  / \  / \
      ------    |    |    ------    |    |
                |    ----------------    |
                --------------------------
#+end_example

- [X] Get Index list

#+name: indexlist
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>

void getBFIndexList(int NSOMO, int *BF1, int *IdxListBF1){
    int Iidx;
    int Jidx;
    int BFcopy[NSOMO];

    int dictidx[2];
    dictidx[0] = -1;
    dictidx[1] =  1;

    for(int i = 0; i < NSOMO; i++)
        BFcopy[i] = BF1[i];

    for(int i = 0; i < NSOMO; i++){
        Iidx = i;
        if(BFcopy[i] == 0){
            int countN1=0;
            for(int j = i+1; j < NSOMO; j++){
                Jidx = j;
                countN1 = countN1 + dictidx[BFcopy[j]];
                if(countN1 > 0){
                    break;
                }
            }
            BFcopy[Iidx] = -1;
            BFcopy[Jidx] = -1;
            IdxListBF1[Jidx] = Iidx;
            IdxListBF1[Iidx] = Jidx;
        }
    }

}
#+end_src

- [X] Get Islands


#+name: calculateIslands
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>

void getIslands(int NSOMO, int *BF1, int *BF2, int *nislands, int *phasefactor){

    // Get BF ids
    int *IdxListBF1 = malloc(NSOMO * sizeof(int));
    int *IdxListBF2 = malloc(NSOMO * sizeof(int));

    getBFIndexList(NSOMO, BF1, IdxListBF1);
    getBFIndexList(NSOMO, BF2, IdxListBF2);
    //printf("\nBF1\n");
    //for(int j = 0; j < NSOMO; j++)
    //    printf("%d ",IdxListBF1[j]);
    //printf("\nBF2\n");
    //for(int j = 0; j < NSOMO; j++)
    //    printf("%d ",IdxListBF2[j]);

    int sumids = 0;
    int maxcount=0;
    ,*nislands = 0;
    ,*phasefactor = 1;

    int BF1copy[NSOMO];
    for(int i = 0; i < NSOMO; i++)
        BF1copy[i] = IdxListBF1[i];
    int BF2copy[NSOMO];
    for(int i = 0; i < NSOMO; i++)
        BF2copy[i] = IdxListBF2[i];

    for(int i = 0; i < NSOMO; i++){
        int thisId = i;
        int nextId = BF1copy[i];
        maxcount = 0;
        while(BF1copy[thisId] != -1 && maxcount < 20){
            if(maxcount==0) *nislands += 1;
            if(maxcount==19) *nislands -= 1;

            maxcount++;

            // First the bra
            nextId = BF1copy[thisId];
            BF1copy[thisId] = -1;
            BF1copy[nextId] = -1;
            //printf("\n(%d) %d> %d -> %d\n",i,maxcount,thisId,nextId);

            // Get the phase factor bra
            if(nextId < thisId) *phasefactor *= -1;

            // Then the ket
            thisId = BF2copy[nextId];
            BF2copy[thisId] = -1;
            BF2copy[nextId] = -1;
            //printf("\n(%d) %d> %d -> %d\n",i,maxcount,nextId,thisId);

            // Get the phase factor bra
            if(nextId < thisId) *phasefactor *= -1;

        }
        //printf("\nsum=%d\nBF1\n",sumids);
        //for(int j = 0; j < NSOMO; j++)
        //    printf("%d ",BF1copy[j]);
        //printf("\nBF2\n");
        //for(int j = 0; j < NSOMO; j++)
        //    printf("%d ",BF2copy[j]);
        for(int j=0;j<NSOMO;j++)
            sumids += BF1copy[j];
        //printf("\nnislands=%d phase=%d sumids=%d\n",*nislands,*phasefactor,sumids);
        if(sumids == -1*NSOMO) break;
        sumids = 0;
    }

    // Garbage collection
    free(IdxListBF1);
    free(IdxListBF2);

}
#+end_src



**** Phase factor (r)

The phase factor is calculated according to the following rule. The connecting
lines shown in example above has a direction. Upon careful observation, one can
observe that out of the eight SOMOs 6 are aligned i.e. both bra and ket have arrows
or tails and 2 are misaligned. The phase \(r\) is defined as the minimum number of
flips required to pair all indices for the bra and ket indices. In the above example
three arrow directions have to be flipped giving \(r=3\) as shown below:

#+begin_example
      ------------------------------------
      |    --------------------------    |
      |    |    ----------------    |    |
      |    |    |    ------    |    |    |
      |   \ /   |   \ /   |   \ /   |   \ /
BF1 : 0    0    0    0    1    1    1    1
      |    |    |    |    |    |    |    |
BF2 : 0    1    0    0    0    1    1    1
      |   / \   |   / \   |   / \   |   / \
      ------    |    |    ------    |    |
                |    ----------------    |
                --------------------------
#+end_example

#+name: illustration islands
#+ATTR_ORG: :width 400
[[./illustration_islands.jpg]]

**** Open chains (O)

The open chains are constituted of open polygons which have an odd number of
sides. These are made up of BFs which consist of un-paired spins such as
\(2^{-1/2} \left[ \alpha(i)\beta(j) + \alpha(j)\beta(i) \right]\alpha(k) \) for
\(V_r\) and \(\alpha(i)-2^{-1/2} \left[ \alpha(j)\beta(k) + \alpha(k)\beta(j)
\right]\) for \(V_s\) respectively. These contribute a factor of \(1\) to the
MEs.

**** E type chains

The E type chains originate from BFs which contain different indices which are
mutually exclusive. The presence of mutually exclusive indices results in a
vanishing ME between such BFs.


Finally, the BFs contribute to the ME as follows:

#+name: EqCalcOvlp
\(
\braket{V_r | V_s} = \delta_{SS'}\delta_{E} 2^{i-s}(-1)^r
\)

Where \( S \) and \( S' \) are the spins for the \(V_r\) and \(V_s\)
respectively and \(s\) represents the total number of pairs in \(V_r\) and
\(V_s\). The total number of pairs are the same in \(V_r\) and \(V_s\) if they
belong to the same spin subspace.

**** TODO [4/8] Make the orthonormalization matrix

- [X] Calculate the number of SOMOs in the input CFG.

#+name:getNsomo
#+begin_src C :main no :tangle cfgCI_utils.c
void getSetBits(int64_t n, int *nsetbits){
    int count = 0;
    while(n){
        count += n & 1;
        n >>= 1;
    }
    *nsetbits = count;
}
#+end_src

- [ ] Generate all the BF for the SOMOs in the CFG

#+name: generateAllBFs
#+begin_src C :main no :tangle cfgCI_utils.c
void generateAllBFs(int64_t Isomo, int64_t MS, Tree *bftree, int *NBF, int *NSOMO){
    getSetBits(Isomo, NSOMO);
    buildTreeDriver(bftree, *NSOMO, MS, NBF);
}
#+end_src

- [ ] Fill the matrix using Eq:[[EqCalcOvlp]]


#+name: getOverlapMatrix
#+begin_src c :main no :tangle cfgCI_utils.c
void getOverlapMatrix(int64_t Isomo, int64_t MS, double **overlapMatrixptr, int *rows, int *cols, int *NSOMOout){

    int NBF = 0;
    int NSOMO = 0;

    Tree bftree = (Tree){  .rootNode = NULL, .NBF = -1 };
    bftree.rootNode = malloc(sizeof(Node));
    (*bftree.rootNode) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = NULL, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Isomo, MS, &bftree, &NBF, &NSOMO);

    *NSOMOout = NSOMO;

    //printTreeDriver(&bftree, NSOMO);

    // Initialize overlap matrix
    (*overlapMatrixptr) = malloc(NBF*NBF*sizeof(double));
    (*rows) = NBF;
    (*cols) = NBF;

    double *overlapMatrix = (*overlapMatrixptr);

    //// initialize Matrix
    //for(int i = 0; i < NBF; i++)
    //    for(int j = 0; j < NBF; j++)
    //        overlapMatrix[i*NBF + j] = 0.0;

    int addI = 0;
    int addJ = 0;
    int *BF1 = malloc(MAX_SOMO * sizeof(int));
    int *BF2 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF1 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF2 = malloc(MAX_SOMO * sizeof(int));

    int g = 0;
    g = (NSOMO - MS)/2;
    //printf("NBFs = %d NSOMOs = %d MS = %ld g = %d\n",NBF,NSOMO,MS,g);

    int nislands; // Note that nislands < g always
    int phasefactor;

    int dictPhase[2];

    dictPhase[0] = 1;
    dictPhase[1] =-1;


    // Set block elements
    for(int i = 0; i < NBF; i++){
        addI = i;
        getIthBFDriver(&bftree, NSOMO, addI, BF1);
        getBFIndexList(NSOMO, BF1, IdxListBF1);

        //printf("addI : %d > ",addI);
        //for(int k=0;k<NSOMO;k++)
        //    printf("%d ",BF1[k]);
        //printf("\n");

        for(int j = 0; j < NBF; j++){
            addJ = j;
            getIthBFDriver(&bftree, NSOMO, addJ, BF2);
            getBFIndexList(NSOMO, BF2, IdxListBF2);
            //printf("addJ : %d > ",addI);
            //for(int k=0;k<NSOMO;k++)
            //    printf("%d ",BF2[k]);
            //printf("\n");

            // Get the i and r factors
            getIslands(NSOMO, BF1, BF2, &nislands, &phasefactor);

            //printf("(%d, %d) is=%d ph=%d fac=%10.15f\n",addI, addJ, nislands, phasefactor, phasefactor*1.0/(1 << (g-nislands)));

            overlapMatrix[i*NBF + j] = 1.0*phasefactor / (1 << (g - nislands));
        }
    }

    // Garbage collection
    free(BF1);
    free(IdxListBF1);
    free(BF2);
    free(IdxListBF2);

}
#+end_src

- [X] Generate orthonormalization matrix

  A Gram-Schmidt orthogonalization will generate the CSFs from the BFs.

#+name: gramSchmidt
#+begin_src C :main no :noweb yes :tangle cfgCI_utils.c
void gramSchmidt(double *overlapMatrix, int rows, int cols, double *orthoMatrix){

    // vector
    double norm = 0.0;
    orthoMatrix[(rows-1)*cols + cols-1] = 1.0;
    for(int i = cols-2; i > -1; i--){ orthoMatrix[(rows-1)*cols + i] = 0.0; }

    // Gram-Schmidt loop
    for(int i = rows-2; i > -1; i--){
        for(int k = cols-1; k > -1; k--){ orthoMatrix[(i)*cols + k] = 0.0; }
        orthoMatrix[i*cols + i] = 1.0;

        // orthogonalization
        for(int j = rows-1; j > i; j--){
            for(int k = rows-1; k >= j; k--){
                orthoMatrix[i*cols + k] += -1.0*orthoMatrix[j*cols + k]*overlapMatrix[i*cols + k];
            }
        }

        //for(int k=rows-1;k>=i;k--){
        //    printf("%4.5f ",orthoMatrix[i*cols + k]);
        //}
        //printf("\n");

        // Normalization
        norm = 0.0;
        for(int j = rows-1; j >= i; j--){
            for(int k=rows-1; k >= i; k--)
                norm += orthoMatrix[i*cols + j]*orthoMatrix[i*cols + k]*overlapMatrix[j*cols+k];
        }
        norm = sqrt(norm);
        //printf("norm=%4.5f\n",norm);
        for(int j = rows-1; j >= i; j--){
            orthoMatrix[i*cols + j] /= norm;
        }
        //for(int k=rows-1;k>=i;k--){
        //    printf("%4.5f ",orthoMatrix[i*cols + k]);
        //}
        //printf("\n");

    }

}
#+end_src

- [X] Generate det basis

  Generate the determinant representation of the BFs.

#+name: genDetBasis
#+begin_src C :main no :tangle tree_utils.c

void genDets(Tree *dettree,
               Node **inode,
               int isomo,
               int izeros,
               int icpl,
               int NSOMOMax,
               int MSmax){

    // Find the maximum parallel couplings 0
    //      the maximum anti-parallel couplings 1
    int zeromax = MSmax + (NSOMOMax-MSmax)/2;
    int onemax = NSOMOMax - zeromax;

    // Exit condition
    if(isomo > NSOMOMax || izeros > zeromax || abs(icpl) > onemax) return;

    // If we find a valid BF assign its address
    if(isomo == NSOMOMax){
        (*inode)->addr = dettree->rootNode->addr;
        dettree->rootNode->addr += 1;
        return;
    }

    // Call 0 branch
    if(((*inode)->C0) == NULL && izeros+1 <= zeromax){
        ((*inode)->C0) = malloc(sizeof(Node));
        (*(*inode)->C0) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = *inode, .addr = -1, .cpl = 0, .iSOMO = isomo };
        genDets(dettree, &(*inode)->C0, isomo+1, izeros+1, icpl+0, NSOMOMax, MSmax);
    }
    else genDets(dettree, &(*inode)->C0, isomo+1, izeros+1, icpl+0, NSOMOMax, MSmax);

    // Call 1 branch
    if(((*inode)->C1) == NULL && abs(icpl+1) <= onemax){
        ((*inode)->C1) = malloc(sizeof(Node));
        (*(*inode)->C1) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = *inode, .addr = -1, .cpl = 1, .iSOMO = isomo };
        genDets(dettree, &(*inode)->C1, isomo+1, izeros+0, icpl+1, NSOMOMax, MSmax);
    }
    else genDets(dettree, &(*inode)->C1, isomo+1, izeros+0, icpl+1, NSOMOMax, MSmax);

    return;
}

void genDetsDriver(Tree *dettree, int NSOMO, int MS, int *Ndets){
    int isomo = 0; // counts the total number of SOMO's
    int izeros= 0; // Counts the total number of parallel coupings (i.e. 0's)
    int icpl  = 0; // keep track of the ith ms (cannot be -ve)
    int addr  = 0; // Counts the total BF's

    genDets(dettree, &(dettree->rootNode), isomo, izeros, icpl, NSOMO, MS);

    ,*Ndets = dettree->rootNode->addr;
}

void getIthDet(Node *inode, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF){
    // Exit condition
    if(foundBF) return;
    if(isomo > NSOMOMax) return;
    if(inode == NULL) return;

    if(isomo == NSOMOMax){
        if(inode->addr == getaddr){
            for(int i = NSOMOMax-1; i > -1; i--){
                vecBF[i] = inode->cpl;
                inode = inode->PREV;
            }
            foundBF = true;
            return;
        }
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(inode),inode->C1);


    // Recurse to C0
    if(inode->C0 != NULL){
        getIthDet(inode->C0, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }
    // Recurse to C1
    if(inode->C1 != NULL){
        getIthDet(inode->C1, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }

    return;
}

void getIthDetDriver(Tree *dettree, int NSOMOMax, int getaddr, int *vecBF){
    int isomo = 0;
    bool foundBF = false;
    getIthDet((dettree->rootNode), isomo, foundBF, NSOMOMax, getaddr, vecBF);
}

void findAddofDet(Node *inode, int isomo, bool foundDet, int NSOMOMax, int *inpdet, int *addr){
    // Exit condition
    if(foundDet) return;
    if(isomo == NSOMOMax){
        foundDet = true;
        ,*addr = inode->addr;
        return;
    }
    //printf("%d | %d (%d)\n",isomo,inpdet[isomo],inode->addr);


    // Recurse to C0
    if(inpdet[isomo] == 0){
        if(inode->C0 != NULL){
            findAddofDet(inode->C0, isomo+1, foundDet, NSOMOMax, inpdet, addr);
        }
        else{
            ,*addr = -1;
            return;
        }
    }
    else{
        // Recurse to C1
        if(inode->C1 != NULL){
            findAddofDet(inode->C1, isomo+1, foundDet, NSOMOMax, inpdet, addr);
        }
        else{
            ,*addr = -1;
            return;
        }
    }

    return;
}

void findAddofDetDriver(Tree *dettree, int NSOMOMax, int *inpdet, int *addr){
    ,*addr = -1;
    int isomo = 0;
    bool foundDet = false;
    // for(int i=0;i<NSOMOMax;i++)
    //    printf("%d ",inpdet[i]);
    findAddofDet((dettree->rootNode), isomo, foundDet, NSOMOMax, inpdet, addr);
}

void getDetlist(Node *inode, int isomo, int NSOMOMax, int *vecBF, int *detlist){
    // Exit condition
    if(isomo > NSOMOMax) return;
    if(inode == NULL) return;

    if(isomo == NSOMOMax){
        int idet=0;
        for(int k=0;k<NSOMOMax;k++){
            if(vecBF[k] == 1) idet = idet | (1<<(NSOMOMax-1-k));
        }
        detlist[inode->addr]=idet;
        return;
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(inode),inode->C1);


    // Recurse to C0
    if(inode->C0 != NULL){
        vecBF[isomo] = 0;
        getDetlist(inode->C0, isomo+1, NSOMOMax, vecBF, detlist);
    }
    // Recurse to C1
    if(inode->C1 != NULL){
        vecBF[isomo] = 1;
        getDetlist(inode->C1, isomo+1, NSOMOMax, vecBF, detlist);
    }

    return;
}

void getDetlistDriver(Tree *dettree, int NSOMOMax, int *detlist){
    int isomo = 0;
    int vecBF[NSOMOMax];
    if(dettree->rootNode->addr > 1) getDetlist((dettree->rootNode), isomo, NSOMOMax, vecBF, detlist);
}

void genDetBasis(Tree *dettree, int Isomo, int MS, int *ndets){

    int NSOMO=0;
    getSetBits(Isomo, &NSOMO);
    genDetsDriver(dettree, NSOMO, MS, ndets);

}
#+end_src

- [X] Generate BF to Det matrix

  Here we generate the matrix of transformation from BF basis to
  determinant basis.

#+name: convertBFtoDetbasis
#+begin_src C :main no :noweb yes #:tangle cfgCI_utils.c

void getbftodetfunction(Tree *dettree, int NSOMO, int MS, int *BF1, double *rowvec){
    int npairs = 1 << ((NSOMO - MS)/2);
    int idxp = 0;
    int idxq = 0;
    int *detslist = malloc(npairs*NSOMO*sizeof(int));
    double *phaselist = malloc(npairs*sizeof(double));
    for(int i=0;i<npairs;i++)
        phaselist[i] = 1.0;
    int shft = npairs;
    int donepq[NSOMO];
    double fac = 1.0;
    for(int i = 0; i < NSOMO; i++)
        donepq[i] = 0.0;
    //for(int i = 0; i < NSOMO; i++)
    //    printf("%d) %d\n",i,BF1[i]);

    for(int i = 0; i < NSOMO; i++){
        idxp = BF1[i];
        idxq = BF1[idxp];
        //printf("idxp=%d idxq=%d\n",idxp,idxq);
        // Do one pair only once
        if(donepq[idxp] > 0.0 || donepq[idxq] > 0.0) continue;
        fac *= 2.0;
        donepq[idxp] = 1.0;
        donepq[idxq] = 1.0;
        for(int j = 0; j < npairs; j = j + shft){
            for(int k = 0; k < shft/2; k++){
                detslist[(k+j)*NSOMO + idxp] = 1;
                detslist[(k+j)*NSOMO + idxq] = 0;
            }
            for(int k = shft/2; k < shft; k++){
                detslist[(k+j)*NSOMO + idxp] = 0;
                detslist[(k+j)*NSOMO + idxq] = 1;
                phaselist[k+j] *=-1;
            }
        }
        shft /= 2;
    }

    // Now get the addresses
    int inpdet[NSOMO];
    int addr = -1;
    for(int i = 0; i < npairs; i++){
        for(int j = 0; j < NSOMO; j++)
            inpdet[j] = detslist[i*NSOMO + j];
        findAddofDetDriver(dettree, NSOMO, inpdet, &addr);
        rowvec[addr] = 1.0 * phaselist[i]/sqrt(fac);
        // Upon transformation from
        // SOMO to DET basis,
        // all dets have the same phase
        // Is this true ?
        //rowvec[addr] = 1.0/sqrt(fac);
    }

    free(detslist);
    free(phaselist);
}

void convertBFtoDetBasis(int64_t Isomo, int MS, double **bftodetmatrixptr, int *rows, int *cols){

    int NSOMO=0;
    getSetBits(Isomo, &NSOMO);
    int ndets = 0;
    int NBF = 0;
    double dNSOMO = NSOMO*1.0;
    double nalpha = (NSOMO + MS)/2.0;
    ndets = (int)binom(dNSOMO, nalpha);
    //printf("Ndets = %d\n",ndets);

    Tree dettree = (Tree){  .rootNode = NULL, .NBF = -1 };
    dettree.rootNode = malloc(sizeof(Node));
    (*dettree.rootNode) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = NULL, .addr = 0, .cpl = -1, .iSOMO = -1};

    genDetBasis(&dettree, Isomo, MS, &ndets);

    if(ndets == 1){
    // Initialize transformation matrix
        NBF = 1;
        (*bftodetmatrixptr) = malloc(NBF*ndets*sizeof(double));
        (*rows) = 1;
        (*cols) = 1;

        double *bftodetmatrix = (*bftodetmatrixptr);
        bftodetmatrix[0] = 1.0;

    }
    else{
    //printTreeDriver(&dettree, NSOMO);
    //printf("Ndets = %d\n",ndets);

    //int addr = -1;
    //int inpdet[NSOMO];
    //inpdet[0] = 1;
    //inpdet[1] = 1;
    //inpdet[2] = 1;
    //inpdet[3] = 0;
    //inpdet[4] = 0;
    //inpdet[5] = 0;

    //findAddofDetDriver(&dettree, NSOMO, inpdet, &addr);

    int detlist[ndets];
    getDetlistDriver(&dettree, NSOMO, detlist);

    //printf("\n");
    //for(int i=0;i<ndets;i++)
    //    printf("%d ",detlist[i]);
    //printf("\n");

    //printf("addr of det=%d\n",addr);

    // Prepare BFs
    Tree bftree = (Tree){  .rootNode = NULL, .NBF = -1 };
    bftree.rootNode = malloc(sizeof(Node));
    (*bftree.rootNode) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = NULL, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Isomo, MS, &bftree, &NBF, &NSOMO);

    //printf("in convert NBFs = %d ndets=%d\n",NBF,ndets);

    // Initialize transformation matrix
    (*bftodetmatrixptr) = malloc(NBF*ndets*sizeof(double));
    (*rows) = NBF;
    (*cols) = ndets;

    double *bftodetmatrix = (*bftodetmatrixptr);

    // Build BF to det matrix
    int addI = 0;
    int addJ = 0;
    double rowvec[ndets];
    for(int i=0;i<ndets;i++)
        rowvec[i]=0.0;
    int *BF1 = malloc(MAX_SOMO * sizeof(int));
    int *BF2 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF1 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF2 = malloc(MAX_SOMO * sizeof(int));

    for(int i = 0; i < NBF; i++){
        addI = i;
        getIthBFDriver(&bftree, NSOMO, addI, BF1);
        getBFIndexList(NSOMO, BF1, IdxListBF1);


        //printf("addI : %d > ",addI);
        //for(int k=0;k<NSOMO;k++)
        //    printf("%d ",BF1[k]);
        //printf("\n");

        // Get ith row
        getbftodetfunction(&dettree, NSOMO, MS, IdxListBF1, rowvec);

        //printf("---%d---\n",i);
        //for(int k=0;k<ndets;k++)
        //    printf("%10.4f ",rowvec[k]);
        //printf("\n");

        //printf("(%d, %d) is=%d ph=%d fac=%10.15f\n",addI, addJ, nislands, phasefactor, phasefactor*1.0/(1 << (g-nislands)));

        for(int j = 0; j < ndets; j++)
            bftodetmatrix[i*ndets + j] = rowvec[j];

        for(int k=0;k<ndets;k++)
            rowvec[k]=0.0;
    }

    // Garbage collection
    free(BF1);
    free(IdxListBF1);
    free(BF2);
    free(IdxListBF2);

    }// ndet > 1

}


void convertBFtoDetBasisWithArrayDims(int64_t Isomo, int MS, int rowsmax, int colsmax, int *rows, int *cols, double *bftodetmatrix){

    int NSOMO=0;
    getSetBits(Isomo, &NSOMO);
    int ndets = 0;
    int NBF = 0;
    double dNSOMO = NSOMO*1.0;
    double nalpha = (NSOMO + MS)/2.0;
    ndets = (int)binom(dNSOMO, nalpha);
    //printf("Ndets = %d\n",ndets);

    Tree dettree = (Tree){  .rootNode = NULL, .NBF = -1 };
    dettree.rootNode = malloc(sizeof(Node));
    (*dettree.rootNode) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = NULL, .addr = 0, .cpl = -1, .iSOMO = -1};

    genDetBasis(&dettree, Isomo, MS, &ndets);

    //printTreeDriver(&dettree, NSOMO);
    //printf("Ndets = %d\n",ndets);

    //int addr = -1;
    //int inpdet[NSOMO];
    //inpdet[0] = 1;
    //inpdet[1] = 1;
    //inpdet[2] = 1;
    //inpdet[3] = 0;
    //inpdet[4] = 0;
    //inpdet[5] = 0;

    //findAddofDetDriver(&dettree, NSOMO, inpdet, &addr);

    int detlist[ndets];
    getDetlistDriver(&dettree, NSOMO, detlist);

    //printf("\n");
    //for(int i=0;i<ndets;i++)
    //    printf("%d ",detlist[i]);
    //printf("\n");

    //printf("addr of det=%d\n",addr);

    // Prepare BFs
    Tree bftree = (Tree){  .rootNode = NULL, .NBF = -1 };
    bftree.rootNode = malloc(sizeof(Node));
    (*bftree.rootNode) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = NULL, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Isomo, MS, &bftree, &NBF, &NSOMO);

    //printf("in convert NBFs = %d ndets=%d\n",NBF,ndets);

    // Initialize transformation matrix
    //(*bftodetmatrixptr) = malloc(NBF*ndets*sizeof(double));
    (*rows) = NBF;
    (*cols) = ndets;

    //double *bftodetmatrix = (*bftodetmatrixptr);

    // Build BF to det matrix
    int addI = 0;
    int addJ = 0;
    double rowvec[ndets];
    for(int i=0;i<ndets;i++)
        rowvec[i]=0.0;
    int *BF1 = malloc(MAX_SOMO * sizeof(int));
    int *BF2 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF1 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF2 = malloc(MAX_SOMO * sizeof(int));

    for(int i = 0; i < NBF; i++){
        addI = i;
        getIthBFDriver(&bftree, NSOMO, addI, BF1);
        getBFIndexList(NSOMO, BF1, IdxListBF1);


        //printf("addI : %d > ",addI);
        //for(int k=0;k<NSOMO;k++)
        //    printf("%d ",BF1[k]);
        //printf("\n");

        // Get ith row
        getbftodetfunction(&dettree, NSOMO, MS, IdxListBF1, rowvec);

        //printf("---%d---\n",i);
        //for(int k=0;k<ndets;k++)
        //    printf("%10.4f ",rowvec[k]);
        //printf("\n");

        //printf("(%d, %d) is=%d ph=%d fac=%10.15f\n",addI, addJ, nislands, phasefactor, phasefactor*1.0/(1 << (g-nislands)));

        for(int j = 0; j < ndets; j++)
            bftodetmatrix[i*ndets + j] = rowvec[j];

        for(int k=0;k<ndets;k++)
            rowvec[k]=0.0;
    }

    // Garbage collection
    free(BF1);
    free(IdxListBF1);
    free(BF2);
    free(IdxListBF2);

}


#+end_src

- [ ] Get CSF to Determinant Transformation matrix

#+begin_src C :main no :tangle cfgCI_utils.c

void convertCSFtoDetBasis(int64_t Isomo, int MS, int rowsmax, int colsmax, double *csftodetmatrix){

    //printf("In convert csf to det\n");
    double *overlapMatrixI;
    double *orthoMatrixI;
    double *bftodetmatrixI;
    double *csftodetmatrixI;
    int NSOMO=0;

    /***********************************
                 Get Overlap
    ,************************************/
    // Fill matrix
    int rowsI = 0;
    int colsI = 0;

    getOverlapMatrix(Isomo, MS, &overlapMatrixI, &rowsI, &colsI, &NSOMO);
    //printf("\noverlap matrix\n");
    //printRealMatrix(overlapMatrixI,rowsI,colsI);
    //printf("\noverlap matrix\n");


    /***********************************
         Get Orthonormalization Matrix
    ,************************************/

    orthoMatrixI = malloc(rowsI*colsI*sizeof(double));

    gramSchmidt(overlapMatrixI, rowsI, colsI, orthoMatrixI);
    //printf("\noverlap matrix\n");
    //printRealMatrix(orthoMatrixI,rowsI,colsI);
    //printf("\noverlap matrix\n");

    /***********************************
         Get BFtoDeterminant Matrix
    ,************************************/

    int rowsbftodetI, colsbftodetI;

    convertBFtoDetBasis(Isomo, MS, &bftodetmatrixI, &rowsbftodetI, &colsbftodetI);
    //printf("\ncsf to det matrix\n");
    //printRealMatrix(bftodetmatrixI,rowsbftodetI, colsbftodetI);
    //printf("\ncsf to det matrix\n");

    /***********************************
         Get Final CSF to Det Matrix
    ,************************************/
    // First transform matrix using BLAS
    //double *bfIApqIJ = malloc(rowsbftodetI*colsbftodetI*sizeof(double));
    double *tmpcsftodet = malloc(rowsI*colsbftodetI*sizeof(double));

    int transA=false;
    int transB=false;
    callBlasMatxMat(orthoMatrixI, rowsI, colsI, bftodetmatrixI, rowsbftodetI, colsbftodetI, tmpcsftodet, transA, transB);
    for(int i=0;i<rowsI;i++)
        for(int j=0;j<colsbftodetI;j++){
            csftodetmatrix[j*rowsI + i] = fabs(tmpcsftodet[i*colsbftodetI + j]);
        }

    //printf("rowsI=%d colsI=%d rowsbftodetI=%d colsbftodetI=%d\n",rowsI,colsI,rowsbftodetI,colsbftodetI);
    // Garbage collection
    if(rowsI + colsI > 0) free(overlapMatrixI);
    if(rowsI + colsI > 0) free(orthoMatrixI);
    if(rowsbftodetI + colsbftodetI > 0) free(bftodetmatrixI);
    if(rowsI + colsbftodetI > 0) free(tmpcsftodet);
}

#+end_src

- [ ] Calling Blas

  Call CBLAS routines

#+name: callingblas
#+begin_src C :main no :tangle tree_utils.c
void callBlasMatxMat(double *A, int rowA, int colA, double *B, int rowB, int colB, double *C, bool transA, bool transB){
    int m = rowA;
    int k = colA;
    int n = colB;
    double alpha = 1.0;
    double beta  = 0.0;
    int val = 0;
    if (transA) val |= 0x1;
    if (transB) val |= 0x2;

    switch (val) {
        case 0: // notransA, notransB
            m = rowA;
            n = colB;
            k = colA;
            cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                        m, n, k, alpha, A, k, B, n, beta, C, n);
            break;
        case 1: // transA, notransB
            m = colA;
            n = colB;
            k = rowA;
            cblas_dgemm(CblasRowMajor, CblasTrans, CblasNoTrans,
                        m, n, k, alpha, A, colA, B, n, beta, C, n);
            break;
        case 2: // notransA, transB
            //m = rowA;
            //n = rowB;
            //k = colB;
            m = rowA;
            n = rowB;
            k = colA;
            cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasTrans,
                        m, n, k, alpha, A, k, B, colB, beta, C, n);
            break;
        case 3: // transA, transB
            m = colA;
            n = rowB;
            k = rowA;
            cblas_dgemm(CblasRowMajor, CblasTrans, CblasTrans,
                        m, n, k, alpha, A, colA, B, colB, beta, C, n);
            break;
        default:
            printf("Impossible !!!!\n");
            break;
    }
}
#+end_src

#+RESULTS: callingblas

- [ ] Testing everything

#+begin_src C :main no :noweb yes :libs "-lm -lblas"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include "tree_utils.h"
#include "/usr/include/x86_64-linux-gnu/cblas.h"

double logbinom(double n, double k);
//double logbinom(double n, double k) {
//    return lgamma(n+1)-lgamma(n-k+1)-lgamma(k+1);
//}
//
double binom(double n, double k);
//double binom(double n, double k) {
//    return exp(logbinom(n,k));
//}

#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

void testCblas(){
    // Test cblas
    //int rowA=4;
    //int colA=20;
    //int rowB=5;
    //int colB=20;
    //double *matA = malloc(rowA*colA*sizeof(double));
    //double *matB = malloc(rowB*colB*sizeof(double));
    //double *matC = malloc(rowA*colB*sizeof(double));
    //for(int i=0;i<rowA*colA;i++)
    //    matA[i]=1.0*i;
    //int countb=0;
    //for(int i=0;i<rowB;i++){
    //    for(int j=0;j<colB;j++){
    //        matB[i*colB + j]=countb;
    //    }
    //        countb=1;
    //}
    //printf("\n");
    //printRealMatrix(matA,rowA,colA);
    //printf("\n");
    //printRealMatrix(matB,rowB,colB);
    //printf("\n");
    //for(int i=0;i<rowA*colB;i++)
    //    matC[i]=0.0;

    //bool transA, transB;
    //transA = false;
    //transB = true;
    //callBlasMatxMat(matA, rowA, colA, matB, rowB, colB, matC, transA, transB);

    //printf("matC\n");
    //printRealMatrix(matC, rowA,rowB);
    //printf("matC\n");

    //free(matA);
    //free(matB);
    //free(matC);
}

<<inttobindigit>>

<<getncsfs>>

<<treefuncmain>>

<<indexlist>>

<<calculateislands>>

<<getNsomo>>

<<generateAllBFs>>

<<getOverlapMatrix>>

<<gramSchmidt>>

<<genDetBasis>>

<<convertBFtoDetBasis>>

<<calcMEdetpair>>

<<callcalcMEdetpair>>

<<callingblas>>

<<getApqIJMatrix>>

void main(){

    int rows = 0;
    int cols = 0;
    //double *overlapMatrixI;
    //double *overlapMatrixJ;
    //double *orthoMatrixI;
    //double *orthoMatrixJ;
    //double *bftodetmatrixI;
    //double *bftodetmatrixJ;
    double *ApqIJ;

    int64_t MS=0;
    int NSOMO=0;
    int NMO=8;

    int64_t Isomo;
    //Isomo = ((1 << 4) - 1)<<1;
    //Isomo = (1 << 4) - 1;
    Isomo = (1 << 6) - 1;
    //Isomo = Isomo + (((1<<3)-1) << 4);
    //Isomo = Isomo << 1;
    //Isomo = (1 << 8) - 1;

    int64_t Idomo;
    Idomo = 0;

    int64_t Jsomo;
    //Jsomo = ((1 << 4) - 1)<<1;
    //Jsomo = (1 << 4) - 1;
    //Jsomo = ((1 << 2) - 1)<<1;
    Jsomo = (1 << 3) - 1;
    Jsomo = Jsomo | (((1<<3)-1) << 4);
    //Jsomo = Jsomo << 1;
    //Jsomo = (1 << 8) - 1;
    //Jsomo = (1 << 10) - 1;

    int64_t Jdomo;
    Jdomo = 0;

    printf("\nIsomo- "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Isomo));
    printf("\n");
    printf("\nJsomo- "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(Jsomo));
    printf("\n");

    int orbp = 1;
    orbp = 4;
    int orbq = 1;
    orbq = 7;
    //orbq = 6;
    //orbq = 8-1;
    //orbq = 10-1;
    printf("%d %d\n",orbp,orbq);

    getApqIJMatrixDriver(Isomo, Jsomo, orbp, orbq, MS, NMO, &ApqIJ, &rows, &cols);
    printf("1-ME CSF basis\n");
    printRealMatrix(ApqIJ, rows, cols);
    printf("\n1-ME CSF basis\n");



    // Garbage collection
    free(ApqIJ);

    return;
}
#+end_src

#+RESULTS:
|           |         |            |       |       |
|    Isomo- |  111111 |            |       |       |
|           |         |            |       |       |
|    Jsomo- | 1110111 |            |       |       |
|         4 |       7 |            |       |       |
|      1-ME |     CSF |      basis |       |       |
| SOMO->VMO |     and | DOMO->SOMO |       |       |
|           |         |            |       |       |
|     -0.13 |    0.13 |      -1.06 | -0.06 | -0.52 |
|     -0.49 |    0.35 |      -0.58 |  0.06 |  -0.7 |
|     -1.06 |   -0.58 |       -1.3 |  -1.0 | -1.12 |
|     -0.17 |   -0.53 |       -1.0 |  -0.1 | -0.45 |
|     -0.52 |    -0.7 |      -1.12 | -0.45 |  -0.5 |
|           |         |            |       |       |
|      1-ME |     CSF |      basis |       |       |


** Make the prototype matrices

The prototype matrices give the matrix-elements (MEs) for a given type
of excitation \(p->q\) of a specific type between two CFGs \(I,J\).

These matrices are independent of the MOs and only depend on the total number of
electrons \(nel\), total number of orbitals \(norb\), and the total spin \(S\).

#+name: makePrototypeMatrices
#+begin_src c
void makePrototypeMatrices(int nel, int norb, double spin);
#+end_src

** Functions required for calculating MEs

*** TODO [4/4] Calculate MEs in Det basis

- [X] Helpers for calculating bit shifts and phases

  #+name: phasehelpers
  #+begin_src C :main no :tangle cfgCI_utils.c
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

int applyRemoveShftAddSOMOVMO(int idet, int p, int q, int *phase){
    // CSF: 1 2 1 1 1 1 1 1 1 1
    // DET: 1   0 0 1 1 0 0 1 0
    //        |         |
    //        p         q
    //
    //          result
    //
    // CSF: 1 1 1 1 1 1 2 1 1 1
    // DET: 1 0 0 0 1 1   0 1 0
    // maskp:
    //      0 1 1 1 1 1 1 1 1 1
    // maskq:
    //      0 0 0 0 0 0 0 1 1 1
    int maskp  = (1UL << p)-1;
    int maskq  = (1UL << q)-1;
    int maskpxq = (maskp ^ maskq);
    int maskpxqi = ~(maskp ^ maskq);

    // Step 1: remove
    // clear bits from p
    int outdet = idet;
    int occatp = idet & (1UL << (p-1));
    //printf("occatp=%d\n",occatp);
    outdet &= ~(1UL << (p-1));

    // Step 2: shift
    if(q > p){
        // start with q
        // shift middle electrons to left

        //// This is because we dont need q but need p
        //maskpxq = maskpxq >> 1;
        //maskpxqi = ~(maskpxq);

        // calculate the phase
        int na, nb;
        int tmpdet = outdet & (maskpxq);
        na = __builtin_popcount(tmpdet);
        nb = abs(p-q) - na;
        //printf("\nna=%d nb=%d\n",na,nb);
        int nfermions = occatp == 0 ? nb : na;
        (*phase) = nfermions % 2 == 0 ? 1 : -1;

        int tmpdetq1 = outdet & maskpxq;
        int tmpdetq2 = outdet & maskpxqi;
        tmpdetq1 = tmpdetq1 >> 1;
        outdet = tmpdetq1 | tmpdetq2;
    }
    else{

        // This is because we dont need p but need q
        maskpxq = maskpxq >> 1;
        maskpxqi = ~(maskpxq);

        // calculate the phase
        int na, nb;
        int tmpdet = outdet & (maskpxq);
        na = __builtin_popcount(tmpdet);
        nb = abs(p-q) - na;
        //printf("\nna=%d nb=%d\n",na,nb);
        int nfermions = occatp == 0 ? nb : na;
        (*phase) = nfermions % 2 == 0 ? 1 : -1;

        // start with p
        // shift middle electrons to right
        int tmpdetp1 = outdet & maskpxq;
        int tmpdetp2 = outdet & maskpxqi;
        tmpdetp1 = tmpdetp1 << 1;
        outdet = tmpdetp1 | tmpdetp2;
    }

    // Step 3: Add bit at q
    if(occatp > 0) outdet |= (1UL << (q-1));

    // Done
    return(outdet);
}
int applyRemoveShftAddDOMOSOMO(int idet, int p, int q, int *phase){
    // CSF: 1 2 1 1 1 1 1 1 1 1
    // DET: 1   0 0 1 1 0 0 1 0
    //        |         |
    //        p         q
    //
    //          result
    //
    // CSF: 1 1 1 1 1 1 2 1 1 1
    // DET: 1 0 0 0 1 1   0 1 0
    // maskp:
    //      0 1 1 1 1 1 1 1 1 1
    // maskq:
    //      0 0 0 0 0 0 0 1 1 1
    int maskp  = (1UL << p)-1;
    int maskq  = (1UL << q)-1;
    int maskpxq = (maskp ^ maskq);
    int maskpxqi = ~(maskp ^ maskq);

    // Step 1: remove
    // clear bits from q
    int outdet = idet;
    int occatq = idet & (1UL << (q-1));
    outdet &= ~(1UL << (q-1));

    // Step 2: shift
    if(q > p){
        // start with q
        // shift middle electrons to left

        // This is because we dont need q but need p
        maskpxq = maskpxq >> 1;
        maskpxqi = ~(maskpxq);

        // calculate the phase
        int na, nb;
        int tmpdet = outdet & (maskpxq);
        na = __builtin_popcount(tmpdet);
        nb = abs(p-q) - na;
        //printf("\nna=%d nb=%d\n",na,nb);
        // spin obb to that at q is moving
        int nfermions = occatq == 0 ? na : nb;
        (*phase) = nfermions % 2 == 0 ? 1 : -1;

        int tmpdetq1 = outdet & maskpxq;
        int tmpdetq2 = outdet & maskpxqi;
        tmpdetq1 = tmpdetq1 << 1;
        outdet = tmpdetq1 | tmpdetq2;
    }
    else{
        // calculate the phase
        int na, nb;
        int tmpdet = outdet & (maskpxq);
        na = __builtin_popcount(tmpdet);
        nb = abs(p-q) - na;
        //printf("\nna=%d nb=%d\n",na,nb);
        // spin obb to that at q is moving
        int nfermions = occatq == 0 ? na : nb;
        (*phase) = nfermions % 2 == 0 ? 1 : -1;

        // start with p
        // shift middle electrons to right
        int tmpdetp1 = outdet & maskpxq;
        int tmpdetp2 = outdet & maskpxqi;
        tmpdetp1 = tmpdetp1 >> 1;
        outdet = tmpdetp1 | tmpdetp2;
    }

    // Step 3: Add bit at p
    if(occatq > 0) outdet |= (1UL << (p-1));

    // Done
    return(outdet);
}

int applyRemoveShftSOMOSOMO(int idet, int p, int q, int *phase){
    // CSF: 1 1 1 1 1 1 1 1 1 1
    // DET: 1 1 0 0 1 1 0 0 1 0
    //        |         |
    //        p         q
    //
    //          result
    //
    // CSF: 1   1 1 1 1   1 1 1
    // DET: 1   0 0 1 1   0 1 0
    // maskp:
    //      0 1 1 1 1 1 1 1 1 1
    // maskq:
    //      0 0 0 0 0 0 0 1 1 1
    int maskp  = (1UL << p)-1;
    int maskq  = (1UL << q)-1;
    int maskpi =~maskp;
    int maskqi =~maskq;

    // Step 1: remove
    // clear bits from p and q
    int outdet = idet;
    outdet &= ~(1UL << (p-1));
    outdet &= ~(1UL << (q-1));

    // calculate the phase
    int occatp = idet & (1UL << (p-1));
    int na, nb;
    int tmpdet = outdet & (maskp ^ maskq);
    na = __builtin_popcount(tmpdet);
    nb = abs(p-q)-1 - na;
    //printf("\nna=%d nb=%d\n",na,nb);
    int nfermions = occatp == 0 ? nb : na;
    (*phase) = nfermions % 2 == 0 ? 1 : -1;

    // Step 2: shift
    if(q > p){
        // start with q
        // shift everything left of q
        int tmpdetq1 = outdet & maskq;
        int tmpdetq2 = outdet & maskqi;
        tmpdetq2 = tmpdetq2 >> 1;
        outdet = tmpdetq1 | tmpdetq2;

        // shift everything left of p
        int tmpdetp1 = outdet & maskp;
        int tmpdetp2 = outdet & maskpi;
        tmpdetp2 = tmpdetp2 >> 1;
        outdet = tmpdetp1 | tmpdetp2;
    }
    else{
        // start with p
        // shift everything left of p
        int tmpdetp1 = outdet & maskp;
        int tmpdetp2 = outdet & maskpi;
        tmpdetp2 = tmpdetp2 >> 1;
        outdet = tmpdetp1 | tmpdetp2;

        // shift everything left of q
        int tmpdetq1 = outdet & maskq;
        int tmpdetq2 = outdet & maskqi;
        tmpdetq2 = tmpdetq2 >> 1;
        outdet = tmpdetq1 | tmpdetq2;
    }

    // Done
    return(outdet);
}

unsigned int shftbit(int num, int p){
    unsigned int maskleft = ~(0 | ((1<<p)-1));
    unsigned int maskright = ((1<<(p-1))-1);
    int numleft = num & maskleft;
    int numright = num & maskright;
    numleft = numleft >> 1;
    return(numleft | numright);
};

int getphase(int num, int p, int q, int nmo){
    // CSF: 1 1 1 1 1 1 1 1 1 1
    // DET: 1 1 0 0 1 1 0 0 1 0
    //        |         |
    //        p         q
    //        |         |
    // CSF: 1 1 1 1 1 1 1 1 1 1
    // DET: 1 0 0 0 1 1 1 0 1 0
    //
    // maskleft:
    //      1 1 1 1 1 1 1 0 0 0
    // maskright:
    //      0 1 1 1 1 1 1 1 1 1
    int omax = p > q ? p : q;
    int omin = p > q ? q : p;
    unsigned int maskleft = ~(0 | ((1<<(omin-1))-1));
    unsigned int maskright = ((1<<(omax))-1);
    unsigned int maskmo = ((1<<nmo)-1);
    int numleft = num & maskleft;
    int numleftright = numleft & maskright;
    int nalpha = __builtin_popcount(numleftright & maskmo);
    int nbeta = omax-omin+1 - nalpha;
    int maskatp = (1<<(p-1));
    int nelecalphaatp = __builtin_popcount(num & maskatp);
    int maskatq = (1<<(q-1));
    int nelecalphaatq = __builtin_popcount(num & maskatq);
    int nfermions = nelecalphaatp == 0 ? nbeta : nalpha;
    int phase = (nfermions-1) % 2 == 0 ? 1 : -1;
    if(nelecalphaatp == nelecalphaatq) phase = 0.0;
    return(phase);
};


int getDOMOSOMOshift(int idet, int p, int q, int *phase){
    /*
      Idea:
      DOMO->SOMO example

      1 2 1 1 1
        p     q
      1 1 1 1 2

      p = 3
      q = 1

      in determinant representation: (0->beta,1->alpha)
      |I>   = 0 0 1 1
               |____|
               p    q

      |ret> = 0 1 0 1
      A shift of bit at q to pos after p.

    ,*/

    int maskq = ~((1UL<<q)-1);
    int maskp = (1UL<<p)-1;
    int maskpq = ~(maskp & maskq);
    int bits_to_shft = (idet & maskq) & maskp;
    // shift bits by 1 index
    int shifted_bits = bits_to_shft >> 1;
    // Now combine with original det
    int detout = (idet & maskpq);
    // Zero out bits at q
    detout &= ~(1UL << (q-1));
    // Set the bit at p
    detout |=  (1UL << (p-1));
    // Add the shifted bits
    detout |= shifted_bits;

    // Now calcaulate the phase
    // Find the type of bit at q
    int occatq = idet & (1UL << (q-1));
    // calculate number of alpha and beta spins
    int na = __builtin_popcount(shifted_bits);
    int nb = p - q - na;
    printf("\noccq=%d | na=%d nb=%d\n",occatq,na,nb);
    // Find the number of fermions to pass
    int nfermions = occatq == 0 ? na : nb;
    (*phase) = nfermions % 2 == 0 ? 1 : -1;
    return(detout);
}
  #+end_src

- [X] Calculate one-electron ME between two dets

#+name: calcMEdetpair
#+begin_src C :main no :tangle cfgCI_utils.c :noweb yes
void calcMEdetpair(int *detlistI, int *detlistJ, int orbI, int orbJ, int Isomo, int Jsomo, int ndetI, int ndetJ, int NMO, double *matelemdetbasis){

    // Calculation of phase
    // The following convention is used
    // <J|a^{\dagger}_q a_p | I>
    //
    // The phase is calculated
    // assuming all alpha electrons
    // are on the left and all beta
    // electrons are on the RHS
    // of the alphas.


    int maskI;
    int nelecatI;
    unsigned int maskleft;
    unsigned int maskright;
    unsigned int psomo;
    unsigned int qsomo;


    // E(q,p) |I> = cqp |J>


    int p,q; // The two orbitals p is always > q.
    p = orbI >= orbJ ? orbI : orbJ;
    q = orbI >= orbJ ? orbJ : orbI;

    // Find the corresponding case
    // 1. NdetI > NdetJ  (SOMO -> SOMO)
    // 2. NdetI < NdetJ  (DOMO -> VMO)
    // 3. NdetI == NdetJ (SOMO -> VMO and DOMO -> SOMO)

    // Converting the above four cases into int:
    int case_type = abs(ndetI - ndetJ) == 0 ? 3 : (ndetI > ndetJ ? 1 : 2);

    switch (case_type){
        case 1:
            // SOMO -> SOMO
            printf("SOMO->SOMO\n");
            // Find the orbital ids in model space
            maskleft  =  (0 | ((1<<(p))-1));
            maskright =  (0 | ((1<<(q))-1));
            //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(maskleft));
            //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(maskright));
            psomo = __builtin_popcount(Isomo & maskleft);
            qsomo = q == 1 ? 1 : __builtin_popcount(Isomo & maskright);
            p = psomo >= qsomo ? psomo : qsomo;
            q = psomo >= qsomo ? qsomo : psomo;

            //printf("I=%d J=%d (%d %d)\n",Isomo,Jsomo,p,q);

            //printf("SOMO->SOMO\n");
            //printf("\np=%d q=%d  (%d %d)\n",q,p,psomo,qsomo);
            for(int i=0;i<ndetI;i++){
                int idet = detlistI[i];
                printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));                // Calculate phase
                int phase = getphase(idet,orbI,orbJ,NMO);
                // Shift bits for
                idet = shftbit(shftbit(detlistI[i],q),p-1);
                printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));
                printf(" %d\n",phase);
                for(int j=0;j<ndetJ;j++){
                    int jdet = (detlistJ[j]);
                    if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
                }
            }
            break;
        case 2:
            // DOMO -> VMO
            printf("DOMO->VMO\n");
            // Find the orbital ids in model space
            maskleft = (0 | ((1<<(p))-1));
            maskright =(0 | ((1<<(q))-1));
            psomo = __builtin_popcount(Jsomo & maskleft);
            qsomo = q == 1 ? 1 : __builtin_popcount(Jsomo & maskright);
            p = psomo >= qsomo ? psomo : qsomo;
            q = psomo >= qsomo ? qsomo : psomo;

            //printf("I=%d J=%d (%d %d)\n",Isomo,Jsomo,p,q);

            for(int i=0;i<ndetI;i++){
                // Get phase
                int idet = detlistI[i];
                for(int j=0;j<ndetJ;j++){
                    int jdet = (detlistJ[j]);
                    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(jdet));                // Calculate phase
                    // Calculate phase
                    int phase = 1*getphase(jdet,p,q,NMO);
                    // Shift bits for I
                    jdet = shftbit(shftbit(detlistJ[j],q),p-1);
                    //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(jdet));
                    //printf(" %d\n",phase);
                    if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
                }
            }
            break;
        case 3:
            // (SOMO -> VMO or DOMO -> SOMO)
            // if Isomo[p] == 1 => SOMO -> VMO
            // if Isomo[p] == 0 => DOMO -> SOMO
            printf("SOMO->VMO and DOMO->SOMO\n");
            // Find the orbital ids in model space
            maskleft = ((1<<(p))-1);
            maskright =((1<<(q))-1);
            psomo = __builtin_popcount(Isomo & maskleft);
            //qsomo = q == 1 ? 1 : __builtin_popcount(Isomo & maskright);
            qsomo = __builtin_popcount(Isomo & maskright);
            p = psomo >= qsomo ? psomo : qsomo;
            q = psomo >= qsomo ? qsomo : psomo;


            int noccorbI = (Isomo & (1<<(orbI-1)));
            switch (noccorbI){
                case 0:
                    // Case: DOMO -> SOMO
                    printf("DOMO->SOMO, %d,%d\n",p,q);
                    break;
                case 1:
                    // Case: SOMO -> VMO
                    printf("SOMO->VMO, %d,%d\n",p,q);
                    break;
                default:
                    printf("Something is wrong in calcMEdetpair\n");
                    break;
            }

            int tmpidet;

            //printf("I=%d J=%d (>%d %d)\n",Isomo,Jsomo,p,q);
            for(int i=0;i<ndetI;i++){
                // Get phase
                int idet = detlistI[i];
                printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));
                int nelecalphaatp = (Isomo & (1<<(orbI-1)));
                // Idea:
                // if DOMO -> SOMO
                //
                // I =
                //   2  1 1 1 1
                // (10) 0 0 1 1
                //
                //     |
                //    \ /
                //     .
                //  0 0 0 1 1
                //
                // J =
                // 1 1 1 1  2
                // 0 0 1 1 (10)
                //
                if(nelecalphaatp == 0){
                    // Case: DOMO -> SOMO
                    tmpidet = idet;
                    int nelecalphaatq = (idet & (1<<(orbJ-1)));
                    if(nelecalphaatq==0) tmpidet = tmpidet ^ (1<<(orbI-1));
                    else                 tmpidet = tmpidet ^ (0);
                    idet = shftbit(idet,q);
                }
                else{
                    tmpidet = idet;
                    idet = shftbit(idet,p);
                }

                // Calculate phase
                int phase = 1*getphase(tmpidet,orbI,orbJ,NMO);
                printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(tmpidet));
                printf(" %d\n",phase);
                for(int j=0;j<ndetJ;j++){
                //printf("\tleading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(detlistJ[j]));
                    int jdet;
                    if(nelecalphaatp == 0) jdet = shftbit(detlistJ[j],p);
                    else                   jdet = shftbit(detlistJ[j],q);
                //printf("\t -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(jdet));
                //printf("\n");
                //printf("(%d  %d) -> %d\n",i,j,phase);
                    if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
                }
            }

            break;
        default:
            printf("Something is wrong in calc ME\n");
            break;
    } // end select
    //printRealMatrix(matelemdetbasis,ndetI,ndetJ);

}
#+end_src

- [ ] Calculate one-electron MEs : a general function (p>q and p<q)


#+begin_src C :main no :tangle cfgCI_utils.c :noweb yes
void calcMEdetpairGeneral(int *detlistI, int *detlistJ, int orbI, int orbJ, int Isomo, int Jsomo, int ndetI, int ndetJ, int NMO, double *matelemdetbasis){

    // Calculation of phase
    // The following convention is used
    // <J|a^{\dagger}_q a_p | I>
    //
    // The phase is calculated
    // assuming all alpha electrons
    // are on the left and all beta
    // electrons are on the RHS
    // of the alphas.

    // There are three possibilities
    // which need to be separated
    // CASE 1. p > q
    // CASE 2. p < q
    // CASE 3. p == q

    int maskI;
    int nelecatI;
    int noccorbI;
    unsigned int maskleft;
    unsigned int maskright;
    unsigned int psomo;
    unsigned int qsomo;

    int p,q; // The two orbitals p is always > q.

    if(orbI > orbJ){
        // CASE 1 : orbI > orbJ
        p = orbI;
        q = orbJ;

        // Find the corresponding sub case
        // 1. NdetI > NdetJ  (SOMO -> SOMO)
        // 2. NdetI < NdetJ  (DOMO -> VMO)
        // 3. NdetI == NdetJ (SOMO -> VMO and DOMO -> SOMO)

        // Converting the above four cases into int:
        int case_type = abs(ndetI - ndetJ) == 0 ? 3 : (ndetI > ndetJ ? 1 : 2);
        p = orbI;
        q = orbJ;

        switch (case_type){
            case 1:
                // SOMO -> SOMO
                //printf("1SOMO->SOMO\n");
                // Find the orbital ids in model space
                maskleft  =  (0 | ((1<<(p))-1));
                maskright =  (0 | ((1<<(q))-1));
                //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(maskleft));
                //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(maskright));
                psomo = __builtin_popcount(Isomo & maskleft);
                qsomo = __builtin_popcount(Isomo & maskright); // q has to be atleast 1
                p = psomo;
                q = qsomo;

                //printf("I=%d J=%d (%d %d)\n",Isomo,Jsomo,p,q);

                //printf("SOMO->SOMO\n");
                //printf("\np=%d q=%d  (%d %d)\n",q,p,psomo,qsomo);
                for(int i=0;i<ndetI;i++){
                    int idet = detlistI[i];
                    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));                // Calculate phase
                    int phase=1;
                    // Apply remove and shft on Isomo
                    idet = applyRemoveShftSOMOSOMO(idet, p, q, &phase);
                    //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));
                    //printf(" %d\n",phase);
                    for(int j=0;j<ndetJ;j++){
                        int jdet = (detlistJ[j]);
                        if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
                    }
                }
                break;
            case 2:
                // DOMO -> VMO
                //printf("1DOMO->VMO\n");
                // Find the orbital ids in model space
                // As seen in Jsomo
                // Here we apply a^{\dagger}_p a_q |J>
                maskleft = (0 | ((1<<(p))-1));
                maskright =(0 | ((1<<(q))-1));
                psomo = __builtin_popcount(Jsomo & maskleft);
                qsomo = __builtin_popcount(Jsomo & maskright); // q has to be atleast 1
                p = psomo;
                q = qsomo;

                //printf("I=%d J=%d (%d %d)\n",Isomo,Jsomo,p,q);

                for(int i=0;i<ndetI;i++){
                    // Get phase
                    int idet = detlistI[i];
                    for(int j=0;j<ndetJ;j++){
                        int jdet = (detlistJ[j]);
                        //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(jdet));                // Calculate phase
                        // Calculate phase
                        int phase=1;
                        // Apply remove and shift on Jdet (orbital ids are inverted)
                        jdet = applyRemoveShftSOMOSOMO(jdet, q, p, &phase);
                        //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(jdet));
                        //printf(" %d\n",phase);
                        if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
                    }
                }
                break;
            case 3:
                // (SOMO -> VMO or DOMO -> SOMO)
                //printf("1SOMO->VMO and DOMO->SOMO\n");
                noccorbI = __builtin_popcount(Isomo & (1<<(orbI-1)));

                //printf("I=%d J=%d (%d %d) nocc=%d\n",Isomo,Jsomo,p,q,noccorbI);
                switch (noccorbI){
                    case 0:
                        // Case: DOMO -> SOMO
                        //printf("DOMO->SOMO, %d,%d\n",p,q);
                        // Find the orbital ids in model space
                        // p is from Jsomo
                        // q is from Isomo
                        maskleft = ((1<<(p))-1);
                        maskright =((1<<(q))-1);
                        psomo = __builtin_popcount(Jsomo & maskleft);
                        qsomo = __builtin_popcount(Isomo & maskright);
                        p = psomo;
                        q = qsomo;

                        for(int i=0;i<ndetI;i++){
                            int idet = detlistI[i];
                            //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));                // Calculate phase
                            int phase=1;
                            // Apply remove and shft on Isomo
                            idet = applyRemoveShftAddDOMOSOMO(idet, p, q, &phase);
                            //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));
                            //printf(" %d\n",phase);
                            for(int j=0;j<ndetJ;j++){
                                int jdet = (detlistJ[j]);
                                if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
                            }
                        }
                        break;
                    case 1:
                        // Case: SOMO -> VMO
                        //printf("SOMO->VMO, %d,%d\n",p,q);
                        // Find the orbital ids in model space
                        // p is from Isomo
                        // q is from Jsomo
                        maskleft = ((1<<(p))-1);
                        maskright =((1<<(q))-1);
                        psomo = __builtin_popcount(Isomo & maskleft);
                        qsomo = __builtin_popcount(Jsomo & maskright);
                        p = psomo;
                        q = qsomo;

                        for(int i=0;i<ndetI;i++){
                            int idet = detlistI[i];
                            //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));                // Calculate phase
                            int phase=1;
                            // Apply remove and shft on Isomo
                            idet = applyRemoveShftAddSOMOVMO(idet, p, q, &phase);
                            //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));
                            //printf(" %d\n",phase);
                            for(int j=0;j<ndetJ;j++){
                                int jdet = (detlistJ[j]);
                                if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
                            }
                        }
                        break;
                    default:
                        printf("Something is wrong in calcMEdetpair\n");
                        break;
                }
                break;
            default:
                printf("Something is wrong in calc ME\n");
                break;
        } // end select

    } // end orbI > orbJ
    else if(p < q){
        // CASE 2 orbI < orbJ
        p = orbI;
        q = orbJ;
        // Find the corresponding sub case
        // 1. NdetI > NdetJ  (SOMO -> SOMO)
        // 2. NdetI < NdetJ  (DOMO -> VMO)
        // 3. NdetI == NdetJ (SOMO -> VMO and DOMO -> SOMO)

        // Converting the above four cases into int:
        int case_type = abs(ndetI - ndetJ) == 0 ? 3 : (ndetI > ndetJ ? 1 : 2);

        switch (case_type){
            case 1:
                // SOMO -> SOMO
                //printf("2SOMO->SOMO\n");
                // Find the orbital ids in model space
                maskleft  =  (0 | ((1<<(p))-1));
                maskright =  (0 | ((1<<(q))-1));
                //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(maskleft));
                //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(maskright));
                psomo = __builtin_popcount(Isomo & maskleft);
                qsomo = __builtin_popcount(Isomo & maskright); // q has to be atleast 1
                p = psomo;
                q = qsomo;

                //printf("I=%d J=%d  (%d %d) (%d %d)\n",Isomo,Jsomo,p,q,orbI,orbJ);

                //printf("SOMO->SOMO\n");
                //printf("\np=%d q=%d  (%d %d)\n",q,p,psomo,qsomo);
                for(int i=0;i<ndetI;i++){
                    int idet = detlistI[i];
                    //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));                // Calculate phase
                    int phase=1;
                    // Apply remove and shft on Isomo
                    idet = applyRemoveShftSOMOSOMO(idet, p, q, &phase);
                    //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));
                    //printf(" %d\n",phase);
                    for(int j=0;j<ndetJ;j++){
                        int jdet = (detlistJ[j]);
                        if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
                    }
                }
                break;
            case 2:
                // DOMO -> VMO
                //printf("2DOMO->VMO\n");
                // Find the orbital ids in model space
                // As seen in Jsomo
                // Here we apply a^{\dagger}_p a_q |J>
                maskleft = (0 | ((1<<(p))-1));
                maskright =(0 | ((1<<(q))-1));
                psomo = __builtin_popcount(Jsomo & maskleft);
                qsomo = __builtin_popcount(Jsomo & maskright); // q has to be atleast 1
                p = psomo;
                q = qsomo;

                //printf("I=%d J=%d (%d %d)\n",Isomo,Jsomo,p,q);

                for(int i=0;i<ndetI;i++){
                    // Get phase
                    int idet = detlistI[i];
                    for(int j=0;j<ndetJ;j++){
                        int jdet = (detlistJ[j]);
                        //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(jdet));                // Calculate phase
                        // Calculate phase
                        int phase=1;
                        // Apply remove and shift on Jdet (orbital ids are inverted)
                        jdet = applyRemoveShftSOMOSOMO(jdet, q, p, &phase);
                        //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(jdet));
                        //printf(" %d\n",phase);
                        if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
                    }
                }
                break;
            case 3:
                // (SOMO -> VMO or DOMO -> SOMO)
                // if Isomo[p] == 1 => SOMO -> VMO
                // if Isomo[p] == 0 => DOMO -> SOMO
                //printf("2SOMO->VMO and DOMO->SOMO\n");
                noccorbI = __builtin_popcount(Isomo & (1<<(orbI-1)));

                switch (noccorbI){
                    case 0:
                        // Case: DOMO -> SOMO
                        //printf("DOMO->SOMO, %d,%d\n",p,q);
                        // Find the orbital ids in model space
                        // p is from Jsomo
                        // q is from Isomo
                        maskleft = ((1<<(p))-1);
                        maskright =((1<<(q))-1);
                        psomo = __builtin_popcount(Jsomo & maskleft);
                        qsomo = __builtin_popcount(Isomo & maskright);
                        p = psomo;
                        q = qsomo;

                        for(int i=0;i<ndetI;i++){
                            int idet = detlistI[i];
                            //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));                // Calculate phase
                            int phase=1;
                            // Apply remove and shft on Isomo
                            idet = applyRemoveShftAddDOMOSOMO(idet, p, q, &phase);
                            //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));
                            //printf(" %d\n",phase);
                            for(int j=0;j<ndetJ;j++){
                                int jdet = (detlistJ[j]);
                                if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
                            }
                        }
                        break;
                    case 1:
                        // Case: SOMO -> VMO
                        //printf("SOMO->VMO, %d,%d\n",p,q);
                        // Find the orbital ids in model space
                        // p is from Isomo
                        // q is from Jsomo
                        maskleft = ((1<<(p))-1);
                        maskright =((1<<(q))-1);
                        psomo = __builtin_popcount(Isomo & maskleft);
                        qsomo = __builtin_popcount(Jsomo & maskright);
                        p = psomo;
                        q = qsomo;

                        for(int i=0;i<ndetI;i++){
                            int idet = detlistI[i];
                            //printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));                // Calculate phase
                            int phase=1;
                            // Apply remove and shft on Isomo
                            idet = applyRemoveShftAddSOMOVMO(idet, p, q, &phase);
                            //printf(" -> "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(idet));
                            //printf(" %d\n",phase);
                            for(int j=0;j<ndetJ;j++){
                                int jdet = (detlistJ[j]);
                                if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0*phase;
                            }
                        }
                        break;
                    default:
                        printf("Something is wrong in calcMEdetpair\n");
                        break;
                }
                break;
            default:
                printf("Something is wrong in calc ME\n");
                break;
        } // end select
    } // end orbI  < orbJ
    else{
        // CASE 3 : orbI == orbJ

        // Three possibilities
        // orbI = VMO
        // orbI = SOMO
        // orbI = DOMO
        int noccorbI = (Isomo & (1<<(orbI-1)));
        switch (noccorbI){
            case 0:
                // Matrix is 0
                for(int i=0;i<ndetI;i++){
                    int idet = detlistI[i];
                    for(int j=0;j<ndetJ;j++){
                        int jdet = (detlistJ[j]);
                        if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 0.0;
                    }
                }
                break;
            case 1:
                // Matrix is Identity
                for(int i=0;i<ndetI;i++){
                    int idet = detlistI[i];
                    for(int j=0;j<ndetJ;j++){
                        int jdet = (detlistJ[j]);
                        if(idet == jdet) matelemdetbasis[i*ndetJ + j] = 1.0;
                    }
                }
                break;
            default:
                break;
        }
    } // end orbI == orbJ

    return;
}
#+end_src

- Testing (SOMO-> VMO)

  #+begin_src C

#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

int applyRemoveShftAddSOMOVMO(int idet, int p, int q, int *phase){
    // CSF: 1 2 1 1 1 1 1 1 1 1
    // DET: 1   0 0 1 1 0 0 1 0
    //        |         |
    //        p         q
    //
    //          result
    //
    // CSF: 1 1 1 1 1 1 2 1 1 1
    // DET: 1 0 0 0 1 1   0 1 0
    // maskp:
    //      0 1 1 1 1 1 1 1 1 1
    // maskq:
    //      0 0 0 0 0 0 0 1 1 1
    int maskp  = (1UL << p)-1;
    int maskq  = (1UL << q)-1;
    int maskpxq = (maskp ^ maskq);
    int maskpxqi = ~(maskp ^ maskq);

    // Step 1: remove
    // clear bits from p
    int outdet = idet;
    int occatp = idet & (1UL << (p-1));
    printf("occatp=%d\n",occatp);
    outdet &= ~(1UL << (p-1));

    // Step 2: shift
    if(q > p){
        // start with q
        // shift middle electrons to left

        //// This is because we dont need q but need p
        //maskpxq = maskpxq >> 1;
        //maskpxqi = ~(maskpxq);

        // calculate the phase
        int na, nb;
        int tmpdet = outdet & (maskpxq);
        na = __builtin_popcount(tmpdet);
        nb = abs(p-q) - na;
        printf("\nna=%d nb=%d\n",na,nb);
        int nfermions = occatp == 0 ? nb : na;
        (*phase) = nfermions % 2 == 0 ? 1 : -1;

        int tmpdetq1 = outdet & maskpxq;
        int tmpdetq2 = outdet & maskpxqi;
        tmpdetq1 = tmpdetq1 >> 1;
        outdet = tmpdetq1 | tmpdetq2;
    }
    else{

        // This is because we dont need p but need q
        maskpxq = maskpxq >> 1;
        maskpxqi = ~(maskpxq);

        // calculate the phase
        int na, nb;
        int tmpdet = outdet & (maskpxq);
        na = __builtin_popcount(tmpdet);
        nb = abs(p-q) - na;
        printf("\nna=%d nb=%d\n",na,nb);
        int nfermions = occatp == 0 ? nb : na;
        (*phase) = nfermions % 2 == 0 ? 1 : -1;

        // start with p
        // shift middle electrons to right
        int tmpdetp1 = outdet & maskpxq;
        int tmpdetp2 = outdet & maskpxqi;
        tmpdetp1 = tmpdetp1 << 1;
        outdet = tmpdetp1 | tmpdetp2;
    }

    // Step 3: Add bit at q
    if(occatp > 0) outdet |= (1UL << (q-1));

    // Done
    return(outdet);
}
printf("\nleading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(7 + 32));
int phase=0;
int outdet = applyRemoveShftAddSOMOVMO(7+32,2,4,&phase);
printf("\nphase=%d\n",phase);
printf("\nleading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(outdet));
  #+end_src

- Testing

#+begin_src C

#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

int applyRemoveShftAddDOMOSOMO(int idet, int p, int q, int *phase){
    // CSF: 1 2 1 1 1 1 1 1 1 1
    // DET: 1   0 0 1 1 0 0 1 0
    //        |         |
    //        p         q
    //
    //          result
    //
    // CSF: 1 1 1 1 1 1 2 1 1 1
    // DET: 1 0 0 0 1 1   0 1 0
    // maskp:
    //      0 1 1 1 1 1 1 1 1 1
    // maskq:
    //      0 0 0 0 0 0 0 1 1 1
    int maskp  = (1UL << p)-1;
    int maskq  = (1UL << q)-1;
    int maskpxq = (maskp ^ maskq);
    int maskpxqi = ~(maskp ^ maskq);

    // Step 1: remove
    // clear bits from q
    int outdet = idet;
    int occatq = idet & (1UL << (q-1));
    outdet &= ~(1UL << (q-1));

    // Step 2: shift
    if(q > p){
        // start with q
        // shift middle electrons to left

        // This is because we dont need q but need p
        maskpxq = maskpxq >> 1;
        maskpxqi = ~(maskpxq);

        // calculate the phase
        int na, nb;
        int tmpdet = outdet & (maskpxq);
        na = __builtin_popcount(tmpdet);
        nb = abs(p-q) - na;
        printf("\nna=%d nb=%d\n",na,nb);
        // spin obb to that at q is moving
        int nfermions = occatq == 0 ? na : nb;
        (*phase) = nfermions % 2 == 0 ? 1 : -1;

        int tmpdetq1 = outdet & maskpxq;
        int tmpdetq2 = outdet & maskpxqi;
        tmpdetq1 = tmpdetq1 << 1;
        outdet = tmpdetq1 | tmpdetq2;
    }
    else{
        // calculate the phase
        int na, nb;
        int tmpdet = outdet & (maskpxq);
        na = __builtin_popcount(tmpdet);
        nb = abs(p-q) - na;
        printf("\nna=%d nb=%d\n",na,nb);
        // spin obb to that at q is moving
        int nfermions = occatq == 0 ? na : nb;
        (*phase) = nfermions % 2 == 0 ? 1 : -1;

        // start with p
        // shift middle electrons to right
        int tmpdetp1 = outdet & maskpxq;
        int tmpdetp2 = outdet & maskpxqi;
        tmpdetp1 = tmpdetp1 >> 1;
        outdet = tmpdetp1 | tmpdetp2;
    }

    // Step 3: Add bit at p
    if(occatq > 0) outdet |= (1UL << (p-1));

    // Done
    return(outdet);
}
printf("\nleading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(7 + 32));
int phase=0;
int outdet = applyRemoveShftAddDOMOSOMO(7+32,2,4,&phase);
printf("\nphase=%d\n",phase);
printf("\nleading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(outdet));
#+end_src

#+RESULTS:
|         |      |        |
| leading | test | 100111 |
| na=2    | nb=0 |        |
|         |      |        |
| phase=1 |      |        |
|         |      |        |
| leading | test | 101101 |


#+begin_src C

#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

int applyRemoveShftSOMOSOMO(int idet, int p, int q, int *phase){
    // CSF: 1 1 1 1 1 1 1 1 1 1
    // DET: 1 1 0 0 1 1 0 0 1 0
    //        |         |
    //        p         q
    //
    //          result
    //
    // CSF: 1   1 1 1 1   1 1 1
    // DET: 1   0 0 1 1   0 1 0
    // maskp:
    //      0 1 1 1 1 1 1 1 1 1
    // maskq:
    //      0 0 0 0 0 0 0 1 1 1
    int maskp  = (1UL << p)-1;
    int maskq  = (1UL << q)-1;
    int maskpi =~maskp;
    int maskqi =~maskq;

    // Step 1: remove
    // clear bits from p and q
    int outdet = idet;
    outdet &= ~(1UL << (p-1));
    outdet &= ~(1UL << (q-1));

    // calculate the phase
    int occatp = idet & (1UL << (p-1));
    int na, nb;
    int tmpdet = outdet & (maskp ^ maskq);
    na = __builtin_popcount(tmpdet);
    nb = abs(p-q)-1 - na;
    printf("\nna=%d nb=%d\n",na,nb);
    int nfermions = occatp == 0 ? nb : na;
    (*phase) = nfermions % 2 == 0 ? 1 : -1;

    // Step 2: shift
    if(q > p){
        // start with q
        // shift everything left of q
        int tmpdetq1 = outdet & maskq;
        int tmpdetq2 = outdet & maskqi;
        tmpdetq2 = tmpdetq2 >> 1;
        outdet = tmpdetq1 | tmpdetq2;

        // shift everything left of p
        int tmpdetp1 = outdet & maskp;
        int tmpdetp2 = outdet & maskpi;
        tmpdetp2 = tmpdetp2 >> 1;
        outdet = tmpdetp1 | tmpdetp2;
    }
    else{
        // start with p
        // shift everything left of p
        int tmpdetp1 = outdet & maskp;
        int tmpdetp2 = outdet & maskpi;
        tmpdetp2 = tmpdetp2 >> 1;
        outdet = tmpdetp1 | tmpdetp2;

        // shift everything left of q
        int tmpdetq1 = outdet & maskq;
        int tmpdetq2 = outdet & maskqi;
        tmpdetq2 = tmpdetq2 >> 1;
        outdet = tmpdetq1 | tmpdetq2;
    }

    // Done
    return(outdet);
}
printf("\nleading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(3+32));
int phase=0;
int outdet = applyRemoveShftSOMOSOMO(3+32,5,1,&phase);
printf("phase=%d\n",phase);
printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(outdet));
#+end_src

#+RESULTS:
|         |      |        |
| leading | test | 100011 |
| na=1    | nb=2 |        |
| phase=1 |      |        |
| leading | test |   1001 |

#+begin_src C
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

unsigned int shftbit(int num, int p){
    unsigned int maskleft = ~(0 | ((1<<p)-1));
    unsigned int maskright = ((1<<(p-1))-1);
    printf("\nshftbit "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(maskleft));
    printf("  "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(maskright));
    printf("\n");
    int numleft = num & maskleft;
    int numright = num & maskright;
    numleft = numleft >> 1;
    return(numleft | numright);
};

//unsigned int getphase(int num, int p, int q, int nmo){
//    unsigned int maskleft = ~(0 | ((1<<q)-1));
//    unsigned int maskmo = ((1<<nmo)-1);
//    unsigned int maskright = ((1<<p)-1);
//    int numleft = num & maskleft;
//    int numleftright = numleft & maskright;
//    return(__builtin_popcount(numleftright & maskmo));
//};

int getphase(int num, int p, int q, int nmo){
    // CSF: 1 1 1 1 1 1 1 1 1 1
    // DET: 1 1 0 0 1 1 0 0 1 0
    //        |         |
    //        p         q
    //        |         |
    // CSF: 1 1 1 1 1 1 1 1 1 1
    // DET: 1 0 0 0 1 1 1 0 1 0
    //
    // maskleft:
    //      1 1 1 1 1 1 1 0 0 0
    // maskright:
    //      0 1 1 1 1 1 1 1 1 1
    int omax = p > q ? p : q;
    int omin = p > q ? q : p;
    unsigned int maskleft = ~(0 | ((1<<(omin-1))-1));
    unsigned int maskright = ((1<<(omax))-1);
    unsigned int maskmo = ((1<<nmo)-1);
    int numleft = num & maskleft;
    int numleftright = numleft & maskright;
    int nalpha = __builtin_popcount(numleftright & maskmo);
    int nbeta = omax-omin+1 - nalpha;
    printf("na=%d nb=%d ( %d, %d)\n",nalpha,nbeta,p,q);
    int maskatp = (1<<(p-1));
    int nelecalphaatp = __builtin_popcount(num & maskatp);
    int maskatq = (1<<(q-1));
    int nelecalphaatq = __builtin_popcount(num & maskatq);
    printf("nelecalphaatp=%d nelecalphaatq=%d\n",nelecalphaatp,nelecalphaatq);
    int nfermions = nelecalphaatp == 0 ? nbeta : nalpha;
    int phase = (nfermions-1) % 2 == 0 ? 1 : -1;
    if(nelecalphaatp == nelecalphaatq) phase = 0.0;
    //if(nelecalphaatp == nelecalphaatq) phase *= -1;
    return(phase);
};

int getDOMOSOMOshift(int idet, int p, int q, int *phase){
    /*
      Idea:
      DOMO->SOMO example

      1 2 1 1 1
        p     q
      1 1 1 1 2

      p = 3
      q = 1

      in determinant representation: (0->beta,1->alpha)
      |I>   = 0 0 1 1
               |____|
               p    q

      |ret> = 0 1 0 1
      A shift of bit at q to pos after p.

    ,*/

    int maskq = ~((1UL<<q)-1);
    int maskp =  ( 1UL<<(p-1))-1;
    int maskpq = ~(maskp & maskq);
    int bits_to_shft = (idet & maskq) & maskp;
    // shift bits by 1 index
    int shifted_bits = bits_to_shft >> 1;
    // Now combine with original det
    int detout = (idet & maskpq);
    // Zero out bits at q
    detout &= ~(1UL << (q-1));
    // Set the bit at p
    detout |=  (1UL << (p-1));
    // Add the shifted bits
    detout |= shifted_bits;
    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(detout));

    // Now calcaulate the phase
    // Find the type of bit at q
    int occatq = idet & (1UL << (q-1));
    // calculate number of alpha and beta spins
    int na = __builtin_popcount(shifted_bits);
    int nb = abs(p - q) - na;
    printf("\n2occq=%d | na=%d nb=%d\n",occatq,na,nb);
    // Find the number of fermions to pass
    int nfermions = occatq == 0 ? na : nb;
    (*phase) = nfermions % 2 == 0 ? 1 : -1;
    return(detout);
}
int d = 4;
printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(((1UL<<(4-1))-1)));
printf("\nleading test %d",(1<<3)-1);
int phase=getphase(7,5,1,6);
int numres=getDOMOSOMOshift(3,3,1,&phase);
printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(numres));
printf("\nphs=%d  numres=%d\n",phase,numres);
#+end_src

- [X] Calculate batch of MEs between CFGs

  Calculate the ME betwee two somos

#+name: callcalcMEdetpair
#+begin_src C :main no :tangle cfgCI_utils.c
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

void callcalcMEij(int Isomo, int Jsomo, int orbI, int orbJ, int MS, int NMO, double **ApqIJptr, int *rowsA, int *colsA){
    // Get dets for I
    int ndetI;
    int ndetJ;

    // Get detlist
    int NSOMOI=0;
    int NSOMOJ=0;
    getSetBits(Isomo, &NSOMOI);
    getSetBits(Jsomo, &NSOMOJ);

    Tree dettreeI = (Tree){  .rootNode = NULL, .NBF = -1 };
    dettreeI.rootNode = malloc(sizeof(Node));
    (*dettreeI.rootNode) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = NULL, .addr = 0, .cpl = -1, .iSOMO = -1};

    genDetBasis(&dettreeI, Isomo, MS, &ndetI);


    Tree dettreeJ = (Tree){  .rootNode = NULL, .NBF = -1 };
    dettreeJ.rootNode = malloc(sizeof(Node));
    (*dettreeJ.rootNode) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = NULL, .addr = 0, .cpl = -1, .iSOMO = -1};

    genDetBasis(&dettreeJ, Jsomo, MS, &ndetJ);
    //printf("In callcalcME Isomo=%d Jsomo=%d ndetI=%d ndetJ=%d\n",Isomo,Jsomo,ndetI,ndetJ);

    int detlistI[ndetI];
    int detlistJ[ndetJ];
    for(int i=0;i<ndetI;i++)
        detlistI[i] = 0;
    for(int i=0;i<ndetJ;i++)
        detlistJ[i] = 0;

    // Get detlist
    getDetlistDriver(&dettreeI, NSOMOI, detlistI);
    getDetlistDriver(&dettreeJ, NSOMOJ, detlistJ);
    // printdets I
    //printf("Idets=%d\n",ndetI);
    //for(int i=0;i<ndetI;i++){
    //    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(detlistI[i]));
    //    printf("\n");
    //}
    ////// printdets J
    //printf("Jdets %d\n",ndetJ);
    //for(int i=0;i<ndetJ;i++){
    //    printf("leading test "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(detlistJ[i]));
    //    printf("\n");
    //}

    (*ApqIJptr) = malloc(ndetI*ndetJ*sizeof(double));
    (*rowsA) = ndetI;
    (*colsA) = ndetJ;
    //printf("ndetI=%d ndetJ=%d\n",ndetI,ndetJ);

    double *matelemdetbasis = (*ApqIJptr);

    for(int i=0;i<ndetI;i++)
        for(int j=0;j<ndetJ;j++)
            matelemdetbasis[i*ndetJ + j]=0.0;

    // Calculate matrix elements in det basis
    //calcMEdetpair(detlistI, detlistJ, orbI, orbJ, Isomo, Jsomo, ndetI, ndetJ, NMO, matelemdetbasis);
    calcMEdetpairGeneral(detlistI, detlistJ, orbI, orbJ, Isomo, Jsomo, ndetI, ndetJ, NMO, matelemdetbasis);

    //printRealMatrix(matelemdetbasis, ndetI, ndetJ);

    // Garbage collection
}
#+end_src

- [X] Transform the MEs in CSF basis

  Transform the bra and ket indices to CSF basis from DET basis. The traonsformation
  proceeds in two steps. In the first step, the DET basis is transformed to BF basis followed
  by the transformation of the BF basis to CSF basis. Each of the transformation is carried out
  using DGEMM calls.

#+name: getApqIJMatrix
#+begin_src C :main no :tangle cfgCI_utils.c :noweb yes

<<convertBFtoDetBasis>>

void getApqIJMatrixDims(int64_t Isomo, int64_t Jsomo, int64_t MS, int32_t *rowsout, int32_t *colsout){
    //printf("Enter in get ApqIJ Dim CSF basis\n");
    int NSOMOI=0;
    int NSOMOJ=0;
    //printf("Isomo=%ld Jsomo=%ld\n",Isomo,Jsomo);
    getSetBits(Isomo, &NSOMOI);
    getSetBits(Jsomo, &NSOMOJ);
    //printf("NsomoI=%d NsomoJ=%d\n",NSOMOI,NSOMOJ);
    int NBFI=0;
    int NBFJ=0;
    getncsfs(NSOMOI, MS, &NBFI);
    getncsfs(NSOMOJ, MS, &NBFJ);
    (*rowsout) = NBFI;
    (*colsout) = NBFJ;
    //printf("\t >> %d %d\n",NBFI,NBFJ);
}

void getApqIJMatrixDriver(int64_t Isomo, int64_t Jsomo, int orbp, int orbq, int64_t MS, int64_t NMO, double **CSFICSFJApqIJptr, int *rowsout, int *colsout){

    double *overlapMatrixI;
    double *overlapMatrixJ;
    double *orthoMatrixI;
    double *orthoMatrixJ;
    double *bftodetmatrixI;
    double *bftodetmatrixJ;
    double *ApqIJ;
    int NSOMO=0;

    /***********************************
                   Doing I
    ,************************************/
    // Fill matrix
    int rowsI = 0;
    int colsI = 0;

    getOverlapMatrix(Isomo, MS, &overlapMatrixI, &rowsI, &colsI, &NSOMO);

    //printf("\nDone Overlap Matrix I\n");
    //printRealMatrix(overlapMatrixI, rowsI, colsI);
    //printf("\nDone Overlap Matrix I\n");

    orthoMatrixI = malloc(rowsI*colsI*sizeof(double));

    gramSchmidt(overlapMatrixI, rowsI, colsI, orthoMatrixI);

    //printf("\nDone Gram-Schmidt orthonormalization I\n");
    //printRealMatrix(orthoMatrixI, rowsI, colsI);
    //printf("\nGen det basis I \n");

    int rowsbftodetI, colsbftodetI;

    convertBFtoDetBasis(Isomo, MS, &bftodetmatrixI, &rowsbftodetI, &colsbftodetI);

    printf("\nBF to det I\n");
    printRealMatrix(bftodetmatrixI, rowsbftodetI, colsbftodetI);
    printf("\nBF to det I\n");

    /***********************************
                   Doing J
    ,************************************/

    int rowsJ = 0;
    int colsJ = 0;
    // Fill matrix
    getOverlapMatrix(Jsomo, MS, &overlapMatrixJ, &rowsJ, &colsJ, &NSOMO);

    //printf("\nDone overlap J\n");
    //printRealMatrix(overlapMatrixJ, rowsJ, colsJ);
    //printf("\nDone overlap J\n");

    orthoMatrixJ = malloc(rowsJ*colsJ*sizeof(double));

    gramSchmidt(overlapMatrixJ, rowsJ, colsJ, orthoMatrixJ);

    //printf("\nDone Gram-Schmidt orthonormalization\n");
    //printRealMatrix(orthoMatrixJ, rowsJ, colsJ);
    //printf("\nDone Gram-Schmidt orthonormalization\n");


    int rowsbftodetJ, colsbftodetJ;

    convertBFtoDetBasis(Jsomo, MS, &bftodetmatrixJ, &rowsbftodetJ, &colsbftodetJ);

    //printf("dims BFtoDetJ rowsbftodetJ=%d colsbftodetJ=%d\n",rowsbftodetJ,colsbftodetJ);

    printf("\nGen det basis J \n");
    printRealMatrix(bftodetmatrixJ, rowsbftodetJ, colsbftodetJ);
    printf("\nGen det basis  J\n");

    int rowsA = 0;
    int colsA = 0;

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &ApqIJ, &rowsA, &colsA);

    printf("Done MEij\n");
    printRealMatrix(ApqIJ, rowsA, colsA);
    printf("Done MEij\n");

    // Final ME in BF basis

    // First transform I in bf basis
    double *bfIApqIJ = malloc(rowsbftodetI*colsA*sizeof(double));

    int transA=false;
    int transB=false;
    callBlasMatxMat(bftodetmatrixI, rowsbftodetI, colsbftodetI, ApqIJ, rowsA, colsA, bfIApqIJ, transA, transB);

    printf("Done blas BFI\n");
    printRealMatrix(bfIApqIJ, colsI, colsA);
    printf("Done blas BFI\n");

    // now transform I in csf basis
    double *CSFIApqIJ = malloc(rowsI*colsA*sizeof(double));
    transA = false;
    transB = false;
    callBlasMatxMat(orthoMatrixI, rowsI, colsI, bfIApqIJ, colsI, colsA, CSFIApqIJ, transA, transB);

    //printf("Done blas CSFI\n");
    //printRealMatrix(CSFIApqIJ, rowsI, colsA);
    //printf("Done blas CSFI\n");

    // now transform J in BF basis
    double *CSFIbfJApqIJ = malloc(rowsI*rowsbftodetJ*sizeof(double));
    //printf("rowsI = %d colsA=%d | rowsbftodetJ=%d colsbftodetJ=%d\n",rowsI,colsA,rowsbftodetJ,colsbftodetJ);
    transA = false;
    transB = true;
    callBlasMatxMat(CSFIApqIJ, rowsI, colsA, bftodetmatrixJ, rowsbftodetJ, colsbftodetJ, CSFIbfJApqIJ, transA, transB);

    //printf("Done blas BFJ\n");
    //printRealMatrix(CSFIbfJApqIJ, rowsI, rowsbftodetJ);
    //printf("Done blas BFJ\n");

    // now transform J in CSF basis
    (*CSFICSFJApqIJptr) = malloc(rowsI*rowsJ*sizeof(double));
    (*rowsout) = rowsI;
    (*colsout) = rowsJ;

    double *CSFICSFJApqIJ = (*CSFICSFJApqIJptr);
    transA = false;
    transB = true;
    callBlasMatxMat(CSFIbfJApqIJ, rowsI, rowsbftodetJ, orthoMatrixJ, rowsJ, colsJ, CSFICSFJApqIJ, transA, transB);

    //printf("ME CSF basis\n");
    //printRealMatrix(CSFICSFJApqIJ, rowsI, rowsJ);


    // Garbage collection
    free(overlapMatrixI);
    free(overlapMatrixJ);
    free(orthoMatrixI);
    free(orthoMatrixJ);
    free(bftodetmatrixI);
    free(bftodetmatrixJ);
    free(ApqIJ);
    free(bfIApqIJ);
    free(CSFIApqIJ);
    free(CSFIbfJApqIJ);
}

void getApqIJMatrixDriverArrayInp(int64_t Isomo, int64_t Jsomo, int32_t orbp, int32_t orbq, int64_t MS, int64_t NMO, double *CSFICSFJApqIJ, int32_t rowsmax, int32_t colsmax){

    double *overlapMatrixI;
    double *overlapMatrixJ;
    double *orthoMatrixI;
    double *orthoMatrixJ;
    double *bftodetmatrixI;
    double *bftodetmatrixJ;
    double *ApqIJ;
    int NSOMO=0;

    /***********************************
                   Doing I
    ,************************************/
    // Fill matrix
    int rowsI = 0;
    int colsI = 0;

    getOverlapMatrix(Isomo, MS, &overlapMatrixI, &rowsI, &colsI, &NSOMO);

    //printf("\nIsomo=%ld MS=%ld NSOMO=%d (%d,%d)\n",Isomo,MS,NSOMO, rowsI, colsI);
    //printf("\nDone Overlap Matrix I\n");
    //printRealMatrix(overlapMatrixI, rowsI, colsI);
    //printf("\nDone Overlap Matrix I\n");

    orthoMatrixI = malloc(rowsI*colsI*sizeof(double));

    gramSchmidt(overlapMatrixI, rowsI, colsI, orthoMatrixI);

    //printf("\nDone Gram-Schmidt orthonormalization I\n");
    //printRealMatrix(orthoMatrixI, rowsI, colsI);
    //printf("\nGen det basis I \n");

    int rowsbftodetI, colsbftodetI;

    convertBFtoDetBasis(Isomo, MS, &bftodetmatrixI, &rowsbftodetI, &colsbftodetI);

    //printf("\nBF to det I\n");
    //printRealMatrix(bftodetmatrixI, rowsbftodetI, colsbftodetI);
    //printf("\nBF to det I\n");

    /***********************************
                   Doing J
    ,************************************/

    int rowsJ = 0;
    int colsJ = 0;
    // Fill matrix
    getOverlapMatrix(Jsomo, MS, &overlapMatrixJ, &rowsJ, &colsJ, &NSOMO);

    //printf("\nDone overlap J\n");
    //printRealMatrix(overlapMatrixJ, rowsJ, colsJ);
    //printf("\nDone overlap J\n");

    orthoMatrixJ = malloc(rowsJ*colsJ*sizeof(double));

    gramSchmidt(overlapMatrixJ, rowsJ, colsJ, orthoMatrixJ);

    //printf("\nDone Gram-Schmidt orthonormalization\n");
    //printRealMatrix(orthoMatrixJ, rowsJ, colsJ);
    //printf("\nDone Gram-Schmidt orthonormalization\n");


    int rowsbftodetJ, colsbftodetJ;

    convertBFtoDetBasis(Jsomo, MS, &bftodetmatrixJ, &rowsbftodetJ, &colsbftodetJ);

    //printf("dims BFtoDetJ rowsbftodetJ=%d colsbftodetJ=%d\n",rowsbftodetJ,colsbftodetJ);

    //printf("\nGen det basis J \n");
    //printRealMatrix(bftodetmatrixJ, rowsbftodetJ, colsbftodetJ);
    //printf("\nGen det basis  J\n");

    int rowsA = 0;
    int colsA = 0;

    callcalcMEij(Isomo, Jsomo, orbp, orbq, MS, NMO, &ApqIJ, &rowsA, &colsA);

    //printf("rowsA = %d colsA = %d\n");
    //printf("Done MEij\n");
    //printRealMatrix(ApqIJ, rowsA, colsA);
    //printf("Done MEij\n");

    // Final ME in BF basis

    // First transform I in bf basis
    double *bfIApqIJ = malloc(rowsbftodetI*colsA*sizeof(double));

    int transA=false;
    int transB=false;
    callBlasMatxMat(bftodetmatrixI, rowsbftodetI, colsbftodetI, ApqIJ, rowsA, colsA, bfIApqIJ, transA, transB);

    //printf("Done blas BFI\n");
    //printRealMatrix(bfIApqIJ, colsI, colsA);

    // now transform I in csf basis
    double *CSFIApqIJ = malloc(rowsI*colsA*sizeof(double));
    transA = false;
    transB = false;
    callBlasMatxMat(orthoMatrixI, rowsI, colsI, bfIApqIJ, colsI, colsA, CSFIApqIJ, transA, transB);

    //printf("Done blas CSFI\n");
    //printRealMatrix(CSFIApqIJ, rowsI, colsA);
    //printf("Done blas CSFI\n");

    // now transform J in BF basis
    double *CSFIbfJApqIJ = malloc(rowsI*rowsbftodetJ*sizeof(double));
    //printf("rowsI = %d colsA=%d | rowsbftodetJ=%d colsbftodetJ=%d\n",rowsI,colsA,rowsbftodetJ,colsbftodetJ);
    transA = false;
    transB = true;
    callBlasMatxMat(CSFIApqIJ, rowsI, colsA, bftodetmatrixJ, rowsbftodetJ, colsbftodetJ, CSFIbfJApqIJ, transA, transB);

    //printf("Done blas BFJ\n");
    //printRealMatrix(CSFIbfJApqIJ, rowsI, rowsbftodetJ);
    //printf("Done blas BFJ\n");

    // now transform J in CSF basis
    //(*CSFICSFJApqIJptr) = malloc(rowsI*rowsJ*sizeof(double));
    //(*rowsout) = rowsI;
    //(*colsout) = rowsJ;

    double *tmpCSFICSFJApqIJ = malloc(rowsI*rowsJ*sizeof(double));
    transA = false;
    transB = true;
    callBlasMatxMat(CSFIbfJApqIJ, rowsI, rowsbftodetJ, orthoMatrixJ, rowsJ, colsJ, tmpCSFICSFJApqIJ, transA, transB);

    // Transfer to actual buffer in Fortran order
    for(int i = 0; i < rowsI; i++)
        for(int j = 0; j < rowsJ; j++)
            CSFICSFJApqIJ[j*14 + i] = tmpCSFICSFJApqIJ[i*rowsJ + j];


    //printf("ME CSF basis\n");
    //printRealMatrix(CSFICSFJApqIJ, 14, 14);
    //printf("End in get ApqIJ ME CSF basis\n");


    // Garbage collection
    free(overlapMatrixI);
    free(overlapMatrixJ);
    free(orthoMatrixI);
    free(orthoMatrixJ);
    free(bftodetmatrixI);
    free(bftodetmatrixJ);
    free(ApqIJ);
    free(bfIApqIJ);
    free(CSFIApqIJ);
    free(CSFIbfJApqIJ);
    free(tmpCSFICSFJApqIJ);
}
#+end_src

#+RESULTS: getApqIJMatrix

#+end_src

*** TODO [1/4] Table of matrix-elements

The first step twoards the evaluation of MEs between bonded-functions is
the tabulation of the effect of the application of the operator on BFs.

There are four type of cases depending on the type of orbitals for the excitaton
i.e. for \(\hat{E}_{ji}\), the type of orbitals possible for \(i\) are DOMO or
SOMO and the type of orbitals possible for \(j\) are SOMO or VMO respectively.
The table of MEs will be different in each case

Here is a table which lists the action of E_{j,i} on all the various
cases of BFs that can arise.

- [ ] SOMO -> VMO type

  This is the simplest type. The \(i\) th SOMO is simply replaced
  by the \(j\) th one.

#+name: SOMO -> VMO
| BF (ket) | Type | Operator         | BF (bra) |
|          |      | \(\hat{E}_{ji}\) |          |
|          |      |                  |          |
| (i       | C-C  | \(1\)            | (j       |
|          |      |                  |          |

- [X] SOMO -> SOMO type

This is slightly involved depending on the type of SOMO \(i\)
and type of SOMO \(j\) and to which islands they belong to.

#+name: SOMO -> SOMO
|   | BF (ket)    | Type | Operator                | BF (bra) |
|   |             |      | \(\hat{E}_{ji}\)        |          |
|   |             |      |                         |          |
| 1 | (i j)       | C-C  | \(\sqrt{2}\)            | -        |
| 2 | (i k) (j l) | C-C' | \(-\frac{1}{\sqrt{2}}\) | (kl)     |
| 3 | (i k) (j    | C-O  | \(-\frac{1}{\sqrt{2}}\) | (k       |
| 4 | (i (j k)    | O-C  | \(-\frac{1}{\sqrt{2}}\) | (k       |
| 5 | (i (j       | O-C  | \(0\)                   | -        |

- [ ] DOMO -> VMO

  Here two extra SOMOs will be created and the MEs of
  the operator will form a rectangular matrix.

#+name: DOMO -> SOMO
| BF (ket) | Type | Operator         | BF (bra)   |
|          |      | \(\hat{E}_{ji}\) |            |
|          |      |                  |            |
| (ii)     | O    | \(\sqrt{2}\)     | (i j)      |
| (ii)     | C    | \(0\)            | (i k)(j l) |
|          |      |                  |            |

- [ ] DOMO -> SOMO

  Here the total number of SOMOs is kept the same therefore,
  there is no change in the BFs for bra and ket functions.

#+name: DOMO -> SOMO
| BF (ket) | Type | Operator         | BF (bra) |
|          |      | \(\hat{E}_{ji}\) |          |
|          |      |                  |          |
| (ii      | O    | \( 1\)           | (j       |
| (i k)    | C    | \(-1\)           | (j k)    |
|          |      |                  |          |

** TODO [0/4] Calculate the Operator MEs

The operator matrix-elements are calculated using the bonded-function (or
determinant) basis and are called \( A^{pq}_{IK} \), where \(p,q\) are the two
molecular orbital indices and \(I,K\) are the two CFGs.

Note that this function simply returns the value from a prototype lookup table
which contains the pretabulated values for a given \(p,q\) excitation of a
specified type which is one of the four:

1. SOMO \(->\) VMO
2. SOMO \(->\) SOMO
3. DOMO \(->\) VMO
4. DOMO \(->\) SOMO




- [ ] SOMO -> VMO type

  This case is the simplest and there is only one
  non-vanising ME as shown in Table:[[SOMO -> VMO]].
  Therefore, the one-electron operator MEs are
  that of the identity matrix.

- [ ] SOMO -> SOMO type

  The MEs for the various types are given in Table:[[SOMO -> SOMO]].
  Here we implement the rules.

#+name: calculateMETypeSOMOSOMO
#+begin_src C :main no :tangle cfgCI_utils.c
void calculateMETypeSOMOSOMO(int *BF1, int *BF2, int moi, int moj, double *factor, int *phasefactor){

    // Calculate the factor following rules in the table
    // find the type

    if(BF1[moi] == moj){
        // Type I
        (*factor) = sqrt(2.0);
        (*phasefactor) = 1;
    }
    else{
        if(BF1[moi] != moi || BF1[moj] != moj){
            // Type II, III and IV
            (*factor) = 1.0/sqrt(2.0);
            (*phasefactor) =-1;
        }
        else{
            // Type V
            (*factor) = 0.0;
            (*phasefactor) = 1;
        }
    }


}
#+end_src

#+name: getOneElMETypeSOMOSOMO
#+begin_src C :main no
void getOneElMETypeSOMOSOMO(int64_t Isomo, int64_t Jsomo, int moi, int moj, int MS, double **oneElMatrixElementsptr, int *rows, int *cols){

    // Icfg

    int64_t INBF = 0;
    int64_t INSOMO = 0;

    Tree Ibftree = (Tree){  .rootNode = NULL, .NBF = -1 };
    Ibftree.rootNode = malloc(sizeof(Node));
    (*Ibftree.rootNode) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = NULL, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Isomo, MS, &Ibftree, &INBF, &INSOMO);

    // Jcfg

    int64_t JNBF = 0;
    int64_t JNSOMO = 0;

    Tree Jbftree = (Tree){  .rootNode = NULL, .NBF = -1 };
    Jbftree.rootNode = malloc(sizeof(Node));
    (*Jbftree.rootNode) = (Node){ .C0 = NULL, .C1 = NULL, .PREV = NULL, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Jsomo, MS, &Jbftree, &JNBF, &JNSOMO);


    // Initialize orthonormalization matrix

    (*oneElMatrixElementsptr) = malloc(INBF*JNBF*sizeof(double));
    (*rows) = INBF;
    (*cols) = JNBF;

    double *oneElMatrixElements = (*oneElMatrixElementsptr);

    // Calculate Matrix

    int addI = 0;
    int addJ = 0;
    int *BF1 = malloc(MAX_SOMO * sizeof(int));
    int *BF2 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF1 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF2 = malloc(MAX_SOMO * sizeof(int));

    int g = 0;
    g = (INSOMO - MS)/2;
    printf("NBFs = %ld NSOMOs = %ld MS = %ld g = %d\n",INBF,INSOMO,MS,g);

    int nislands; // Note that nislands < g always
    int phasefactor;
    double factor;
    nislands = 0;
    phasefactor = 1;
    factor = 0.0;

    int dictPhase[2];

    dictPhase[0] = 1;
    dictPhase[1] =-1;


    // Set block elements
    for(int i = 0; i < INBF; i++){
        addI = i;
        getIthBFDriver(&Ibftree, INSOMO, addI, BF1);
        getBFIndexList(INSOMO, BF1, IdxListBF1);

        //printf("addI : %d > ",addI);
        //for(int k=0;k<NSOMO;k++)
        //    printf("%d ",BF1[k]);
        //printf("\n");

        for(int j = 0; j < JNBF; j++){
            addJ = j;
            getIthBFDriver(&Jbftree, JNSOMO, addJ, BF2);
            getBFIndexList(JNSOMO, BF2, IdxListBF2);
            //printf("addJ : %d > ",addI);
            //for(int k=0;k<NSOMO;k++)
            //    printf("%d ",BF2[k]);
            //printf("\n");

            // Get the i and r factors
            calculateMETypeSOMOSOMO(IdxListBF1, IdxListBF2, moi, moj, &factor, &phasefactor);

            //printf("(%d, %d) is=%d ph=%d fac=%10.15f\n",addI, addJ, nislands, phasefactor, phasefactor*1.0/(1 << (g-nislands)));

            oneElMatrixElements[i*INBF + j] = -1.0*phasefactor*factor;
        }
    }

    // Garbage collection
    free(BF1);
    free(IdxListBF1);
    free(BF2);
    free(IdxListBF2);
}
#+end_src

#+RESULTS: METypeSOMOSOMO

- [ ] DOMO -> VMO type

- [ ] DOMO -> SOMO type

- [ ] Testing


#+begin_src C :main no :noweb yes
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include "tree_utils.h"

<<inttobindigit>>

<<treefuncmain>>

<<indexlist>>

<<calculateislands>>

<<getNsomo>>

<<generateAllBFs>>

<<getOrthoMatrix>>

<<calculateMETypeSOMOSOMO>>

<<getOneElMETypeSOMOSOMO>>

void main(){

    int rows = 0;
    int cols = 0;
    double *oneElMatrixElementsptr;

    int64_t MS=0;

    int64_t Isomo;
    Isomo = (1 << 8) - 1;

    int64_t Jsomo;
    Jsomo = (1 << 6) - 1;

    int moi = 6;
    int moj = 7;

    //int digit[MAX_SOMO];
    //int_to_bin_digit(Isomo, MAX_SOMO, digit);
    //for(int j=0;j<MAX_SOMO;j++)
    //    printf("%d ",digit[j]);
    //printf("\n");

    // Fill matrix
    getOneElMETypeSOMOSOMO(Isomo, Jsomo, moi, moj, MS, &oneElMatrixElementsptr, &rows, &cols);

    printRealMatrix(oneElMatrixElementsptr, rows, cols);

    // Garbage collection
    free(oneElMatrixElementsptr);

    return;
}
#+end_src

#+RESULTS:


#+name: getOneElOperatorMatrix
#+begin_src c
void getOneElOperatorMatrix(int *cfgI, int *cfgK);
#+end_src

** Sigma-Vector I

The one-electron part \( \sum_{pq} \tilde{h}_{pq} <\Psi|\hat{E}_{pq}|\Psi>\).

** Sigma-Vector II

The two-electron part \(\frac{1}{2} \sum_{pq,rs} g(pq,rs) <\Psi|\hat{E}_{pq}\hat{E}_{rs}|\Psi> \)

*** Function to calculate Sigma-Vector

#+name: calcSigmaFunction
#+begin_src c :results output
void calcSigma(double *coeff, double *Gpqrs){
}
#+end_src

* Bibliography

bibliography:biblio.org
