# -*- mode:org -*-
#+TITLE: Theory CFGCI
#+AUTHOR: Vijay Gopal Chilkuri
#+EMAIL: vijay.gopal.c@gmail.com
#+OPTIONS: toc:t
#+LATEX_CLASS: article
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{braket}
#+LATEX_HEADER: \usepackage{minted}

* Introduction

There are three main aspects while using configuration based representation

* Algorithms

*** Small function to convert int to bit

Convert input CFG to an array of bits containing 0's and 1's representing
the position of SOMOs and DOMOs.

#+name: inttobindigit
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdint.h>

void int_to_bin_digit(int64_t in, int count, int* out)
{
    /* assert: count <= sizeof(int)*CHAR_BIT */
    unsigned int mask = 1U << (count-1);
    int i;
    for (i = 0; i < count; i++) {
        out[i] = (in & mask) ? 1 : 0;
        in <<= 1;
    }
}

void printRealMatrix(double *orthoMatrix, int rows, int cols){

    for(int i = 0; i < rows; i++){
        printf("\n");
        for(int j = 0; j < cols; j++){
            printf("%10.15f ",orthoMatrix[i*rows + j]);
        }
    }
}
#+end_src


*** Get number of CSFs

#+name: getncsfs
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>
#include <stdint.h>
#include <math.h>

inline double logbinom(double n, double k) {
    return lgamma(n+1)-lgamma(n-k+1)-lgamma(k+1);
}
inline double binom(double n, double k) {
    return exp(logbinom(n,k));
}

void getncsfs(int *inpnsomo, int *inpms, int *outncsfs){
    int nsomo = *inpnsomo;
    int ms = *inpms;
    int nparcoupl = (nsomo + ms)/2;
    *outncsfs = binom(nsomo, nparcoupl);
}
#+end_src

** TODO [2/2] Print all CFGs

The only input required is the selected list of CFGs at a given CIPSI iteration \( I \).

- [X] Fortran module

  #+begin_src fortran :main no :tangle cfgCI_interface.f90
      module cfunctions
      use, intrinsic :: ISO_C_BINDING
      interface
         subroutine printcfglist(nint, ncfgs, cfglist) bind(C, name='printCFGList')
         import C_INT32_T, C_INT64_T
         integer(kind=C_INT32_T) :: nint
         integer(kind=C_INT32_T) :: ncfgs
         integer(kind=C_INT64_T) :: cfglist(nint,2,ncfgs)
         end subroutine printcfglist
      end interface
      end module cfunctions
  #+end_src


- [X] C function

#+name: printCFGlist
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>
#include <stdint.h>
#include "tree_utils.h"

void printCFGList(int32_t *inpNint, int32_t *inpNcfgs, int64_t *cfglist){
    int Ncfgs    = *inpNcfgs;
    int N_int    = *inpNint;
    int digit[MAX_SOMO];
    int64_t cfg1,cfg2;
    int nsomo=4;
    int ms=0;
    int ncsfs=0;
    printf("In 64 printcfglist\n");
    printf("Ncfgs = %d Nint=%d\n",Ncfgs, N_int);
    printf(" 1-- %d \n -- %d \n",cfglist[0*(2*Ncfgs) + 0*(Ncfgs) + 0], cfglist[0*(2*Ncfgs) + 1*(Ncfgs) + 0]);
    for(int i = 0; i < 15; i++){
        cfg1 = cfglist[1 + i*2];
        printf("%d> domo=%d somo=%d\n",i,cfg1,cfg2);
        int_to_bin_digit(cfg1,18,digit);
        for(int j=0;j<18;j++)
            printf("%d ",digit[j]);
        printf("\n");
    }
    getncsfs(&nsomo,&ms,&ncsfs);
    printf("Nsomos = %d\n",ncsfs);
}
#+end_src

** Generate BFs for a given number of SOMOs

A BF is represented as an integer. The bit representation of the integer (0 or 1) indicates the pairs. The BFs can be generated using the following rules:

1. A pair is represented by (0 1) with 0 indicating the left most index.

2. The right most 0 is linked with the left most 1.

This code generates all the bonded functions for a given number of SOMOs.

**** TODO [3/3] Algorithm

Here we describe how we generate the Bonded functions as shown in the example below.

#+begin_example
SOMO: [ 1 1 1 1 1] Ms = 1
BF list:
[[0 0 0 1 1]
 [0 0 1 0 1]
 [0 1 0 0 1]
 [0 0 1 1 0]
 [0 1 0 1 0]]
#+end_example

Basically, we use a binary tree to generate all the valid BFs.



- [X] Tree node data structure

The tree is built of a simple node which contains two links each for the two children \(C0, C1\) belonging to either a parallel \(0\)
or an anti-parallel \(1\) coupling. The address ~addr~ of all intermediate nodes is -1 and the address of the leaf node is the id of the BF
associated with the path traversed upon going back from the leaf to the root node using ~PREV~ pointer.

#+name: nodedef
#+begin_src c :main no :tangle tree_utils.h
typedef struct bin_node Node;
typedef struct bin_tree Tree;
struct bin_node {
    Node *C0;
    Node *C1;
    Node *PREV;
    int addr;
    int cpl;
    int iSOMO;
};

struct bin_tree {
    Node *rootNode;
    int NBF;
};
#+end_src

- [X] Build Tree

  The algorithm for building the tree is very simple, the tree is constructed using two rules:

  1. The total number of 0's cannot be larger than ~zeromax~
  2. The total number of 1's cannot be smaller than ~onemin~

#+name: treefuncdefs
#+begin_src c :main no :tangle tree_utils.h

#define MAX_SOMO 32

void buildTreeDriver(Tree *bftree, int NSOMO, int MS, int *NBF);

void buildTree(Tree *bftree, Node **inode, int isomo, int izeros, int icpl, int NSOMOMax, int MSmax);

void printTreeDriver(Tree *bftree, int NSOMOMax);
void printTree(Node *bftree, int isomo, int NSOMOMax, int *vecBF);

void getIthBF(Node *node, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF);
void getIthBFDriver(Tree *bftree, int NSOMOMax, int getaddr, int *vecBF);

void getBFIndexList(int NSOMO, int *BF1, int *IdxListBF1);
void getIslands(int NSOMO, int *BF1, int *BF2, int *nislands, int *phasefactor);

void generateAllBFs(int64_t Isomo, int64_t MS, Tree *bftree, int *NBF, int *NSOMO);
void getSetBits(int64_t n, int *nsetbits);
void getOrthoMatrix(int64_t Isomo, int64_t MS, double **orthoMatrixptr, int *rows, int *cols);


// Misc utils
void int_to_bin_digit(int64_t in, int count, int* out);
void printRealMatrix(double *orthoMatrix, int rows, int cols);
#+end_src

#+name: treefuncmain
#+begin_src c :main no :tangle tree_utils.c
void buildTree(Tree *bftree,
               Node **inode,
               int isomo,
               int izeros,
               int icpl,
               int NSOMOMax,
               int MSmax){

    // Find the maximum parallel couplings 0
    //      the maximum anti-parallel couplings 1
    int zeromax = MSmax + (NSOMOMax-MSmax)/2;
    int onemax = NSOMOMax - zeromax;

    // Exit condition
    if(isomo > NSOMOMax || icpl < 0 || izeros > zeromax ) return;

    // If we find a valid BF assign its address
    if(isomo == NSOMOMax){
        (*inode)->addr = bftree->rootNode->addr;
        bftree->rootNode->addr += 1;
        return;
    }

    // Call 0 branch
    if(((*inode)->C0) == -1 && izeros+1 <= zeromax){
        ((*inode)->C0) = malloc(sizeof(Node));
        (*(*inode)->C0) = (Node){ .C0 = -1, .C1 = -1, .PREV = *inode, .addr = -1, .cpl = 0, .iSOMO = isomo };
        buildTree(bftree, &(*inode)->C0, isomo+1, izeros+1, icpl+1, NSOMOMax, MSmax);
    }
    else buildTree(bftree, &(*inode)->C0, isomo+1, izeros+1, icpl+1, NSOMOMax, MSmax);

    // Call 1 branch
    if(((*inode)->C1) == -1 && icpl-1 >= 0){
        ((*inode)->C1) = malloc(sizeof(Node));
        (*(*inode)->C1) = (Node){ .C0 = -1, .C1 = -1, .PREV = *inode, .addr = -1, .cpl = 1, .iSOMO = isomo };
        buildTree(bftree, &(*inode)->C1, isomo+1, izeros+0, icpl-1, NSOMOMax, MSmax);
    }
    else buildTree(bftree, &(*inode)->C1, isomo+1, izeros+0, icpl-1, NSOMOMax, MSmax);

    return;
}

void buildTreeDriver(Tree *bftree, int NSOMO, int MS, int *NBF){
    int isomo = 0; // counts the total number of SOMO's
    int izeros= 0; // Counts the total number of parallel coupings (i.e. 0's)
    int icpl  = 0; // keep track of the ith ms (cannot be -ve)
    int addr  = 0; // Counts the total BF's

    buildTree(bftree, &(bftree->rootNode), isomo, izeros, icpl, NSOMO, MS);

    ,*NBF = bftree->rootNode->addr;
}

void printTree(Node *inode, int isomo, int NSOMOMax, int *vecBF){
    // Exit condition
    if(isomo > NSOMOMax) return;
    if(inode == -1) return;

    if(isomo == NSOMOMax){
        printf("add : %d > ",inode->addr);
        for(int i=0;i<NSOMOMax;i++)
            printf("%d ",vecBF[i]);
        printf("\n");
        return;
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(inode),inode->C1);


    // Recurse to C0
    if(inode->C0 != -1){
        vecBF[isomo] = 0;
        printTree(inode->C0, isomo+1, NSOMOMax, vecBF);
    }
    // Recurse to C1
    if(inode->C1 != -1){
        vecBF[isomo] = 1;
        printTree(inode->C1, isomo+1, NSOMOMax, vecBF);
    }

    return;
}

void printTreeDriver(Tree *bftree, int NSOMOMax){
    int isomo = 0;
    int vecBF[NSOMOMax];
    for(int i=0;i<NSOMOMax;i++)
        vecBF[i]=0;
    printTree((bftree->rootNode), isomo, NSOMOMax, vecBF);
}

void getIthBF(Node *inode, int isomo, bool foundBF, int NSOMOMax, int getaddr, int *vecBF){
    // Exit condition
    if(foundBF) return;
    if(isomo > NSOMOMax) return;
    if(inode == -1) return;

    if(isomo == NSOMOMax){
        if(inode->addr == getaddr){
            for(int i = NSOMOMax-1; i > -1; i--){
                vecBF[i] = inode->cpl;
                inode = inode->PREV;
            }
            foundBF = true;
            return;
        }
    }
    //printf("%d | %d (%d)\n",isomo,sizeof(inode),inode->C1);


    // Recurse to C0
    if(inode->C0 != -1){
        getIthBF(inode->C0, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }
    // Recurse to C1
    if(inode->C1 != -1){
        getIthBF(inode->C1, isomo+1, foundBF, NSOMOMax, getaddr, vecBF);
    }

    return;
}

void getIthBFDriver(Tree *bftree, int NSOMOMax, int getaddr, int *vecBF){
    int isomo = 0;
    bool foundBF = false;
    getIthBF((bftree->rootNode), isomo, foundBF, NSOMOMax, getaddr, vecBF);
}
#+end_src

- [X] Test Build BF

#+begin_src C :main no :noweb yes
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "/home/vijay/Documents/codes/qp2/plugins/local/pluginRepo/cfgCI/tree_utils.h"

<<treefuncmain>>

<<indexlist>>

<<calculateislands>>

void main(){
    int NSOMO = 6;
    int MS = 0;
    int NBF=0;
    Tree bftree = (Tree){  .rootNode = -1, .NBF = -1 };
    bftree.rootNode = malloc(sizeof(Node));
    (*bftree.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    buildTreeDriver(&bftree, NSOMO, MS, &NBF);

    //printTreeDriver(&bftree, NSOMO);

    int *BF1 = malloc(NSOMO * sizeof(int));
    int *BF2 = malloc(NSOMO * sizeof(int));

    int getaddr = 0;
    getIthBFDriver(&bftree, NSOMO, getaddr, BF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",BF1[i]);
    printf("\n");

    getaddr = 1;
    getIthBFDriver(&bftree, NSOMO, getaddr, BF2);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",BF2[i]);
    printf("\n");

    int *IdxListBF1 = malloc(NSOMO * sizeof(int));
    getBFIndexList(NSOMO, BF1, IdxListBF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",IdxListBF1[i]);
    printf("\n");

    getBFIndexList(NSOMO, BF2, IdxListBF1);

    printf("add : %d > ",getaddr);
    for(int i=0;i<NSOMO;i++)
        printf("%d ",IdxListBF1[i]);
    printf("\n");

    int nislands;
    int phasefactor;

    getIslands(NSOMO, BF1, BF2, &nislands, &phasefactor);
    printf("nislands = %d phase = %d\n",nislands,phasefactor);


    // Garbage collection
    free(BF1);
    free(BF2);
    free(IdxListBF1);

    return;
}
#+end_src

#+RESULTS:
| add      | : | 0 | >     | 0 | 0 | 0 | 1 | 1 | 1 |
| add      | : | 1 | >     | 0 | 0 | 1 | 0 | 1 | 1 |
| add      | : | 1 | >     | 5 | 4 | 3 | 2 | 1 | 0 |
| add      | : | 1 | >     | 5 | 2 | 1 | 4 | 3 | 0 |
| nislands | = | 2 | phase | = | 1 |   |   |   |   |


** Calculate the orthogonalization matrix

The orthogonalization matrix gives the orthonormalized vectors
in bonded-function (BF) (or determinant) basis which are eigenfunctions
of \( S^2 \) c.f. \( \mathbf{O}_{i}\) matrices.

*** Calculate Overlap between two BFs

In our representation, the BFs are represented as a seqence of \(0,1\)
as shown below:

#+begin_example
BF1 : [0 0 0 1 1] Ms = 1
      (1 (1 (2 3) 4)
#+end_example

The second representation is only used to derive the overlap/matrix-elements.

The overlap between two bonded functions is based on the derivations
by Cooper and McWeeney[?] and Sutcliffe[?]. They are based on Rumer
diagrams. Here, we shall briefly outline the algorithm for the
calculation of the overlap between two BFs.

In order to calculate the Overlap (\( S \)) between two bonded functions
\( V_r \) and \(V_s\), there are two steps which are as follows:

1. Permutations of the strings to bring \(V_r, V_s\) into maximum overlap
   configuration. This incurs a phase (\(-1\) for each permutation) \((-1)^r\).

2. The calculation of the number of Islands (\(i\)), the number of Open chains (\(O\)),
   and the number of E chains.

The description of the three types of diagrams is described below:

**** TODO [2/2] Islands

Once the two BFs are brought into maximum overlap, the number of islands can be
calculated. An island is defined as the total number of closed polygons formed
by joining the common indices in \(V_r\) and \(V_s\). The pairs in each BF
\(V_r\) and \(V_s\) are also joind by an arc. Each island has two primitive
spin-functions. A primitive spin-function is defined as a product of
\(\alpha-\beta\) pair in the two BFs. The two primitives originate from
assigning \(\alpha\) or \(\beta\) to the head and tail of the closed polygon or
vice-versa.

#+begin_example
      ------------------------------------
      |    --------------------------    |
      |    |    ----------------    |    |
      |    |    |    ------    |    |    |
      |    |    |    |   \ /  \ /  \ /  \ /
BF1 : 0    0    0    0    1    1    1    1
      |    |    |    |    |    |    |    |
BF2 : 0    1    0    0    0    1    1    1
      |   / \   |    |    |   / \  / \  / \
      ------    |    |    ------    |    |
                |    ----------------    |
                --------------------------
#+end_example

- [X] Get Index list

#+name: indexlist
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>

void getBFIndexList(int NSOMO, int *BF1, int *IdxListBF1){
    int Iidx;
    int Jidx;
    int BFcopy[NSOMO];

    int dictidx[2];
    dictidx[0] = -1;
    dictidx[1] =  1;

    for(int i = 0; i < NSOMO; i++)
        BFcopy[i] = BF1[i];

    for(int i = 0; i < NSOMO; i++){
        Iidx = i;
        if(BFcopy[i] == 0){
            int countN1=0;
            for(int j = i+1; j < NSOMO; j++){
                Jidx = j;
                countN1 = countN1 + dictidx[BFcopy[j]];
                if(countN1 > 0){
                    break;
                }
            }
            BFcopy[Iidx] = -1;
            BFcopy[Jidx] = -1;
            IdxListBF1[Jidx] = Iidx;
            IdxListBF1[Iidx] = Jidx;
        }
    }

}
#+end_src

- [X] Get Islands


#+name: calculateIslands
#+begin_src c :main no :tangle cfgCI_utils.c
#include <stdio.h>

void getIslands(int NSOMO, int *BF1, int *BF2, int *nislands, int *phasefactor){

    // Get BF ids
    int *IdxListBF1 = malloc(NSOMO * sizeof(int));
    int *IdxListBF2 = malloc(NSOMO * sizeof(int));

    getBFIndexList(NSOMO, BF1, IdxListBF1);
    getBFIndexList(NSOMO, BF2, IdxListBF2);

    int maxcount=0;
    ,*nislands = 0;
    ,*phasefactor = 1;

    int BF1copy[NSOMO];
    for(int i = 0; i < NSOMO; i++)
        BF1copy[i] = IdxListBF1[i];
    int BF2copy[NSOMO];
    for(int i = 0; i < NSOMO; i++)
        BF2copy[i] = IdxListBF2[i];

    for(int i = 0; i < NSOMO; i++){
        int thisId = i;
        int nextId = BF1copy[i];
        maxcount = 0;
        while(BF1copy[thisId] != -1 && maxcount < 20){
            if(maxcount==0) *nislands += 1;
            if(maxcount==19) *nislands -= 1;

            maxcount++;

            // First the bra
            nextId = BF1copy[thisId];
            BF1copy[thisId] = -1;
            BF1copy[nextId] = -1;
            //printf("\n(%d) %d> %d -> %d\n",i,maxcount,thisId,nextId);

            // Get the phase factor bra
            if(nextId < thisId) *phasefactor *= -1;

            // Then the ket
            thisId = BF2copy[nextId];
            BF2copy[thisId] = -1;
            BF2copy[nextId] = -1;
            //printf("\n(%d) %d> %d -> %d\n",i,maxcount,nextId,thisId);

            // Get the phase factor bra
            if(nextId > thisId) *phasefactor *= -1;

        }
        //printf("\nBF1\n");
        //for(int j = 0; j < NSOMO; j++)
        //    printf("%d ",BF1copy[j]);
        //printf("\nBF2\n");
        //for(int j = 0; j < NSOMO; j++)
        //    printf("%d ",BF2copy[j]);
    }

    // Garbage collection
    free(IdxListBF1);
    free(IdxListBF2);

}
#+end_src



**** Phase factor (r)

The phase factor is calculated according to the following rule. The connecting
lines shown in example above has a direction. Upon careful observation, one can
observe that out of the eight SOMOs 6 are aligned i.e. both bra and ket have arrows
or tails and 2 are misaligned. The phase \(r\) is defined as the minimum number of
flips required to pair all indices for the bra and ket indices. In the above example
three arrow directions have to be flipped giving \(r=3\) as shown below:

#+begin_example
      ------------------------------------
      |    --------------------------    |
      |    |    ----------------    |    |
      |    |    |    ------    |    |    |
      |   \ /   |   \ /   |   \ /   |   \ /
BF1 : 0    0    0    0    1    1    1    1
      |    |    |    |    |    |    |    |
BF2 : 0    1    0    0    0    1    1    1
      |   / \   |   / \   |   / \   |   / \
      ------    |    |    ------    |    |
                |    ----------------    |
                --------------------------
#+end_example

#+name: illustration islands
#+ATTR_ORG: :width 400
[[./illustration_islands.jpg]]

**** Open chains (O)

The open chains are constituted of open polygons which have an odd number of
sides. These are made up of BFs which consist of un-paired spins such as
\(2^{-1/2} \left[ \alpha(i)\beta(j) + \alpha(j)\beta(i) \right]\alpha(k) \) for
\(V_r\) and \(\alpha(i)-2^{-1/2} \left[ \alpha(j)\beta(k) + \alpha(k)\beta(j)
\right]\) for \(V_s\) respectively. These contribute a factor of \(1\) to the
MEs.

**** E type chains

The E type chains originate from BFs which contain different indices which are
mutually exclusive. The presence of mutually exclusive indices results in a
vanishing ME between such BFs.


Finally, the BFs contribute to the ME as follows:

#+name: EqCalcOvlp
\(
\braket{V_r | V_s} = \delta_{SS'}\delta_{E} 2^{i-s}(-1)^r
\)

Where \( S \) and \( S' \) are the spins for the \(V_r\) and \(V_s\)
respectively and \(s\) represents the total number of pairs in \(V_r\) and
\(V_s\). The total number of pairs are the same in \(V_r\) and \(V_s\) if they
belong to the same spin subspace.

**** TODO [1/4] Make the orthonormalization matrix

- [X] Calculate the number of SOMOs in the input CFG.

#+name: getNsomo
#+begin_src C :main no :tangle cfgCI_utils.c
void getSetBits(int64_t n, int *nsetbits){
    int count = 0;
    while(n){
        count += n & 1;
        n >>= 1;
    }
    *nsetbits = count;
}
#+end_src

- [ ] Generate all the BF for the SOMOs in the CFG

#+name: generateAllBFs
#+begin_src C :main no :tangle cfgCI_utils.c
void generateAllBFs(int64_t Isomo, int64_t MS, Tree *bftree, int *NBF, int *NSOMO){
    getSetBits(Isomo, NSOMO);
    buildTreeDriver(bftree, *NSOMO, MS, NBF);
}
#+end_src

- [ ] Fill the matrix using Eq:[[EqCalcOvlp]]


#+name: getOrthoMatrix
#+begin_src c :main no :tangle cfgCI_utils.c
void getOrthoMatrix(int64_t Isomo, int64_t MS, double **orthoMatrixptr, int *rows, int *cols){

    int64_t NBF = 0;
    int64_t NSOMO = 0;

    Tree bftree = (Tree){  .rootNode = -1, .NBF = -1 };
    bftree.rootNode = malloc(sizeof(Node));
    (*bftree.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Isomo, MS, &bftree, &NBF, &NSOMO);

    //printTreeDriver(&bftree, NSOMO);

    // Initialize orthonormalization matrix
    (*orthoMatrixptr) = malloc(NBF*NBF*sizeof(double));
    (*rows) = NBF;
    (*cols) = NBF;

    double *orthoMatrix = (*orthoMatrixptr);

    //// initialize Matrix
    //for(int i = 0; i < NBF; i++)
    //    for(int j = 0; j < NBF; j++)
    //        orthoMatrix[i*NBF + j] = 0.0;

    int addI = 0;
    int addJ = 0;
    int *BF1 = malloc(MAX_SOMO * sizeof(int));
    int *BF2 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF1 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF2 = malloc(MAX_SOMO * sizeof(int));

    int g = 0;
    g = (NSOMO - MS)/2;
    printf("NBFs = %d NSOMOs = %d MS = %d g = %d\n",NBF,NSOMO,MS,g);

    int nislands; // Note that nislands < g always
    int phasefactor;

    int dictPhase[2];

    dictPhase[0] = 1;
    dictPhase[1] =-1;


    // Set block elements
    for(int i = 0; i < NBF; i++){
        addI = i;
        getIthBFDriver(&bftree, NSOMO, addI, BF1);
        getBFIndexList(NSOMO, BF1, IdxListBF1);

        //printf("addI : %d > ",addI);
        //for(int k=0;k<NSOMO;k++)
        //    printf("%d ",BF1[k]);
        //printf("\n");

        for(int j = 0; j < NBF; j++){
            addJ = j;
            getIthBFDriver(&bftree, NSOMO, addJ, BF2);
            getBFIndexList(NSOMO, BF2, IdxListBF2);
            //printf("addJ : %d > ",addI);
            //for(int k=0;k<NSOMO;k++)
            //    printf("%d ",BF2[k]);
            //printf("\n");

            // Get the i and r factors
            getIslands(NSOMO, BF1, BF2, &nislands, &phasefactor);

            //printf("(%d, %d) is=%d ph=%d fac=%10.15f\n",addI, addJ, nislands, phasefactor, phasefactor*1.0/(1 << (g-nislands)));

            orthoMatrix[i*NBF + j] = -1.0*phasefactor / (1 << (g - nislands));
        }
    }

    // Garbage collection
    free(BF1);
    free(IdxListBF1);
    free(BF2);
    free(IdxListBF2);

}
#+end_src

- [ ] Testing everything

#+begin_src C :main no :noweb yes :tangle main.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "/home/vijay/Documents/codes/qp2/plugins/local/pluginRepo/cfgCI/tree_utils.h"

<<inttobindigit>>

<<treefuncmain>>

<<indexlist>>

<<calculateislands>>

<<getNsomo>>

<<generateAllBFs>>

<<getOrthoMatrix>>

void main(){

    int rows = 0;
    int cols = 0;
    double *orthoMatrix;

    int64_t MS=0;

    int64_t Isomo;
    Isomo = (1 << 8) - 1;

    //int digit[MAX_SOMO];
    //int_to_bin_digit(Isomo, MAX_SOMO, digit);
    //for(int j=0;j<MAX_SOMO;j++)
    //    printf("%d ",digit[j]);
    //printf("\n");

    // Fill matrix
    getOrthoMatrix(Isomo, MS, &orthoMatrix, &rows, &cols);

    printRealMatrix(orthoMatrix, rows, cols);

    // Garbage collection
    free(orthoMatrix);

    return;
}
#+end_src

#+RESULTS:
|  NBFs |     = |    14 | NSOMOs |     = |     8 |    MS |     = |     0 |     g |     = |     4 |       |       |
|       |       |       |        |       |       |       |       |       |       |       |       |       |       |
|  -1.0 |   0.5 | -0.25 |  0.125 | -0.25 |   0.5 | -0.25 | -0.25 | 0.125 | 0.125 | -0.25 |   0.5 | 0.125 | -0.25 |
|   0.5 |  -1.0 |   0.5 |  -0.25 |   0.5 | -0.25 | 0.125 | 0.125 | -0.25 | -0.25 | 0.125 | -0.25 | -0.25 |   0.5 |
| -0.25 |   0.5 |  -1.0 |    0.5 | -0.25 |   0.5 | -0.25 | -0.25 | 0.125 | 0.125 | -0.25 | 0.125 |   0.5 | -0.25 |
| 0.125 | -0.25 |   0.5 |   -1.0 | 0.125 | -0.25 |   0.5 | 0.125 | -0.25 | -0.25 | 0.125 | -0.25 | -0.25 |   0.5 |
| -0.25 |   0.5 | -0.25 |  0.125 |  -1.0 |   0.5 | -0.25 | -0.25 |   0.5 |   0.5 | -0.25 | 0.125 | 0.125 | -0.25 |
|   0.5 | -0.25 |   0.5 |  -0.25 |   0.5 |  -1.0 |   0.5 |   0.5 | -0.25 | -0.25 |   0.5 | -0.25 | -0.25 | 0.125 |
| -0.25 | 0.125 | -0.25 |    0.5 | -0.25 |   0.5 |  -1.0 | -0.25 |   0.5 | 0.125 | -0.25 |   0.5 | 0.125 | -0.25 |
| -0.25 | 0.125 | -0.25 |  0.125 | -0.25 |   0.5 | -0.25 |  -1.0 |   0.5 | 0.125 | -0.25 | 0.125 |   0.5 | -0.25 |
| 0.125 | -0.25 | 0.125 |  -0.25 |   0.5 | -0.25 |   0.5 |   0.5 |  -1.0 | -0.25 | 0.125 | -0.25 | -0.25 |   0.5 |
| 0.125 | -0.25 | 0.125 |  -0.25 |   0.5 | -0.25 | 0.125 | 0.125 | -0.25 |  -1.0 |   0.5 | -0.25 | -0.25 |   0.5 |
| -0.25 | 0.125 | -0.25 |  0.125 | -0.25 |   0.5 | -0.25 | -0.25 | 0.125 |   0.5 |  -1.0 |   0.5 |   0.5 | -0.25 |
|   0.5 | -0.25 | 0.125 |  -0.25 | 0.125 | -0.25 |   0.5 | 0.125 | -0.25 | -0.25 |   0.5 |  -1.0 | -0.25 |   0.5 |
| 0.125 | -0.25 |   0.5 |  -0.25 | 0.125 | -0.25 | 0.125 |   0.5 | -0.25 | -0.25 |   0.5 | -0.25 |  -1.0 |   0.5 |
| -0.25 |   0.5 | -0.25 |    0.5 | -0.25 | 0.125 | -0.25 | -0.25 |   0.5 |   0.5 | -0.25 |   0.5 |   0.5 |  -1.0 |


** Make the prototype matrices

The prototype matrices give the matrix-elements (MEs) for a given type
of excitation \(p->q\) of a specific type between two CFGs \(I,J\).

These matrices are independent of the MOs and only depend on the total number of
electrons \(nel\), total number of orbitals \(norb\), and the total spin \(S\).

#+name: makePrototypeMatrices
#+begin_src c
void makePrototypeMatrices(int nel, int norb, double spin);
#+end_src

** Functions required for calculating MEs

*** TODO [1/4] Table of matrix-elements

The first step twoards the evaluation of MEs between bonded-functions is
the tabulation of the effect of the application of the operator on BFs.

There are four type of cases depending on the type of orbitals for the excitaton
i.e. for \(\hat{E}_{ji}\), the type of orbitals possible for \(i\) are DOMO or
SOMO and the type of orbitals possible for \(j\) are SOMO or VMO respectively.
The table of MEs will be different in each case

Here is a table which lists the action of E_{j,i} on all the various
cases of BFs that can arise.

- [ ] SOMO -> VMO type

  This is the simplest type. The \(i\) th SOMO is simply replaced
  by the \(j\) th one.

#+name: SOMO -> VMO
| BF (ket) | Type | Operator         | BF (bra) |
|          |      | \(\hat{E}_{ji}\) |          |
|          |      |                  |          |
| (i       | C-C  | \(1\)            | (j       |
|          |      |                  |          |

- [X] SOMO -> SOMO type

This is slightly involved depending on the type of SOMO \(i\)
and type of SOMO \(j\) and to which islands they belong to.

#+name: SOMO -> SOMO
| BF (ket)    | Type | Operator                | BF (bra) |
|             |      | \(\hat{E}_{ji}\)        |          |
|             |      |                         |          |
| (i j)       | C-C  | \(\sqrt{2}\)            | -        |
| (i k) (j l) | C-C' | \(-\frac{1}{\sqrt{2}}\) | (kl)     |
| (i k) (j    | C-O  | \(-\frac{1}{\sqrt{2}}\) | (k       |
| (i (j k)    | O-C  | \(-\frac{1}{\sqrt{2}}\) | (k       |
| (i (j       | O-C  | \(0\)                   | -        |
|             |      |                         |          |

- [ ] DOMO -> VMO

  Here two extra SOMOs will be created and the MEs of
  the operator will form a rectangular matrix.

#+name: DOMO -> SOMO
| BF (ket) | Type | Operator         | BF (bra)   |
|          |      | \(\hat{E}_{ji}\) |            |
|          |      |                  |            |
| (ii)     | O    | \(\sqrt{2}\)     | (i j)      |
| (ii)     | C    | \(0\)            | (i k)(j l) |
|          |      |                  |            |

- [ ] DOMO -> SOMO

  Here the total number of SOMOs is kept the same therefore,
  there is no change in the BFs for bra and ket functions.

#+name: DOMO -> SOMO
| BF (ket) | Type | Operator         | BF (bra) |
|          |      | \(\hat{E}_{ji}\) |          |
|          |      |                  |          |
| (ii      | O    | \( 1\)           | (j       |
| (i k)    | C    | \(-1\)           | (j k)    |
|          |      |                  |          |

** TODO [0/4] Calculate the Operator MEs

The operator matrix-elements are calculated using the bonded-function (or
determinant) basis and are called \( A^{pq}_{IK} \), where \(p,q\) are the two
molecular orbital indices and \(I,K\) are the two CFGs.

Note that this function simply returns the value from a prototype lookup table
which contains the pretabulated values for a given \(p,q\) excitation of a
specified type which is one of the four:

1. SOMO \(->\) VMO
2. SOMO \(->\) SOMO
3. DOMO \(->\) VMO
4. DOMO \(->\) SOMO




- [ ] SOMO -> VMO type

  This case is the simplest and there is only one
  non-vanising ME as shown in Table:[[SOMO -> VMO]].
  Therefore, the one-electron operator MEs are
  that of the identity matrix.

- [ ] SOMO -> SOMO type

  The MEs for the various types are given in Table:[[SOMO -> SOMO]].
  Here we implement the rules.

#+name: calculateMETypeSOMOSOMO
#+begin_src C :main no :tangle cfgCI_utils.c
void calculateMETypeSOMOSOMO(int NSOMO, int *BF1, int *BF2, double *factor, int *phasefactor){

    // Calculate the factor following rules in the table
    // find the type

}
#+end_src

#+name: METypeSOMOVMO
#+begin_src C :main no :tangle cfgCI_utils.c
void getOneElMETypeSOMOVMO(int64_t Isomo, int64_t Jsomos, int MS, double **oneElMatrixElementsptr, int *rows, int *cols){

    // Icfg

    int64_t INBF = 0;
    int64_t INSOMO = 0;

    Tree Ibftree = (Tree){  .rootNode = -1, .NBF = -1 };
    Ibftree.rootNode = malloc(sizeof(Node));
    (*Ibftree.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Isomo, MS, &Ibftree, &INBF, &INSOMO);

    // Jcfg

    int64_t JNBF = 0;
    int64_t JNSOMO = 0;

    Tree Jbftree = (Tree){  .rootNode = -1, .NBF = -1 };
    Jbftree.rootNode = malloc(sizeof(Node));
    (*Jbftree.rootNode) = (Node){ .C0 = -1, .C1 = -1, .PREV = -1, .addr = 0, .cpl = -1, .iSOMO = -1};

    generateAllBFs(Jsomo, MS, &Jbftree, &JNBF, &JNSOMO);


    // Initialize orthonormalization matrix

    (*oneElMatrixElementsptr) = malloc(INBF*JNBF*sizeof(double));
    (*rows) = INBF;
    (*cols) = JNBF;

    double *oneElMatrixElements = (*oneElMatrixElementsptr);

    // Calculate Matrix

    int addI = 0;
    int addJ = 0;
    int *BF1 = malloc(MAX_SOMO * sizeof(int));
    int *BF2 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF1 = malloc(MAX_SOMO * sizeof(int));
    int *IdxListBF2 = malloc(MAX_SOMO * sizeof(int));

    int g = 0;
    g = (NSOMO - MS)/2;
    printf("NBFs = %d NSOMOs = %d MS = %d g = %d\n",NBF,NSOMO,MS,g);

    int nislands; // Note that nislands < g always
    int phasefactor;

    int dictPhase[2];

    dictPhase[0] = 1;
    dictPhase[1] =-1;


    // Set block elements
    for(int i = 0; i < INBF; i++){
        addI = i;
        getIthBFDriver(&Ibftree, NSOMO, addI, BF1);
        getBFIndexList(NSOMO, BF1, IdxListBF1);

        //printf("addI : %d > ",addI);
        //for(int k=0;k<NSOMO;k++)
        //    printf("%d ",BF1[k]);
        //printf("\n");

        for(int j = 0; j < JNBF; j++){
            addJ = j;
            getIthBFDriver(&Jbftree, NSOMO, addJ, BF2);
            getBFIndexList(NSOMO, BF2, IdxListBF2);
            //printf("addJ : %d > ",addI);
            //for(int k=0;k<NSOMO;k++)
            //    printf("%d ",BF2[k]);
            //printf("\n");

            // Get the i and r factors
            calculateMETypeSOMOSOMO(NSOMO, IdxListBF1, IdxListBF2, &factor, &phasefactor);

            //printf("(%d, %d) is=%d ph=%d fac=%10.15f\n",addI, addJ, nislands, phasefactor, phasefactor*1.0/(1 << (g-nislands)));

            oneElMatrixElements[i*INBF + j] = -1.0*phasefactor*factor;
        }
    }

    // Garbage collection
    free(BF1);
    free(IdxListBF1);
    free(BF2);
    free(IdxListBF2);
}
#+end_src

- [ ] DOMO -> VMO type

- [ ] DOMO -> SOMO type


#+name: getOneElOperatorMatrix
#+begin_src c
void getOneElOperatorMatrix(int *cfgI, int *cfgK);
#+end_src

** Sigma-Vector I

The one-electron part \( \sum_{pq} \tilde{h}_{pq} <\Psi|\hat{E}_{pq}|\Psi>\).

** Sigma-Vector II

The two-electron part \(\frac{1}{2} \sum_{pq,rs} g(pq,rs) <\Psi|\hat{E}_{pq}\hat{E}_{rs}|\Psi> \)

*** Function to calculate Sigma-Vector

#+name: calcSigmaFunction
#+begin_src c :results output
<<getOrthoMatrix>>
void calcSigma(double *coeff, double *Gpqrs);
#+end_src

* Bibliography

bibliography:biblio.org
